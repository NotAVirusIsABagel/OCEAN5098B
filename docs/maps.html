<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>…</title>

<script src="site_libs/header-attrs-2.21/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/clipboard-2.0.6/clipboard.min.js"></script>
<link href="site_libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
<script src="site_libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
<script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; } /* Alert */
code span.an { color: #008000; } /* Annotation */
code span.at { } /* Attribute */
code span.bu { } /* BuiltIn */
code span.cf { color: #0000ff; } /* ControlFlow */
code span.ch { color: #008080; } /* Char */
code span.cn { color: #585cf6; } /* Constant */
code span.co { color: #4c886b; } /* Comment */
code span.cv { color: #008000; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.dv { color: #0000cd; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cd; } /* Float */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #0000ff; } /* Keyword */
code span.op { color: #687687; } /* Operator */
code span.ot { color: #ff4000; } /* Other */
code span.pp { color: #ff4000; } /* Preprocessor */
code span.sc { color: #008080; } /* SpecialChar */
code span.ss { color: #008080; } /* SpecialString */
code span.st { color: #036a07; } /* String */
code span.va { } /* Variable */
code span.vs { color: #008080; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */

.sourceCode .row {
  width: 100%;
}
.sourceCode {
  overflow-x: auto;
}
.code-folding-btn {
  margin-right: -30px;
}
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">OCEAN_5098</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="environment.html">Environment</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Manipulation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="TEMP_basics.html">Basics</a>
    </li>
    <li>
      <a href="TEMP_dplyr.html">dplyr</a>
    </li>
    <li>
      <a href="TEMP_tidyr.html">tidyr</a>
    </li>
  </ul>
</li>
<li>
  <a href="TEMP_types.html">Types &amp; structures</a>
</li>
<li>
  <a href="maps.html">Mapping</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">…</h1>

</div>


<a href="data:text/x-markdown;base64,LS0tDQp0aXRsZTogIi4uLiINCi0tLQ0KDQoNCmBgYHtyIGV2YWwgPSBUUlVFLCAgbWVzc2FnZT1GLCBpbmNsdWRlPUZBTFNFLCB3YXJuaW5nPUYsIHB1cmw9RiwgcmVzdWx0cz0iaGlkZSJ9DQprbml0cjo6cHVybCgnbWFwcy5SbWQnLCBkb2N1bWVudGF0aW9uID0gMCkNCmBgYA0KDQoNCmBgYHtyIGVjaG89RkFMU0UsIHB1cmw9Rn0NCnhmdW46OmVtYmVkX2ZpbGUoJ21hcHMuUm1kJykNCmBgYA0KDQpgYGB7ciBlY2hvPUZBTFNFLCBwdXJsPUZ9DQp4ZnVuOjplbWJlZF9maWxlKCdtYXBzLlInKQ0KYGBgDQoNCg0KYGBge3IgZWNobz1GQUxTRX0NCnhhcmluZ2FuRXh0cmE6OnVzZV9jbGlwYm9hcmQoKQ0KYGBgDQoNCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNClRoaXMgaXMgYW4gaW50cm9kdWN0aW9uIHRvIHNwYXRpYWwgZGF0YSBtYW5pcHVsYXRpb24gd2l0aCBSIGFuZCB0aGUgdGVycmEgcGFja2FnZS4gSW4gdGhpcyBjb250ZXh0IOKAnHNwYXRpYWwgZGF0YeKAnSByZWZlcnMgdG8gZGF0YSBhYm91dCBnZW9ncmFwaGljYWwgbG9jYXRpb25zLCB0aGF0IGlzLCBwbGFjZXMgb24gZWFydGguIFNvIHRvIGJlIG1vcmUgcHJlY2lzZSwgd2Ugc2hvdWxkIHNwZWFrIGFib3V0ICoqZ2Vvc3BhdGlhbCoqIGRhdGEsIGJ1dCB3ZSB1c2UgdGhlIHNob3J0aGFuZCAqKnNwYXRpYWwqKi4NCg0KVGhlIHBhY2thZ2UgYHRlcnJhYCBpcyBub3cgdGhlIHBhY2thZ2Ugb2YgcmVmZXJlbmNlIGZvciBtYW5pcHVsYXRpbmcgc3BhdGlhbCBkYXRhLCBzcGF0aWFsIGFuYWx5c2lzIGFuZCBtb2RlbGluZyBpbiBSLiBJdCBpcyBhIHZlcnkgbGFyZ2UgdG9waWNzIGFuZCBoZXJlIHdlIGNvdmVyIHRoZSBiYXNpY3Mgb2YgZGF0YSBtYW5pcHVsYXRpb24uDQoNCkJlY2F1c2Ugb2YgdGhlIG1hbnkgY2hhbmdlcyBoYXBwZW5pbmcgaW4gdGhlIHBhc3QgZmV3IHllYXJzIHJlbGF0ZWQgdG8gc3BhdGlhbCBkYXRhIGFuYWx5c2lzIGluIFIsIHRoaXMgc2VjdGlvbiBvZiB0aGUgY291cnNlIGlzIHN0aWxsIHVuZGVyIGRldmVsb3BlbWVudC4gKipUaGUgaW5mb3JtYXRpb24gYmVsb3cgYXJlIGxhcmdlbHkgZXh0cmFjdGVkIGZvcm0gVGVycmEgb25saW5lIHR1dG9yaWFsIGF2YWlsYWJsZSBbaGVyZV0oaHR0cHM6Ly9yc3BhdGlhbC5vcmcvc3BhdGlhbC8yLXNwYXRpYWxkYXRhLmh0bWwpLioqDQoNCg0KIyBTcGF0aWFsIGRhdGENCg0KU3BhdGlhbCBwaGVub21lbmEgY2FuIGdlbmVyYWxseSBiZSB0aG91Z2h0IG9mIGFzIGVpdGhlciBkaXNjcmV0ZSBvYmplY3RzIHdpdGggY2xlYXIgYm91bmRhcmllcyBvciBhcyBhIGNvbnRpbnVvdXMgcGhlbm9tZW5hIHRoYXQgY2FuIGJlIG9ic2VydmVkIGV2ZXJ5d2hlcmUsIGJ1dCB0aGF0IGRvIG5vdCBoYXZlIG5hdHVyYWwgYm91bmRhcmllcy4gRGlzY3JldGUgc3BhdGlhbCBvYmplY3RzIG1heSByZWZlciB0byBhIHJpdmVyLCByb2FkLCBjb3VudHJ5LCB0b3duLCBvciBhIHJlc2VhcmNoIHNpdGUuIEV4YW1wbGVzIG9mIGNvbnRpbnVvdXMgcGhlbm9tZW5hLCBvciAqKnNwYXRpYWwgZmllbGRzKiosIGluY2x1ZGUgZWxldmF0aW9uLCB0ZW1wZXJhdHVyZSwgYW5kIGFpciBxdWFsaXR5Lg0KDQpTcGF0aWFsIG9iamVjdHMgYXJlIHVzdWFsbHkgcmVwcmVzZW50ZWQgYnkgdmVjdG9yIGRhdGEuIFN1Y2ggZGF0YSBjb25zaXN0cyBvZiBhIGRlc2NyaXB0aW9uIG9mIHRoZSAqKmdlb21ldHJ5Kiogb3IgKipzaGFwZSoqIG9mIHRoZSBvYmplY3RzLCBhbmQgbm9ybWFsbHkgYWxzbyBpbmNsdWRlcyBhZGRpdGlvbmFsIHZhcmlhYmxlcy4gRm9yIGV4YW1wbGUsIGEgdmVjdG9yIGRhdGEgc2V0IG1heSByZXByZXNlbnQgdGhlIGJvcmRlcnMgb2YgdGhlIGNvdW50cmllcyBvZiB0aGUgd29ybGQgKGdlb21ldHJ5KSwgYW5kIGFsc28gc3RvcmUgdGhlaXIgbmFtZXMgYW5kIHRoZSBzaXplIG9mIHRoZWlyIHBvcHVsYXRpb24gaW4gMjAxNTsgb3IgaXQgbWF5IGhhdmUgdGhlIGdlb21ldHJ5IG9mIHRoZSByb2FkcyBpbiBhbiBhcmVhLCBhcyB3ZWxsIGFzIHRoZWlyIHR5cGUgYW5kIG5hbWVzLiBUaGVzZSBhZGRpdGlvbmFsIHZhcmlhYmxlcyBhcmUgb2Z0ZW4gcmVmZXJyZWQgdG8gYXMgKiphdHRyaWJ1dGVzKiouIENvbnRpbnVvdXMgc3BhdGlhbCBkYXRhIChmaWVsZHMpIGFyZSB1c3VhbGx5IHJlcHJlc2VudGVkIHdpdGggYSByYXN0ZXIgZGF0YSBzdHJ1Y3R1cmUuIFdlIGRpc2N1c3MgdGhlc2UgdHdvIGRhdGEgdHlwZXMgaW4gdHVybi4NCg0KIyMgVmVjdG9yIGRhdGENCg0KVGhlIG1haW4gdmVjdG9yIGRhdGEgdHlwZXMgYXJlIHBvaW50cywgbGluZXMgYW5kIHBvbHlnb25zLiBJbiBhbGwgY2FzZXMsIHRoZSBnZW9tZXRyeSBvZiB0aGVzZSBkYXRhIHN0cnVjdHVyZXMgY29uc2lzdHMgb2Ygc2V0cyBvZiBjb29yZGluYXRlIHBhaXJzICh4LCB5KS4gUG9pbnRzIGFyZSB0aGUgc2ltcGxlc3QgY2FzZS4gRWFjaCBwb2ludCBoYXMgb25lIGNvb3JkaW5hdGUgcGFpciwgYW5kIG4gYXNzb2NpYXRlZCB2YXJpYWJsZXMuIEZvciBleGFtcGxlLCBhIHBvaW50IG1pZ2h0IHJlcHJlc2VudCBhIHBsYWNlIHdoZXJlIGEgcmF0IHdhcyB0cmFwcGVkLCBhbmQgdGhlIGF0dHJpYnV0ZXMgY291bGQgaW5jbHVkZSB0aGUgZGF0ZSBpdCB3YXMgY2FwdHVyZWQsIHRoZSBwZXJzb24gd2hvIGNhcHR1cmVkIGl0LCB0aGUgc3BlY2llcyBzaXplIGFuZCBzZXgsIGFuZCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGFiaXRhdC4gSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBjb21iaW5lIHNldmVyYWwgcG9pbnRzIGludG8gYSBtdWx0aS1wb2ludCBzdHJ1Y3R1cmUsIHdpdGggYSBzaW5nbGUgYXR0cmlidXRlIHJlY29yZC4gRm9yIGV4YW1wbGUsIGFsbCB0aGUgY29mZmVlIHNob3BzIGluIGEgdG93biBjb3VsZCBiZSBjb25zaWRlcmVkIGFzIGEgc2luZ2xlIGdlb21ldHJ5Lg0KDQpUaGUgZ2VvbWV0cnkgb2YgbGluZXMgaXMgYSBqdXN0IGEgbGl0dGxlIGJpdCBtb3JlIGNvbXBsZXguIEZpcnN0IG5vdGUgdGhhdCBpbiB0aGlzIGNvbnRleHQsIHRoZSB0ZXJtICpsaW5lKiByZWZlcnMgdG8gYSBzZXQgb2Ygb25lIG9yIG1vcmUgcG9seWxpbmVzIChjb25uZWN0ZWQgc2VyaWVzIG9mIGxpbmUgc2VnbWVudHMpLiBGb3IgZXhhbXBsZSwgaW4gc3BhdGlhbCBhbmFseXNpcywgYSByaXZlciBhbmQgYWxsIGl0cyB0cmlidXRhcmllcyBjb3VsZCBiZSBjb25zaWRlcmVkIGFzIGEgc2luZ2xlICpsaW5lKiAoYnV0IHRoZXkgY291bGQgYWxzbyBhbHNvIGJlIHNldmVyYWwgbGluZXMsIHBlcmhhcHMgb25lIGZvciBlYWNoIHRyaWJ1dGFyeSByaXZlcikuIExpbmVzIGFyZSByZXByZXNlbnRlZCBhcyBvcmRlcmVkIHNldHMgb2YgY29vcmRpbmF0ZXMgKG5vZGVzKS4gVGhlIGFjdHVhbCBsaW5lIHNlZ21lbnRzIGNhbiBiZSBjb21wdXRlZCAoYW5kIGRyYXduIG9uIGEgbWFwKSBieSBjb25uZWN0aW5nIHRoZSBwb2ludHMuIFRodXMsIHRoZSByZXByZXNlbnRhdGlvbiBvZiBhIGxpbmUgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgYSBtdWx0aS1wb2ludCBzdHJ1Y3R1cmUuIFRoZSBtYWluIGRpZmZlcmVuY2UgaXMgdGhhdCBmb3IgYSBsaW5lIHRoZSBvcmRlcmluZyBvZiB0aGUgcG9pbnRzIGlzIGltcG9ydGFudCwgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgaW4gd2hpY2ggb3JkZXIgdGhlIHBvaW50cyBzaG91bGQgYmUgY29ubmVjdGVkLg0KDQpBIG5ldHdvcmsgKGUuZy4gYSByb2FkIG9yIHJpdmVyIG5ldHdvcmspLCBvciBzcGF0aWFsIGdyYXBoLCBpcyBhIHNwZWNpYWwgdHlwZSBvZiBsaW5lcyBnZW9tZXRyeSB3aGVyZSB0aGVyZSBpcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoaW5ncyBsaWtlIGZsb3csIGNvbm5lY3Rpdml0eSwgZGlyZWN0aW9uLCBhbmQgZGlzdGFuY2UuDQoNCkEgcG9seWdvbiByZWZlcnMgdG8gYSBzZXQgb2YgY2xvc2VkIHBvbHlsaW5lcy4gVGhlIGdlb21ldHJ5IGlzIHZlcnkgc2ltaWxhciB0byB0aGF0IG9mIGxpbmVzLCBidXQgdG8gY2xvc2UgYSBwb2x5Z29uIHRoZSBsYXN0IGNvb3JkaW5hdGUgcGFpciBjb2luY2lkZXMgd2l0aCB0aGUgZmlyc3QgcGFpci4gQSBjb21wbGljYXRpb24gd2l0aCBwb2x5Z29ucyBpcyB0aGF0IHRoZXkgY2FuIGhhdmUgaG9sZXMgKHRoYXQgaXMgYSBwb2x5Z29uIGVudGlyZWx5IGVuY2xvc2VkIGJ5IGFub3RoZXIgcG9seWdvbiwgdGhhdCBzZXJ2ZXMgdG8gcmVtb3ZlIHBhcnRzIG9mIHRoZSBlbmNsb3NpbmcgcG9seWdvbiAoZm9yIGV4YW1wbGUgdG8gc2hvdyBhbiBpc2xhbmQgaW5zaWRlIGEgbGFrZS4gQWxzbywgdmFsaWQgcG9seWdvbnMgZG8gbm90IHNlbGYtaW50ZXJzZWN0IChidXQgaXQgaXMgT0sgZm9yIGEgbGluZSB0byBzZWxmLWNyb3NzKS4gQWdhaW4sIG11bHRpcGxlIHBvbHlnb25zIGNhbiBiZSBjb25zaWRlcmVkIGFzIGEgc2luZ2xlIGdlb21ldHJ5LiBGb3IgZXhhbXBsZSwgSW5kb25lc2lhIGNvbnNpc3RzIG9mIG1hbnkgaXNsYW5kcy4gRWFjaCBpc2xhbmQgY2FuIGJlIHJlcHJlc2VudGVkIGJ5IGEgc2luZ2xlIHBvbHlnb24sIGJ1dCB0b2dldGhlciB0aGVuIGNhbiBiZSByZXByZXNlbnQgYSBzaW5nbGUgKG11bHRpLSkgcG9seWdvbiByZXByZXNlbnRpbmcgdGhlIGVudGlyZSBjb3VudHJ5Lg0KDQojIyBSYXN0ZXIgZGF0YQ0KDQpSYXN0ZXIgZGF0YSBpcyBjb21tb25seSB1c2VkIHRvIHJlcHJlc2VudCBzcGF0aWFsbHkgY29udGludW91cyBwaGVub21lbmEgc3VjaCBhcyBlbGV2YXRpb24uIEEgcmFzdGVyIGRpdmlkZXMgdGhlIHdvcmxkIGludG8gYSBncmlkIG9mIGVxdWFsbHkgc2l6ZWQgcmVjdGFuZ2xlcyAocmVmZXJyZWQgdG8gYXMgY2VsbHMgb3IsIGluIHRoZSBjb250ZXh0IG9mIHNhdGVsbGl0ZSByZW1vdGUgc2Vuc2luZywgcGl4ZWxzKSB0aGF0IGFsbCBoYXZlIG9uZSBvciBtb3JlIHZhbHVlcyAob3IgbWlzc2luZyB2YWx1ZXMpIGZvciB0aGUgdmFyaWFibGVzIG9mIGludGVyZXN0LiBBIHJhc3RlciBjZWxsIHZhbHVlIHNob3VsZCBub3JtYWxseSByZXByZXNlbnQgdGhlIGF2ZXJhZ2UgKG9yIG1ham9yaXR5KSB2YWx1ZSBmb3IgdGhlIGFyZWEgaXQgY292ZXJzLiBIb3dldmVyLCBpbiBzb21lIGNhc2VzIHRoZSB2YWx1ZXMgYXJlIGFjdHVhbGx5IGVzdGltYXRlcyBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2VsbCAoaW4gZXNzZW5jZSBiZWNvbWluZyBhIHJlZ3VsYXIgc2V0IG9mIHBvaW50cyB3aXRoIGFuIGF0dHJpYnV0ZSkuDQoNCkluIGNvbnRyYXN0IHRvIHZlY3RvciBkYXRhLCBpbiByYXN0ZXIgZGF0YSB0aGUgZ2VvbWV0cnkgaXMgbm90IGV4cGxpY2l0bHkgc3RvcmVkIGFzIGNvb3JkaW5hdGVzLiBJdCBpcyBpbXBsaWNpdGx5IHNldCBieSBrbm93aW5nIHRoZSBzcGF0aWFsIGV4dGVudCBhbmQgdGhlIG51bWJlciBvciByb3dzIGFuZCBjb2x1bW5zIGluIHdoaWNoIHRoZSBhcmVhIGlzIGRpdmlkZWQuIEZyb20gdGhlIGV4dGVudCBhbmQgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMsIHRoZSBzaXplIG9mIHRoZSByYXN0ZXIgY2VsbHMgKHNwYXRpYWwgcmVzb2x1dGlvbikgY2FuIGJlIGNvbXB1dGVkLiBXaGlsZSByYXN0ZXIgY2VsbHMgY2FuIGJlIHRob3VnaHQgb2YgYXMgYSBzZXQgb2YgcmVndWxhciBwb2x5Z29ucywgaXQgd291bGQgYmUgdmVyeSBpbmVmZmljaWVudCB0byByZXByZXNlbnQgdGhlIGRhdGEgdGhhdCB3YXkgYXMgY29vcmRpbmF0ZXMgZm9yIGVhY2ggY2VsbCB3b3VsZCBoYXZlIHRvIGJlIHN0b3JlZCBleHBsaWNpdGx5LiBEb2luZyBzbyB3b3VsZCBhbHNvIGRyYW1hdGljYWxseSBpbmNyZWFzZSBwcm9jZXNzaW5nIHRpbWUuDQoNCkNvbnRpbnVvdXMgc3VyZmFjZSBkYXRhIGFyZSBzb21ldGltZXMgc3RvcmVkIGFzIHRyaWFuZ3VsYXRlZCBpcnJlZ3VsYXIgbmV0d29ya3MgKFRJTnMpOyB0aGVzZSBhcmUgbm90IGRpc2N1c3NlZCBoZXJlLg0KDQojIyBTaW1wbGUgcmVwcmVzZW50YXRpb24gb2Ygc3BhdGlhbCBkYXRhDQoNClRoZSBiYXNpYyBkYXRhIHR5cGVzIGluIFIgYXJlIG51bWJlcnMsIGNoYXJhY3RlcnMsIGxvZ2ljYWwgKFRSVUUgb3IgRkFMU0UpIGFuZCBmYWN0b3IgdmFsdWVzLiBWYWx1ZXMgb2YgYSBzaW5nbGUgdHlwZSBjYW4gYmUgY29tYmluZWQgaW4gdmVjdG9ycyBhbmQgbWF0cmljZXMsIGFuZCB2YXJpYWJsZXMgb2YgbXVsdGlwbGUgdHlwZXMgY2FuIGJlIGNvbWJpbmVkIGludG8gYSBkYXRhLmZyYW1lLiBXZSBjYW4gcmVwcmVzZW50IChvbmx5IHZlcnkpIGJhc2ljIHNwYXRpYWwgZGF0YSB3aXRoIHRoZXNlIGRhdGEgdHlwZXMuIExldOKAmXMgc2F5IHdlIGhhdmUgdGhlIGxvY2F0aW9uIChyZXByZXNlbnRlZCBieSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlKSBvZiB0ZW4gd2VhdGhlciBzdGF0aW9ucyAobmFtZWQgQSB0byBKKSBhbmQgdGhlaXIgYW5udWFsIHByZWNpcGl0YXRpb24uDQoNCkluIHRoZSBleGFtcGxlIGJlbG93IHdlIG1ha2UgYSB2ZXJ5IHNpbXBsZSBtYXAuIE5vdGUgdGhhdCBhIG1hcCBpcyBzcGVjaWFsIHR5cGUgb2YgcGxvdCAobGlrZSBhIHNjYXR0ZXIgcGxvdCwgYmFycGxvdCwgZXRjLikuIEEgbWFwIGlzIGEgcGxvdCBvZiBnZW9zcGF0aWFsIGRhdGEgdGhhdCBhbHNvIGhhcyBsYWJlbHMgYW5kIG90aGVyIGdyYXBoaWNhbCBvYmplY3RzIHN1Y2ggYXMgYSBzY2FsZSBiYXIgb3IgbGVnZW5kLiBUaGUgc3BhdGlhbCBkYXRhIGl0c2VsZiBzaG91bGQgbm90IGJlIHJlZmVycmVkIHRvIGFzIGEgbWFwLg0KDQpgYGB7ciwgIGV2YWw9VH0NCm5hbWUgPC0gTEVUVEVSU1sxOjEwXQ0KbG9uZ2l0dWRlIDwtIGMoLTExNi43LCAtMTIwLjQsIC0xMTYuNywgLTExMy41LCAtMTE1LjUsDQogICAgICAgICAgICAgICAtMTIwLjgsIC0xMTkuNSwgLTExMy43LCAtMTEzLjcsIC0xMTAuNykNCmxhdGl0dWRlIDwtIGMoNDUuMywgNDIuNiwgMzguOSwgNDIuMSwgMzUuNywgMzguOSwNCiAgICAgICAgICAgICAgMzYuMiwgMzksIDQxLjYsIDM2LjkpDQpzdGF0aW9ucyA8LSBjYmluZChsb25naXR1ZGUsIGxhdGl0dWRlKQ0KIyBTaW11bGF0ZWQgcmFpbmZhbGwgZGF0YQ0Kc2V0LnNlZWQoMCkNCnByZWNpcCA8LSByb3VuZCgocnVuaWYobGVuZ3RoKGxhdGl0dWRlKSkqMTApXjMpDQpgYGANCg0KQSBtYXAgb2YgcG9pbnQgbG9jYXRpb25zIGlzIG5vdCB0aGF0IGRpZmZlcmVudCBmcm9tIGEgYmFzaWMgeC15IHNjYXR0ZXIgcGxvdC4gQmVsb3cgaXMgYSBwbG90IChhIG1hcCBpbiB0aGlzIGNhc2UpIHRoYXQgc2hvd3MgdGhlIGxvY2F0aW9uIG9mIHRoZSB3ZWF0aGVyIHN0YXRpb25zLCBhbmQgdGhlIHNpemUgb2YgdGhlIGRvdHMgaXMgcHJvcG9ydGlvbmFsIHRvIHRoZSBhbW91bnQgb2YgcHJlY2lwaXRhdGlvbi4gVGhlIHBvaW50IHNpemUgaXMgc2V0IHdpdGggYXJndW1lbnQgY2V4Lg0KDQpgYGB7ciwgIGV2YWw9VH0NCnBzaXplIDwtIDEgKyBwcmVjaXAvNTAwDQpwbG90KHN0YXRpb25zLCBjZXg9cHNpemUsIHBjaD0yMCwgY29sPSdyZWQnLCBtYWluPSdQcmVjaXBpdGF0aW9uJykNCiMgYWRkIG5hbWVzIHRvIHBsb3QNCnRleHQoc3RhdGlvbnMsIG5hbWUsIHBvcz00KQ0KIyBhZGQgYSBsZWdlbmQNCmJyZWFrcyA8LSBjKDEwMCwgMjUwLCA1MDAsIDEwMDApDQpsZWdlbmQucHNpemUgPC0gMSticmVha3MvNTAwDQpsZWdlbmQoInRvcHJpZ2h0IiwgbGVnZW5kPWJyZWFrcywgcGNoPTIwLCBwdC5jZXg9bGVnZW5kLnBzaXplLCBjb2w9J3JlZCcsIGJnPSdncmF5JykNCmBgYA0KDQpOb3RlIHRoYXQgdGhlIGRhdGEgYXJlIHJlcHJlc2VudGVkIGJ5IOKAnGxvbmdpdHVkZSwgbGF0aXR1ZGXigJ0sIGluIHRoYXQgb3JkZXIsIGRvIG5vdCB1c2Ug4oCcbGF0aXR1ZGUsIGxvbmdpdHVkZeKAnSBiZWNhdXNlIG9uIG1vc3QgbWFwcyBsYXRpdHVkZSAoTm9ydGgvU291dGgpIGlzIHVzZWQgZm9yIHRoZSB2ZXJ0aWNhbCBheGlzIGFuZCBsb25naXR1ZGUgKEVhc3QvV2VzdCkgZm9yIHRoZSBob3Jpem9udGFsIGF4aXMuIFRoaXMgaXMgaW1wb3J0YW50IHRvIGtlZXAgaW4gbWluZCwgYXMgaXQgaXMgYSB2ZXJ5IGNvbW1vbiBzb3VyY2Ugb2YgbWlzdGFrZXMhDQoNCg0KV2UgY2FuIGFkZCBtdWx0aXBsZSBzZXRzIG9mIHBvaW50cyB0byB0aGUgcGxvdCwgYW5kIGV2ZW4gZHJhdyBsaW5lcyBhbmQgcG9seWdvbnM6DQoNCg0KYGBge3IsICBldmFsPVR9DQpsb24gPC0gYygtMTE2LjgsIC0xMTQuMiwgLTExMi45LCAtMTExLjksIC0xMTQuMiwgLTExNS40LCAtMTE3LjcpDQpsYXQgPC0gYyg0MS4zLCA0Mi45LCA0Mi40LCAzOS44LCAzNy42LCAzOC4zLCAzNy42KQ0KeCA8LSBjYmluZChsb24sIGxhdCkNCnBsb3Qoc3RhdGlvbnMsIG1haW49J1ByZWNpcGl0YXRpb24nKQ0KcG9seWdvbih4LCBjb2w9J2JsdWUnLCBib3JkZXI9J2xpZ2h0IGJsdWUnKQ0KbGluZXMoc3RhdGlvbnMsIGx3ZD0zLCBjb2w9J3JlZCcpDQpwb2ludHMoeCwgY2V4PTIsIHBjaD0yMCkNCnBvaW50cyhzdGF0aW9ucywgY2V4PXBzaXplLCBwY2g9MjAsIGNvbD0ncmVkJywgbWFpbj0nUHJlY2lwaXRhdGlvbicpDQpgYGANCg0KVGhlIGFib3ZlIGlsbHVzdHJhdGVzIGhvdyBudW1lcmljIHZlY3RvcnMgcmVwcmVzZW50aW5nIGxvY2F0aW9ucyBjYW4gYmUgdXNlZCB0byBkcmF3IHNpbXBsZSBtYXBzLiBJdCBhbHNvIHNob3dzIGhvdyBwb2ludHMgY2FuIChhbmQgdHlwaWNhbGx5IGFyZSkgcmVwcmVzZW50ZWQgYnkgcGFpcnMgb2YgbnVtYmVycy4gQSBsaW5lIGFuZCBhIHBvbHlnb24gY2FuIGJlIHJlcHJlc2VudGVkIGJ5IGEgbnVtYmVyIG9mIHRoZXNlIHBvaW50cy4gUG9seWdvbnMgbmVlZCB0byDigJxjbG9zZWTigJ0sIHRoYXQgaXMsIHRoZSBmaXJzdCBwb2ludCBtdXN0IGNvaW5jaWRlIHdpdGggdGhlIGxhc3QgcG9pbnQsIGJ1dCB0aGUgYHBvbHlnb25gIGZ1bmN0aW9uIHRvb2sgY2FyZSBvZiB0aGF0IGZvciB1cy4NCg0KVGhlcmUgYXJlIGNhc2VzIHdoZXJlIGEgc2ltcGxlIGFwcHJvYWNoIGxpa2UgdGhpcyBtYXkgc3VmZmljZSBhbmQgeW91IG1heSBjb21lIGFjcm9zcyB0aGlzIGluIG9sZGVyIFIgY29kZSBvciBwYWNrYWdlcy4gTGlrZXdpc2UsIHJhc3RlciBkYXRhIGNvdWxkIGJlIHJlcHJlc2VudGVkIGJ5IGEgbWF0cml4IG9yIGhpZ2hlci1vcmRlciBhcnJheS4gUGFydGljdWxhcmx5IHdoZW4gb25seSBkZWFsaW5nIHdpdGggcG9pbnQgZGF0YSBzdWNoIGFuIGFwcHJvYWNoIG1heSBiZSBwcmFjdGljYWwuIEZvciBleGFtcGxlLCBhIHNwYXRpYWwgZGF0YSBzZXQgcmVwcmVzZW50aW5nIHBvaW50cyBhbmQgYXR0cmlidXRlcyBjb3VsZCBiZSBtYWRlIGJ5IGNvbWJpbmluZyBnZW9tZXRyeSBhbmQgYXR0cmlidXRlcyBpbiBhIHNpbmdsZSBgZGF0YS5mcmFtZWAuDQoNCmBgYHtyLCAgZXZhbD1UfQ0Kd3N0IDwtIGRhdGEuZnJhbWUobG9uZ2l0dWRlLCBsYXRpdHVkZSwgbmFtZSwgcHJlY2lwKQ0Kd3N0DQpgYGANCg0KDQpIb3dldmVyLCBgd3N0YCBpcyBhIGRhdGEuZnJhbWUgYW5kIFIgZG9lcyBub3QgYXV0b21hdGljYWxseSB1bmRlcnN0YW5kIHRoZSBzcGVjaWFsIG1lYW5pbmcgb2YgdGhlIGZpcnN0IHR3byBjb2x1bW5zLCBvciB0byB3aGF0IGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbSBpdCByZWZlcnMgKGxvbmdpdHVkZS9sYXRpdHVkZSwgb3IgcGVyaGFwcyBVVE0gem9uZSAxN1MsIG9yIOKApi4/KS4NCg0KTW9yZW92ZXIsIGl0IGlzIG5vbi10cml2aWFsIHRvIGRvIHNvbWUgYmFzaWMgc3BhdGlhbCBvcGVyYXRpb25zLiBGb3IgZXhhbXBsZSwgdGhlIGJsdWUgcG9seWdvbiBkcmF3biBvbiB0aGUgbWFwIGFib3ZlIG1pZ2h0IHJlcHJlc2VudCBhIHN0YXRlLCBhbmQgYSBuZXh0IHF1ZXN0aW9uIG1pZ2h0IGJlIHdoaWNoIG9mIHRoZSAxMCBzdGF0aW9ucyBmYWxsIHdpdGhpbiB0aGF0IHBvbHlnb24uIEFuZCBob3cgYWJvdXQgYW55IG90aGVyIG9wZXJhdGlvbiBvbiBzcGF0aWFsIGRhdGEsIGluY2x1ZGluZyByZWFkaW5nIGZyb20gYW5kIHdyaXRpbmcgZGF0YSB0byBmaWxlcz8gVG8gZmFjaWxpdGF0ZSBzdWNoIG9wZXJhdGlvbiBhIG51bWJlciBvZiBSIHBhY2thZ2VzIGhhdmUgYmVlbiBkZXZlbG9wZWQgdGhhdCBkZWZpbmUgbmV3IHNwYXRpYWwgZGF0YSB0eXBlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciB0aGlzIHR5cGUgb2Ygc3BlY2lhbGl6ZWQgb3BlcmF0aW9ucy4NCg0KUmVjZW50IHBhY2thZ2VzIGluIFIgdGhhdCBkZWZpbmUgc3VjaCBzcGF0aWFsIGRhdGEgc3RydWN0dXJlcyBpbmNsdWRlIGB0ZXJyYWAgYW5kIGBzZmAuIFRoZXNlIHBhY2thZ2VzIHJlcGxhY2UgYSBzZXQgb2Ygb2xkZXIgcGFja2FnZXMgaW5jbHVkaW5nIGByYXN0ZXJgIGFuZCBgc3BgLg0KDQpXZSBtb3N0bHkgdXNlIHRoZSBgdGVycmFgIHBhY2thZ2UgaW4gdGhlc2UgbWF0ZXJpYWxzLiBZb3UgY2FuIGluc3RhbGwgdGhlIGxhdGVzdCByZWxlYXNlZCB2ZXJzaW9uIG9mIHRlcnJhIGZyb20gQ1JBTiB3aXRoIGBpbnN0YWxsLnBhY2thZ2VzKCJ0ZXJyYSIpYC4NCg0KDQojIFJlYWRpbmcgYW5kIHdyaXRpbmcgc3BhdGlhbCBkYXRhDQoNCg0KUmVhZGluZyBhbmQgd3JpdGluZyBzcGF0aWFsIGRhdGEgaXMgY29tcGxpY2F0ZWQgYnkgdGhlIGZhY3QgdGhhdCB0aGVyZSBhcmUgbWFueSBkaWZmZXJlbnQgZmlsZSBmb3JtYXRzLiBIb3dldmVyLCB0aGVyZSBhcmUgYSBmZXcgZm9ybWF0cyB0aGF0IGFyZSBtb3N0IGNvbW1vbiB0aGF0IHdlIGRpc2N1c3MgaGVyZS4NCg0KIyMgVmVjdG9yIGZpbGVzDQoNClRoZSBzaGFwZWZpbGUgaXMgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBmaWxlIGZvcm1hdCBmb3IgdmVjdG9yIGRhdGEgKGlmIHlvdSBhcmUgbm90IGZhbWlsaWFyIHdpdGggdGhpcyBmaWxlIGZvcm1hdCwgYW4gaW1wb3J0YW50IHRoaW5nIHRvIHVuZGVyc3RhbmQgaXMgdGhhdCBhIHNoYXBlZmlsZSBpcyByZWFsbHkgYSBzZXQgb2YgYXQgbGVhc3QgdGhyZWUgKGlkZWFsbHkgZm91cikgZmlsZXMsIHdpdGggYWxsIHRoZSBzYW1lIG5hbWUsIGJ1dCBkaWZmZXJlbnQgZXh0ZW5zaW9uLiBGb3Igc2hhcGVmaWxlIHggeW91IG11c3QgaGF2ZSwgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LCB0aGVzZSB0aHJlZSBmaWxlczogeC5zaHAsIHguc2h4LCB4LmRiZiwgYW5kIGlkZWFsbHkgYWxzbyB4LnByai4NCg0KSXQgaXMgZWFzeSB0byByZWFkIGFuZCB3cml0ZSBzdWNoIGZpbGVzLiBIZXJlIHdlIHVzZSBhIHNoYXBlZmlsZSB0aGF0IGNvbWVzIHdpdGggdGhlIGB0ZXJyYWAgcGFja2FnZS4NCg0KIyMjIFJlYWRpbmcNCg0KTGV0J3MgZmlyc3QgZG93bmxvYWQgc29tZSBzcGF0aWFsIGRhdGEgb2YgVGFpd2FuIHVzaW5nIHRoZSBgZ2VvZGF0YWAgcGFja2FnZToNCg0KYGBge3IsICBldmFsPUZ9DQpsaWJyYXJ5IChnZW9kYXRhKQ0KI1RXTiA8LSBnYWRtKGNvdW50cnk9IlRXTiIsIGxldmVsPTEsIHBhdGg9dGVtcGRpcigpKQ0KI1RXTiA8LSBnYWRtKGNvdW50cnk9IlRXTiIsIGxldmVsPTEsIHBhdGg9Ii4vZGF0YSINClRXTiA8LSB2ZWN0KCdkYXRhL2dhZG0vZ2FkbTQxX1RXTl8xX3BrLnJkcycpDQpUV04NCiMgY2hlY2sgZm9yID9nYWRtDQpgYGANCg0KVXNpbmcgYSAuc2hwIGZpbGUsIHdlIGNhbiB1c2UgdGhlIGB2ZWN0YCBmdW5jdGlvbiBmcm9tIHRoZSBgdGVycmFgIHBhY2thZ2UgdG8gcmVhZCB0aGUgZmlsZS4gRmlyc3Q6DQoNCmBgYHtyLCAgZXZhbD1UfQ0KIyBleGFtcGxlIHVzaW5nIC5zaHAgZmlsZQ0KbGlicmFyeSh0ZXJyYSkNCmZpbGVuYW1lMSA8LSBzeXN0ZW0uZmlsZSgiZXgvbHV4LnNocCIsIHBhY2thZ2U9InRlcnJhIikNCmJhc2VuYW1lKGZpbGVuYW1lMSkNCmBgYA0KPiBXZSB1c2UgdGhlIHN5c3RlbS5maWxlIGZ1bmN0aW9uIHRvIGdldCB0aGUgZnVsbCBwYXRoIG5hbWUgb2YgdGhlIGZpbGXigJlzIGxvY2F0aW9uLiBXZSBuZWVkIHRvIGRvIHRoaXMgYXMgdGhlIGxvY2F0aW9uIG9mIHRoaXMgZmlsZSBkZXBlbmRzIG9uIHdoZXJlIHRoZSB0ZXJyYSBwYWNrYWdlIGlzIGluc3RhbGxlZC4gWW91IHNob3VsZCBub3QgdXNlIHRoZSBzeXN0ZW0uZmlsZSBmdW5jdGlvbiBmb3IgeW91ciBvd24gZmlsZXMuIEl0IG9ubHkgc2VydmVzIGZvciBjcmVhdGluZyBleGFtcGxlcyB3aXRoIGRhdGEgdGhhdCBzaGlwIHdpdGggUi4gV2l0aCB5b3VyIG93biBmaWxlcywganVzdCB1c2UgdGhlIGZpbGVuYW1lIChhbmQgcGF0aCBpZiB0aGUgZmlsZSBpcyBub3QgaW4geW91ciB3b3JraW5nIGRpcmVjdG9yeSkuDQoNClRoZW46DQoNCmBgYHtyLCAgZXZhbD1UfQ0KIyBleGFtcGxlIHVzaW5nIC5zaHAgZmlsZQ0KczEgPC0gdmVjdChmaWxlbmFtZTEpDQpzMQ0KYGBgDQoNClRoZSBgdmVjdGAgZnVuY3Rpb24gcmV0dXJucyBgU3BhdFZlY3RvcmAgb2JqZWN0cy4gSXQgaXMgaW1wb3J0YW50IHRvIHJlY29nbmlzZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgdHlwZSBvZiBSIG9iamVjdCAoYFNwYXRWZWN0b3JgKSwgYW5kIHRoZSBmaWxlICjigJxzaGFwZWZpbGXigJ0pIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIGl0LiBUaHVzLCB5b3Ugc2hvdWxkIG5ldmVyIHNheSDigJxJIGhhdmUgYSBzaGFwZWZpbGUgaW4gUuKAnSwgc2F5IOKAnEkgaGF2ZSBhIFNwYXRWZWN0b3Igb2YgcG9seWdvbnMgaW4gUuKAnSwgKGFuZCBpbiBzb21lIGNhc2VzIHlvdSBjYW4gYWRkIOKAnGNyZWF0ZWQgZnJvbSBhIHNoYXBlZmlsZeKAnSkuIFRoZSBzaGFwZWZpbGUgaXMgb25lIG9mIG1hbnkgZmlsZSBmb3JtYXRzIGZvciB2ZWN0b3IgZGF0YS4NCg0KIyMjIFdyaXRpbmcNCg0KWW91IGNhbiB3cml0ZSBuZXcgZmlsZXMgdXNpbmcgdGhlIGB3cml0ZVZlY3RvcmAgbWV0aG9kLiBZb3UgbmVlZCB0byBhZGQgYXJndW1lbnQgYG92ZXJ3cml0ZT1UUlVFYCBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgZmlsZS4NCg0KYGBge3IsICBldmFsPVR9DQpUV04gPC0gdmVjdCgnZGF0YS9nYWRtL2dhZG00MV9UV05fMV9way5yZHMnKQ0Kb3V0ZmlsZTEgPC0gImRhdGEvc2hwX1RXTi5zaHAiDQp3cml0ZVZlY3RvcihUV04sIG91dGZpbGUxLCBvdmVyd3JpdGU9VFJVRSkNCmBgYA0KDQojIyBSYXN0ZXIgZmlsZXMNCg0KVGhlIHRlcnJhIHBhY2thZ2UgY2FuIHJlYWQgYW5kIHdyaXRlIHNldmVyYWwgcmFzdGVyIGZpbGUgZm9ybWF0cy4NCg0KIyMjIFJlYWRpbmcgcmFzdGVyIGRhdGENCg0KDQpHZXQgcmFzdGVyIGRhdGEgb2YgdGFpd2FuIGVsZXZhdGlvbiB1c2luZyB0aGUgYGdlb2RhdGFgIHBhY2thZ2U6DQoNCmBgYHtyLCAgZXZhbD1UfQ0KbGlicmFyeShnZW9kYXRhKQ0KZWxlIDwtZWxldmF0aW9uXzMwcygiVFdOIiwgcGF0aD10ZW1wZGlyKCkpDQplbGUNCmBgYA0KDQpVc2luZyBhIC50aWYgZmlsZSwgd2UgY2FuIHVzZSB0aGUgYHJhc3RgIGZ1bmN0aW9uIGZyb20gdGhlIGB0ZXJyYWAgcGFja2FnZSB0byByZWFkIHRoZSBmaWxlLiBGaXJzdHVzaW5nIGV4YW1wbGUgZmlsZSBmcm9tIHRoZSBwYWNrYWdlOg0KDQpgYGB7ciwgIGV2YWw9VH0NCmYgPC0gc3lzdGVtLmZpbGUoImV4L2xvZ28udGlmIiwgcGFja2FnZT0idGVycmEiKQ0KYmFzZW5hbWUoZikNCmBgYA0KDQpOb3cgd2UgY2FuIGRvDQoNCmBgYHtyLCAgZXZhbD1UfQ0KciA8LSByYXN0KGYpDQpyDQpgYGANCg0KTm90ZSB0aGF0IHggaXMgYSBTcGF0UmFzdGVyIG9mIHRocmVlIGxheWVycyAo4oCcYmFuZHPigJ0pLiBXZSBjYW4gc3Vic2V0IGl0IHRvIGdldCBhIHNpbmdsZSBsYXllci4NCg0KYGBge3IsICBldmFsPVR9DQpyMiA8LSByW1syXV0NCnIyDQpgYGANCg0KVGhlIHNhbWUgYXBwcm9hY2ggaG9sZHMgZm9yIG90aGVyIHJhc3RlciBmaWxlIGZvcm1hdHMsIGluY2x1ZGluZyBHZW9UaWZmLCBOZXRDREYsIEltYWdpbmUsIGFuZCBFU1JJIEdyaWQgZm9ybWF0cy4NCg0KIyMjIFdyaXRpbmcgcmFzdGVyIGRhdGENCg0KVXNlIGB3cml0ZVJhc3RlcmAgdG8gd3JpdGUgcmFzdGVyIGRhdGEuIFlvdSBtdXN0IHByb3ZpZGUgYSBTcGF0UmFzdGVyIGFuZCBhIGZpbGVuYW1lLiBUaGUgZmlsZSBmb3JtYXQgd2lsbCBiZSBndWVzc2VkIGZyb20gdGhlIGZpbGVuYW1lIGV4dGVuc2lvbi4gSWYgdGhhdCBkb2VzIG5vdCB3b3JrIHlvdSBjYW4gcHJvdmlkZSBhbiBhcmd1bWVudCBsaWtlIGBmb3JtYXQ9R1RpZmZgLiBOb3RlIHRoZSBhcmd1bWVudCBgb3ZlcndyaXRlPVRSVUVgIGFuZCBzZWUgYD93cml0ZVJhc3RlcmAgZm9yIG1vcmUgYXJndW1lbnRzLCBzdWNoIGFzIGBkYXRhdHlwZT1gIHRvIHNldCB0aGUgYSBzcGVjaWZpYyBkYXRhdHlwZSAoZS5nLiwgaW50ZWdlcikuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KeCA8LSB3cml0ZVJhc3RlcihlbGUsICJkYXRhL2VsZS50aWYiLCBvdmVyd3JpdGU9VFJVRSkNCngNCmBgYA0KDQojIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbXMNCg0KQSB2ZXJ5IGltcG9ydGFudCBhc3BlY3Qgb2Ygc3BhdGlhbCBkYXRhIGlzIHRoZSBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW0gKENSUykgdGhhdCBpcyB1c2VkLiBGb3IgZXhhbXBsZSwgYSBsb2NhdGlvbiBvZiAoMTQwLCAxMikgaXMgbm90IG1lYW5pbmdmdWwgaWYgeW91IGRvIGtub3cgd2hlcmUgdGhlIG9yaWdpbiAoMCwwKSBpcyBhbmQgaWYgdGhlIHgtY29vcmRpbmF0ZSBpcyAxNDAgbWV0ZXJzLCBmZWV0LCBuYXV0aWNhbCBtaWxlcywga2lsb21ldGVycywgb3IgcGVyaGFwcyBkZWdyZWVzIGF3YXkgZnJvbSB0aGUgeC1vcmlnaW4uDQoNCg0KIyMgQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtcyAoQ1JTKQ0KDQojIyMgQW5ndWxhciBjb29yZGluYXRlcw0KDQpUaGUgZWFydGggaGFzIGFuIGlycmVndWxhciBzcGhlcm9pZC1saWtlIHNoYXBlLiBUaGUgbmF0dXJhbCBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW0gZm9yIGdlb2dyYXBoaWMgZGF0YSBpcyBsb25naXR1ZGUvbGF0aXR1ZGUuIFRoaXMgaXMgYW4gYW5ndWxhciBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW0uIFRoZSBsYXRpdHVkZSANCiAocGhpKSBvZiBhIHBvaW50IGlzIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSBlcXVhdG9yaWFsIHBsYW5lIGFuZCB0aGUgbGluZSB0aGF0IHBhc3NlcyB0aHJvdWdoIGEgcG9pbnQgYW5kIHRoZSBjZW50ZXIgb2YgdGhlIEVhcnRoLiBMb25naXR1ZGUgDQogKGxhbWJkYSkgaXMgdGhlIGFuZ2xlIGZyb20gYSByZWZlcmVuY2UgbWVyaWRpYW4gKGxpbmVzIG9mIGNvbnN0YW50IGxvbmdpdHVkZSkgdG8gYSBtZXJpZGlhbiB0aGF0IHBhc3NlcyB0aHJvdWdoIHRoZSBwb2ludC4NCg0KT2J2aW91c2x5IHdlIGNhbm5vdCBhY3R1YWxseSBtZWFzdXJlIHRoZXNlIGFuZ2xlcy4gQnV0IHdlIGNhbiBlc3RpbWF0ZSB0aGVtLiBUbyBkbyBzbywgeW91IG5lZWQgYSBtb2RlbCBvZiB0aGUgc2hhcGUgb2YgdGhlIGVhcnRoLiBTdWNoIGEgbW9kZWwgaXMgY2FsbGVkIGEg4oCcZGF0dW3igJ0uIFRoZSBzaW1wbGVzdCBkYXR1bXMgYXJlIGEgc3BoZXJvaWQgKGEgc3BoZXJlIHRoYXQgaXMg4oCcZmxhdHRlbmVk4oCdIGF0IHRoZSBwb2xlcyBhbmQgYnVsZ2VzIGF0IHRoZSBlcXVhdG9yKS4gTW9yZSBjb21wbGV4IGRhdHVtcyBhbGxvdyBmb3IgbW9yZSB2YXJpYXRpb24gaW4gdGhlIGVhcnRo4oCZcyBzaGFwZS4gVGhlIG1vc3QgY29tbW9ubHkgdXNlZCBkYXR1bSBpcyBjYWxsZWQgV0dTODQgKFdvcmxkIEdlb2Rlc2ljIFN5c3RlbSAxOTg0KS4gVGhpcyBpcyB2ZXJ5IHNpbWlsYXIgdG8gTkFEODMgKFRoZSBOb3J0aCBBbWVyaWNhbiBEYXR1bSBvZiAxOTgzKS4gT3RoZXIsIGxvY2FsIGRhdHVtcyBleGlzdCB0byBtb3JlIHByZWNpc2VseSByZWNvcmQgbG9jYXRpb25zIGZvciBhIHNpbmdsZSBjb3VudHJ5IG9yIHJlZ2lvbi4NCg0KU28gdGhlIGJhc2ljIHdheSB0byByZWNvcmQgYSBsb2NhdGlvbiBpcyBhIGNvb3JkaW5hdGUgcGFpciBpbiBkZWdyZWVzIGFuZCBhIHJlZmVyZW5jZSBkYXR1bS4gU29tZXRpbWVzIHBlb3BsZSBzYXkgdGhhdCB0aGVpciBjb29yZGluYXRlcyBhcmUg4oCcaW4gV0dTODTigJ0uIFRoYXQgZG9lcyBub3QgdGVsbCB1cyBtdWNoOyB0aGV5IHR5cGljYWxseSBtZWFuIHRvIHNheSB0aGF0IHRoZXkgYXJlIGxvbmdpdHVkZS9sYXRpdHVkZSByZWxhdGl2ZSB0byB0aGUgV0dTODQgZGF0dW0uIExpa2V3aXNlIGxvbmdpdHVkZS9sYXRpdHVkZSBjb29yZGluYXRlcyBhcmUgc29tZXRpbWVzIHJlZmVycmVkIHRvIGFzIOKAnGdlb2dyYXBoaWPigJ0gY29vcmRpbmF0ZXMuIFRoYXQgaXMgcmF0aGVyIG9kZCwgaWYgcGxhbmFyIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgKHNlZSBiZWxvdykgYXJlIG5vdCBnZW9ncmFwaGljLCB3aGF0IGFyZSB0aGV5Pw0KDQojIyMgUHJvamVjdGlvbnMNCg0KQSBtYWpvciBxdWVzdGlvbiBpbiBzcGF0aWFsIGFuYWx5c2lzIGFuZCBjYXJ0b2dyYXBoeSBpcyBob3cgdG8gdHJhbnNmb3JtIHRoaXMgdGhyZWUgZGltZW5zaW9uYWwgYW5ndWxhciBzeXN0ZW0gdG8gYSB0d28gZGltZW5zaW9uYWwgcGxhbmFyIChzb21ldGltZXMgY2FsbGVkIOKAnENhcnRlc2lhbuKAnSkgc3lzdGVtLiBBIHBsYW5hciBzeXN0ZW0gaXMgZWFzaWVyIHRvIHVzZSBmb3IgY2VydGFpbiBjYWxjdWxhdGlvbnMgYW5kIHJlcXVpcmVkIHRvIG1ha2UgbWFwcyAodW5sZXNzIHlvdSBoYXZlIGEgMy1kIHByaW50ZXIpLiBUaGUgZGlmZmVyZW50IHR5cGVzIG9mIHBsYW5hciBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGFyZSByZWZlcnJlZCB0byBhcyDigJxwcm9qZWN0aW9uc+KAnS4gRXhhbXBsZXMgYXJlIOKAnE1lcmNhdG9y4oCdLCDigJxVVE3igJ0sIOKAnFJvYmluc29u4oCdLCDigJxMYW1iZXJ04oCdLCDigJxTaW51c29pZGFs4oCdIGFuZCDigJxBbGJlcnPigJ0uDQoNClRoZXJlIGlzIG5vdCBvbmUgYmVzdCBwcm9qZWN0aW9uLiBTb21lIHByb2plY3Rpb25zIGNhbiBiZSB1c2VkIGZvciBhIG1hcCBvZiB0aGUgd2hvbGUgd29ybGQ7IG90aGVyIHByb2plY3Rpb25zIGFyZSBhcHByb3ByaWF0ZSBmb3Igc21hbGwgYXJlYXMgb25seS4gT25lIG9mIHRoZSBtb3N0IGltcG9ydGFudCBjaGFyYWN0ZXJpc3RpY3Mgb2YgYSBtYXAgcHJvamVjdGlvbiBpcyB3aGV0aGVyIGl0IGlzIOKAnGVxdWFsIGFyZWHigJ0gKHRoZSBzY2FsZSBvZiB0aGUgbWFwIGlzIGNvbnN0YW50KSBvciDigJxjb25mb3JtYWzigJ0gKHRoZSBzaGFwZXMgb2YgdGhlIGdlb2dyYXBoaWMgZmVhdHVyZXMgYXJlIGFzIHRoZXkgYXJlIHNlZW4gb24gYSBnbG9iZSkuIE5vIHR3byBkaW1lbnNpb25hbCBtYXAgcHJvamVjdGlvbiBjYW4gYmUgYm90aCBjb25mb3JtYWwgYW5kIGVxdWFsLWFyZWEgKGJ1dCB0aGV5IGNhbiBiZSBhcHByb3hpbWF0ZWx5IGJvdGggZm9yIHNtYWxsZXIgYXJlYXMsIGUuZy4gVVRNLCBvciBMYW1iZXJ0IEVxdWFsIEFyZWEgZm9yIGEgbGFyZ2VyIGFyZWEpLCBhbmQgc29tZSBhcmUgbmVpdGhlci4NCg0KIyMjIE5vdGF0aW9uDQoNCkEgcGxhbmFyIENSUyBpcyBkZWZpbmVkIGJ5IGEgcHJvamVjdGlvbiwgZGF0dW0sIGFuZCBhIHNldCBvZiBwYXJhbWV0ZXJzLiBUaGUgcGFyYW1ldGVycyBkZXRlcm1pbmUgdGhpbmdzIGxpa2Ugd2hlcmUgdGhlIGNlbnRlciBvZiB0aGUgbWFwIGlzLiBUaGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgZGVwZW5kcyBvbiB0aGUgcHJvamVjdGlvbi4gSXQgaXMgdGhlcmVmb3JlIG5vdCB0cml2aWFsIHRvIGRvY3VtZW50IGEgcHJvamVjdGlvbiB1c2VkLCBhbmQgc2V2ZXJhbCBzeXN0ZW1zIGV4aXN0LiBJbiBSIHdlIHVzZWQgdG8gZGVwZW5kIG9uIHRoZSBQUk9KLjQgbm90YXRpb24uIFBST0ouNCBpcyB0aGUgbmFtZSBvZiBhIHNvZnR3YXJlIGxpYnJhcnkgdGhhdCBpcyBjb21tb25seSB1c2VkIGZvciBDUlMgdHJhbnNmb3JtYXRpb24uIFlvdSBjYW4gZmluZCBtYW55IG1vcmUgb2YgdGhlc2Ugb24gW3NwYXRpYWxyZWZlcmVuY2Uub3JnXShodHRwczovL3NwYXRpYWxyZWZlcmVuY2Uub3JnL3JlZi9lcHNnLzQzMjYvKQ0KDQpUaGUgUFJPSi40IG5vdGF0aW9uIGlzIG5vIGxvbmdlciBmdWxseSBzdXBwb3J0ZWQgaW4gdGhlIG5ld2VyIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5ICh0aGF0IHdhcyByZW5hbWVkIHRvIFBSJFxwaGkkSikuIEl0IHN0aWxsIHdvcmtzIGZvciBDUlNzIHdpdGggdGhlIFdHUzg0IGRhdHVtLiBGb3Igb3RoZXIgY2FzZXMgeW91IGhhdmUgdG8gdXNlIGEgRVBTRyBjb2RlIChpZiBhdmFpbGFibGUpIG9yIGEgV2VsbC1Lbm93bi1UZXh0IG5vdGF0aW9uLg0KDQpNb3N0IGNvbW1vbmx5IHVzZWQgQ1JTcyBoYXZlIGJlZW4gYXNzaWduZWQgYSDigJxFUFNHIGNvZGXigJ0gKEVQU0cgc3RhbmRzIGZvciBFdXJvcGVhbiBQZXRyb2xldW0gU3VydmV5IEdyb3VwKS4gVGhpcyBpcyBhIHVuaXF1ZSBJRCB0aGF0IGNhbiBiZSBhIHNpbXBsZSB3YXkgdG8gaWRlbnRpZnkgYSBDUlMuIEZvciBleGFtcGxlIGBFUFNHOjI3NTYxYCBpcyBlcXVpdmFsZW50IHRvIGArcHJvaj1sY2MgK2xhdF8xPTQ5LjUgK2xhdF8wPTQ5LjUgK2xvbl8wPTAgK2tfMD0wLjk5OTg3NzM0MSAreF8wPTYgK3lfMD0yICthPTYzNzgyNDkuMiArYj02MzU2NTE1ICt0b3dnczg0PS0xNjgsLTYwLDMyMCwwLDAsMCwwICtwbT1wYXJpcyArdW5pdHM9bSArbm9fZGVmc2AuDQoNCk5vdyBsZXTigJlzIGxvb2sgYXQgYW4gZXhhbXBsZSB3aXRoIGEgc3BhdGlhbCBkYXRhIHNldCBpbiBSLg0KDQoNCg0KYGBge3IsICBldmFsPVR9DQpzMQ0KYGBgDQoNCldlIGNhbiBpbnNwZWN0IHRoZSBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW0gbGlrZSB0aGlzLg0KDQpgYGB7ciwgIGV2YWw9VH0NCmNycyhzMSkNCmBgYA0KDQojIyBBc3NpZ25pbmcgQ1JTDQoNClNvbWV0aW1lcyB3ZSBoYXZlIGRhdGEgd2l0aG91dCBhIENSUy4gVGhpcyBjYW4gYmUgYmVjYXVzZSB0aGUgZmlsZSB1c2VkIHdhcyBpbmNvbXBsZXRlLCBvciBwZXJoYXBzIGJlY2F1c2Ugd2UgY3JlYXRlZCB0aGUgZGF0YSBvdXJzZWx2ZXMgd2l0aCBSIGNvZGUuIEluIHRoYXQgY2FzZSB3ZSBjYW4gYXNzaWduIHRoZSBDUlMgaWYgd2Uga25vdyB3aGF0IGl0IHNob3VsZCBiZS4gSGVyZSBJIGZpcnN0IHJlbW92ZSB0aGUgQ1JTIG9mIGBwcGAgYW5kIHRoZW4gSSBzZXQgaXQgYWdhaW4uDQoNCmBgYHtyLCAgZXZhbD1UfQ0Kc3MgPC0gczENCmNycyhzcykgPC0gIiINCmNycyhzcykNCmNycyhzcykgPC0gIitwcm9qPWxvbmdsYXQgK2RhdHVtPVdHUzg0Ig0KY3JzKHNzKQ0KYGBgDQoNCk5vdGUgdGhhdCB5b3Ugc2hvdWxkIG5vdCB1c2UgdGhpcyBhcHByb2FjaCB0byBjaGFuZ2UgdGhlIENSUyBvZiBhIGRhdGEgc2V0IGZyb20gd2hhdCBpdCBpcyB0byB3aGF0IHlvdSB3YW50IGl0IHRvIGJlLiBBc3NpZ25pbmcgYSBDUlMgaXMgbGlrZSBsYWJlbGluZyBzb21ldGhpbmcuIFlvdSBuZWVkIHRvIHByb3ZpZGUgdGhlIGxhYmVsIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGl0ZW0uIE5vdCB0byB3aGF0IHlvdSB3b3VsZCBsaWtlIGl0IHRvIGJlLiBGb3IgZXhhbXBsZSBpZiB5b3UgbGFiZWwgYSBiaWN5Y2xlLCB5b3UgY2FuIHdyaXRlIOKAnGJpY3ljbGXigJ0uIFBlcmhhcHMgeW91IHdvdWxkIHByZWZlciBhIGNhciwgYW5kIHlvdSBjYW4gbGFiZWwgeW91ciBiaWN5Y2xlIGFzIOKAnGNhcuKAnSBidXQgdGhhdCB3b3VsZCBub3QgZG8geW91IGFueSBnb29kLiBJdCBpcyBzdGlsbCBhIGJpY3ljbGUuIFlvdSBjYW4gdHJ5IHRvIHRyYW5zZm9ybSB5b3VyIGJpY3ljbGUgaW50byBhIGNhci4gVGhhdCB3b3VsZCBub3QgYmUgZWFzeS4gVHJhbnNmb3JtaW5nIHNwYXRpYWwgZGF0YSBpcyBlYXNpZXIuDQoNCiMjIFRyYW5zZm9ybWluZyB2ZWN0b3IgZGF0YQ0KDQpXZSBjYW4gdHJhbnNmb3JtIHRoZXNlIGRhdGEgdG8gYSBuZXcgZGF0YSBzZXQgd2l0aCBhbm90aGVyIENSUyB1c2luZyB0aGUgYHByb2plY3RgIG1ldGhvZC4NCg0KSGVyZSB3ZSB1c2UgdGhlIFJvYmluc29uIHByb2plY3Rpb24uIEZpcnN0IHdlIG5lZWQgdG8gZmluZCB0aGUgY29ycmVjdCBub3RhdGlvbi4NCg0KYGBge3IsICBldmFsPVR9DQpuZXdjcnMgPC0gIitwcm9qPXJvYmluICtkYXR1bT1XR1M4NCINCmBgYA0KDQpOb3cgdXNlIGl0OiANCg0KYGBge3IsICBldmFsPVR9DQpyb2IgPC0gdGVycmE6OnByb2plY3QoczEsIG5ld2NycykNCnJvYg0KYGBgDQoNCkFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiwgdGhlIHVuaXRzIG9mIHRoZSBnZW9tZXRyeSBhcmUgbm8gbG9uZ2VyIGluIGRlZ3JlZXMsIGJ1dCBpbiBtZXRlcnMgYXdheSBmcm9tIChsb25naXR1ZGU9MCwgbGF0aXR1ZGU9MCkuIFRoZSBzcGF0aWFsIGV4dGVudCBvZiB0aGUgZGF0YSBpcyBhbHNvIGluIHRoZXNlIHVuaXRzLg0KDQpXZSBjYW4gYmFja3RyYW5zZm9ybSB0byBsb25naXR1ZGUvbGF0aXR1ZGU6DQoNCmBgYHtyLCAgZXZhbD1UfQ0KcDIgPC0gdGVycmE6OnByb2plY3Qocm9iLCAiK3Byb2o9bG9uZ2xhdCArZGF0dW09V0dTODQiKQ0KYGBgDQoNCiMjIFRyYW5zZm9ybWluZyByYXN0ZXIgZGF0YQ0KDQpWZWN0b3IgZGF0YSBjYW4gYmUgdHJhbnNmb3JtZWQgZnJvbSBsb24vbGF0IGNvb3JkaW5hdGVzIHRvIHBsYW5hciBhbmQgYmFjayB3aXRob3V0IGxvc3Mgb2YgcHJlY2lzaW9uLiBUaGlzIGlzIG5vdCB0aGUgY2FzZSB3aXRoIHJhc3RlciBkYXRhLiBBIHJhc3RlciBjb25zaXN0cyBvZiByZWN0YW5ndWxhciBjZWxscyBvZiB0aGUgc2FtZSBzaXplIChpbiB0ZXJtcyBvZiB0aGUgdW5pdHMgb2YgdGhlIENSUzsgdGhlaXIgYWN0dWFsIHNpemUgbWF5IHZhcnkpLiBJdCBpcyBub3QgcG9zc2libGUgdG8gdHJhbnNmb3JtIGNlbGwgYnkgY2VsbC4gRm9yIGVhY2ggbmV3IGNlbGwsIHZhbHVlcyBuZWVkIHRvIGJlIGVzdGltYXRlZCBiYXNlZCBvbiB0aGUgdmFsdWVzIGluIHRoZSBvdmVybGFwcGluZyBvbGQgY2VsbHMuIElmIHRoZSB2YWx1ZXMgYXJlIGNhdGVnb3JpY2FsIGRhdGEsIHRoZSDigJxuZWFyZXN0IG5laWdoYm9y4oCdIG1ldGhvZCBpcyBjb21tb25seSB1c2VkLiBPdGhlcndpc2Ugc29tZSBzb3J0IG9mIGludGVycG9sYXRpb24gaXMgZW1wbG95ZWQgKGUuZy4g4oCcYmlsaW5lYXLigJ0pLg0KDQpCZWNhdXNlIHByb2plY3Rpb24gb2YgcmFzdGVycyBhZmZlY3RzIHRoZSBjZWxsIHZhbHVlcywgaW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCB3YW50IHRvIGF2b2lkIHByb2plY3RpbmcgcmFzdGVyIGRhdGEgYW5kIHJhdGhlciBwcm9qZWN0IHZlY3RvciBkYXRhLiBCdXQgaGVyZSBpcyBob3cgeW91IGNhbiBwcm9qZWN0IHJhc3RlciBkYXRhLg0KDQpgYGB7ciwgIGV2YWw9VH0NCnIgPC0gcmFzdCh4bWluPS0xMTAsIHhtYXg9LTkwLCB5bWluPTQwLCB5bWF4PTYwLCBuY29scz00MCwgbnJvd3M9NDApDQp2YWx1ZXMocikgPC0gMTpuY2VsbChyKQ0Kcg0KcGxvdCAocikNCmBgYA0KDQpUaGUgc2ltcGxlc3QgYXBwcm9hY2ggaXMgdG8gcHJvdmlkZSBhIG5ldyBjcnMgKHRoZSBSb2JpbnNvbiBjcnMgaW4gdGhpcyBjYXNlKToNCg0KYGBge3IsICBldmFsPVR9DQpuZXdjcnMNCnByMSA8LSB0ZXJyYTo6cHJvamVjdChyLCBuZXdjcnMpDQpjcnMocHIxKQ0KcGxvdChwcjEpDQpgYGANCg0KQnV0IHRoYXQgaXMgbm90IGEgZ29vZCBtZXRob2QuIEFzIHlvdSBzaG91bGQgd2FudCB0byBhc3N1cmUgdGhhdCB5b3UgcHJvamVjdCBmaXRzIHRvIGV4YWN0bHkgdGhlIHJhc3RlciBwYXJhbWV0ZXJzIHlvdSBuZWVkIChzbyB0aGF0IGl0IGxpbmVzIHVwIHdpdGggb3RoZXIgcmFzdGVyIGRhdGEgeW91IGFyZSB1c2luZykuDQoNClRvIGhhdmUgdGhpcyBraW5kIG9mIGNvbnRyb2wsIHByb3ZpZGUgYW4gZXhpc3RpbmcgU3BhdFJhc3RlciB3aXRoIHRoZSBnZW9tZXRyeSB5b3UgZGVzaXJlLiBUaGF0IGlzIGdlbmVyYWxseSB0aGUgYmVzdCB3YXkgdG8gcHJvamVjdCByYXN0ZXIuIEJ5IHByb3ZpZGluZyBhbiBleGlzdGluZyBTcGF0UmFzdGVyLCBzdWNoIHRoYXQgeW91ciBuZXdseSBwcm9qZWN0ZWQgZGF0YSBwZXJmZWN0bHkgYWxpZ25zIHdpdGggaXQuIEluIHRoaXMgZXhhbXBsZSB3ZSBkbyBub3QgaGF2ZSBhbiBleGlzdGluZyBTcGF0UmFzdGVyIG9iamVjdCwgc28gd2UgY3JlYXRlIGZyb20gdGhlIHJlc3VsdCBvYnRhaW5lZCBhYm92ZS4NCg0KYGBge3IsICBldmFsPVR9DQp4IDwtIHJhc3QocHIxKQ0KIyBTZXQgdGhlIGNlbGwgc2l6ZQ0KcmVzKHgpIDwtIDIwMDAwMA0KYGBgDQoNCk5vdyBwcm9qZWN0LCBhbmQgbm90ZSB0aGUgY2hhbmdlIGluIHRoZSBjb29yZGluYXRlcy4NCg0KYGBge3IsICBldmFsPVR9DQpwcjMgPC0gdGVycmE6OnByb2plY3QociwgeCkNCnByMw0KcGxvdChwcjMpDQpgYGANCg0KRm9yIHJhc3RlciBiYXNlZCBhbmFseXNpcyBpdCBpcyBvZnRlbiBpbXBvcnRhbnQgdG8gdXNlIGVxdWFsIGFyZWEgcHJvamVjdGlvbnMsIHBhcnRpY3VsYXJseSB3aGVuIGxhcmdlIGFyZWFzIGFyZSBhbmFseXplZC4gVGhpcyB3aWxsIGFzc3VyZSB0aGF0IHRoZSBncmlkIGNlbGxzIGFyZSBhbGwgb2Ygc2FtZSBzaXplLCBhbmQgdGhlcmVmb3JlIGNvbXBhcmFibGUgdG8gZWFjaCBvdGhlciwgZXNwZWNpYWxseSB3aGVuIGNvdW50IGRhdGEgYXJlIHVzZWQuDQoNCiMgVmVjdG9yIGRhdGEgbWFuaXB1bGF0aW9uDQoNClRoaXMgY2hhcHRlciBpbGx1c3RyYXRlcyBzb21lIHdheXMgaW4gd2hpY2ggd2UgY2FuIG1hbmlwdWxhdGUgdmVjdG9yIGRhdGEuIFdlIHN0YXJ0IHdpdGggYW4gZXhhbXBsZSBTcGF0VmVjdG9yIHRoYXQgd2UgcmVhZCBmcm9tIGEgc2hhcGVmaWxlLg0KDQpgYGB7ciwgIGV2YWw9VH0NClRXTiA8LSB2ZWN0KCdkYXRhL2dhZG0vZ2FkbTQxX1RXTl8xX3BrLnJkcycpDQpwbG90KFRXTiwgIk5BTUVfMSIpDQpgYGANCg0KV2UgY2FuIHBsb3QgdGhlc2UgZGF0YSBpbiBtYW55IHdheXMuIEZvciBleGFtcGxlOg0KDQpXZSBjYW4gc2VlIHRoaXMgZGF0YSBzZXQgaXMgaW5jb21wbGV0ZSBmb3IgVGFpd2FuLiBMZXQncyBnZXQgc29tZSBkYXRhIGRpcmVjdGx5IGZyb20gVGFpd2FuDQoNCmBgYHtyLCAgZXZhbD1GfQ0KdXJsIDwtICdodHRwczovL2RhdGEubW9pLmdvdi50dy9Nb2lPRC9TeXN0ZW0vRG93bmxvYWRGaWxlLmFzcHg/REFUQT03Mjg3NEM1NS04ODRELTRDRUEtQjdENi1GNjBCMEJFODVBQjAnDQpwYXRoMSA8LSB0ZW1wZmlsZShmaWxlZXh0ID0gIi56aXAiKQ0KaWYgKGZpbGUuZXhpc3RzKHBhdGgxKSkgICdmaWxlIGFscmVkeSBleGlzdHMnIGVsc2UgZG93bmxvYWQuZmlsZSh1cmwsIHBhdGgxLCBtb2RlPSJ3YiIpDQp6aXA6OnVuemlwKHppcGZpbGUgPSBwYXRoMSxleGRpciA9ICdkYXRhJykNCmBgYA0KDQpNYWtlIGBTcGF0aWFsVmVjdG9yYDoNCg0KYGBge3IsICBldmFsPVR9DQpUYWl3YW4gPC0gImRhdGEvQ09VTlRZX01PSV8xMTMwNzE4LnNocCINClRhaXdhbiA8LXZlY3QoVGFpd2FuKQ0KYGBgDQoNCk1ha2UgdGhlIG5ldyBwbG90OiANCg0KYGBge3IsICBldmFsPVR9DQpwbG90KFRhaXdhbiwgIkNPVU5UWUVORyIpDQpgYGANCg0KDQojIyBCYXNpY3MNCg0KIyMjIEdlb21ldHJ5IGFuZCBhdHRyaWJ1dGVzDQoNClRvIGV4dHJhY3QgdGhlIGF0dHJpYnV0ZXMgKGRhdGEuZnJhbWUpIGZyb20gYSBTcGF0VmVjdG9yLCB1c2U6DQoNCg0KYGBge3IsICBldmFsPVR9DQpkIDwtIGFzLmRhdGEuZnJhbWUoVGFpd2FuKQ0KIyBoZWFkKGQpICMgbm90IHJ1biBmb3IgQ2hpbmVzZSBjaGFyYWN0ZXINCmBgYA0KWW91IGNhbiBhbHNvIGV4dHJhY3QgdGhlIGdlb21ldHJ5IGFzIGEgYSBtYXRyaXggKHRoaXMgaXMgcmFyZWx5IG5lZWRlZCkuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KZyA8LSBnZW9tKFRhaXdhbikgDQpoZWFkKGcpDQpgYGANCg0KT3IgYXMg4oCcd2VsbC1rbm93bi10ZXh04oCdLg0KDQpgYGB7ciwgIGV2YWw9VH0NCmcgPC0gZ2VvbShUYWl3YW4sIHdrdD1UUlVFKQ0Kc3Vic3RyKGcsIDEsIDUwKQ0KYGBgDQoNCiMjIyBWYXJpYWJsZXMNCg0KWW91IGNhbiBleHRyYWN0IGEgdmFyaWFibGUgYXMgeW91IHdvdWxkIGRvIHdpdGggYSBgZGF0YS5mcmFtZWAuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KVGFpd2FuJENPVU5UWUVORw0KYGBgDQpUbyBzdWItc2V0IGEgU3BhdFZlY3RvciB0byBvbmUgb3IgbW9yZSB2YXJpYWJsZXMgeW91IGNhbiB1c2UgdGhlIG5vdGF0aW9uIGJlbG93LiBOb3RlIGhvdyB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhYm92ZSBleGFtcGxlLiBBYm92ZSBhIHZlY3RvciBvZiB2YWx1ZXMgaXMgcmV0dXJuZWQuIFdpdGggdGhlIGFwcHJvYWNoIGJlbG93IHlvdSBnZXQgYSBuZXcgU3BhdFZlY3RvciB3aXRoIG9ubHkgb25lIHZhcmlhYmxlLg0KDQpgYGB7ciwgIGV2YWw9VH0NClRhaXdhblssIkNPVU5UWUVORyJdDQpgYGANCg0KWW91IGNhbiBhZGQgYSBuZXcgdmFyaWFibGUgdG8gYSBTcGF0VmVjdG9yIGp1c3QgYXMgaWYgaXQgd2VyZSBhIGRhdGEuZnJhbWUuDQoNCmBgYHtyLCAgZXZhbD1UfQ0Kc2V0LnNlZWQoMCkNClRhaXdhbiRsZXRzIDwtIHNhbXBsZShsZXR0ZXJzLCBucm93KFRhaXdhbikpDQojIFRhaXdhbg0KYGBgDQoNCk5vdGUgdGhhdCB0byBnZXQgdGhlIG51bWJlciBvZiBnZW9tZXRyaWVzIG9mIFNwYXRWZWN0b3IgYFRhaXdhbmAsIHlvdSBjYW4gdXNlIGBucm93KFRhaXdhbilgLCBvciBgc2l6ZShUYWl3YW4pYC4gWW91IGNhbiBhbHNvIGRvIGBwZXJpbShUYWl3YW4pYCB0byBnZXQgdGhlIOKAnGxlbmd0aOKAnSBvZiB0aGUgc3BhdGlhbCBvYmplY3RzICh6ZXJvIGZvciBwb2ludHMsIHRoZSBsZW5ndGggb2YgdGhlIGxpbmVzLCBvciB0aGUgcGVyaW1ldGVyIG9mIHRoZSBwb2x5Z29ucykuDQoNCkFzc2lnbmluZyBhIG5ldyB2YWx1ZSB0byBhbiBleGlzdGluZyB2YXJpYWJsZS4NCg0KYGBge3IsICBldmFsPVR9DQpUYWl3YW4kbGV0cyA8LSBzYW1wbGUoTEVUVEVSUywgbnJvdyhUYWl3YW4pKQ0KIyBoZWFkKFRhaXdhbikNCmBgYA0KDQpUbyBnZXQgcmlkIG9mIGEgdmFyaWFibGUsIHNldCBpdCB0byBgTlVMTGAuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KVGFpd2FuJGxldHMgPC0gTlVMTA0KYGBgDQoNCiMjIyBNZXJnZQ0KDQpZb3UgY2FuIGFzc2lnbiBhbiBhdHRyaWJ1dGVzIHRhYmxlIChkYXRhLmZyYW1lKSB0byBhIFNwYXRWZWN0b3Igd2l0aCBgdmFsdWVzPC1gLiBUbyBhZGQgYXR0cmlidXRlcyB0byBhIFNwYXRWZWN0b3IgdGhhdCBhbHJlYWR5IGhhcyBhdHRyaWJ1dGVzIHVzZSBgbWVyZ2VgIChvciBgY2JpbmRgIGlmIHlvdSBrbm93IHRoZSBvcmRlciBvZiB0aGUgcmVjb3JkcyBpcyB0aGUgc2FtZSkuDQoNCg0KYGBge3IsICBldmFsPVR9DQpkZnIgPC0gZGF0YS5mcmFtZShDb3VudHk9VGFpd2FuJENPVU5UWUVORywgVmFsdWU9cm91bmQocnVuaWYobGVuZ3RoKFRhaXdhbiksIDEwMCwgMTAwMCkpKQ0KZGZyIDwtIGRmcltvcmRlcihkZnIkQ291bnR5KSwgXQ0KcG0gPC0gbWVyZ2UoVGFpd2FuLCBkZnIsIGJ5Lng9IkNPVU5UWUVORyIsYnkueT0iQ291bnR5IikNCiMgcG0gDQojIGhlYWQocG0pDQpgYGANCg0KTm90ZSB0aGUgbmV3IHZhcmlhYmxlIGBWYWx1ZWAgYWRkZWQgdG8gYHBtYA0KDQojIyMgUmVjb3Jkcw0KDQpTZWxlY3Rpbmcgcm93cyAocmVjb3JkcykuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KaSA8LSB3aGljaChUYWl3YW4kQ09VTlRZRU5HID09ICdUYWlwZWkgQ2l0eScpDQpnIDwtIFRhaXdhbltpLF0NCiMgZw0KYGBgDQoNCkl0IGlzIGFsc28gcG9zc2libGUgdG8gaW50ZXJhY3RpdmVseSBzZWxlY3QgYW5kIHF1ZXJ5IHJlY29yZHMgYnkgY2xpY2tpbmcgb24gYSBwbG90dGVkIGRhdGFzZXQuIFRoYXQgaXMgZGlmZmljdWx0IHRvIHNob3cgaGVyZS4gU2VlIGA/c2VsYCBmb3IgaW50ZXJhY3RpdmVseSBzZWxlY3RpbmcgZ2VvbWV0cmllcyBhbmQgYD9jbGlja2AgdG8gaWRlbnRpZnkgYXR0cmlidXRlcyBieSBjbGlja2luZyBvbiBhIHBsb3QgKG1hcCkuDQoNCiMjIEFwcGVuZCBhbmQgYWdncmVnYXRlDQoNCiMjIyBBcHBlbmQNCg0KTW9yZSBleGFtcGxlIGRhdGEuIE9iamVjdCB6IGNvbnNpc3RzIG9mIGZvdXIgcG9seWdvbnM7IHoyIGlzIG9uZSBvZiB0aGVzZSBmb3VyIHBvbHlnb25zLg0KDQpgYGB7ciwgIGV2YWw9VH0NCnogPC0gcmFzdChUYWl3YW4pDQpkaW0oeikgPC0gYygyLDIpDQp2YWx1ZXMoeikgPC0gMTo0DQpuYW1lcyh6KSA8LSAnWm9uZScNCnogPC0gYXMucG9seWdvbnMoeikNCnoNCnoxIDwtIHpbMSxdDQp6MiA8LSB6WzIsXQ0KejMgPC0gelszLF0NCno0IDwtIHpbNCxdDQpwbG90KFRhaXdhbikNCnBsb3QoeiwgYWRkPVRSVUUsIGJvcmRlcj0nYmx1ZScsIGx3ZD01KQ0KcGxvdCh6MiwgYWRkPVRSVUUsIGJvcmRlcj0ncmVkJywgbHdkPTIsIGNvbD0ncmVkJykNCmBgYA0KDQpUbyBhcHBlbmQgU3BhdFZlY3RvciBvYmplY3RzIG9mIHRoZSBzYW1lICh2ZWN0b3IpIHR5cGUgeW91IGNhbiB1c2UgYHJiaW5kYDoNCg0KYGBge3IsICBldmFsPVR9DQpiIDwtIHJiaW5kKFRhaXdhbiwgeikNCiMgaGVhZChiKQ0KIyB0YWlsKGIpDQpgYGANCk5vdGUgaG93IGByYmluZGAgYWxsb3dzIHlvdSB0byBhcHBlbmQgU3BhdFZlY3Qgb2JqZWN0cyB3aXRoIGRpZmZlcmVudCBhdHRyaWJ1dGUgbmFtZXMsIHVubGlrZSB0aGUgc3RhbmRhcmQgYHJiaW5kYCBmb3IgYGRhdGEuZnJhbWVgLg0KDQoNCiMjIyBBZ2dyZWdhdGUNCg0KSXQgaXMgY29tbW9uIHRvIGFnZ3JlZ2F0ZSAo4oCcZGlzc29sdmXigJ0pIHBvbHlnb25zIHRoYXQgaGF2ZSB0aGUgc2FtZSB2YWx1ZSBmb3IgYW4gYXR0cmlidXRlIG9mIGludGVyZXN0LiBJbiB0aGlzIGNhc2UsIHdlIHdhbnQgdG8gaGlnaGxpZ2h0IHRoZSBOb3J0aCBvZiBUYWl3YW4uDQoNCg0KYGBge3IsICBldmFsPVR9DQpUYWl3YW4kcmVnaW9uPC1jKHJlcCgiT3RoZXJzIiw2KSwgcmVwKCJOb3J0aCIsMyksIHJlcCgiT3RoZXJzIiwyKSwgIk5vcnRoIiwgcmVwKCJPdGhlcnMiLDEwKSkNCnBhIDwtIGFnZ3JlZ2F0ZShUYWl3YW4sIGJ5PSdyZWdpb24nKQ0KemEgPC0gYWdncmVnYXRlKHopDQpwbG90KHphLCBjb2w9J2xpZ2h0IGdyYXknLCBib3JkZXI9J2xpZ2h0IGdyYXknLCBsd2Q9NSkNCnBsb3QocGEsIGFkZD1UUlVFLCBjb2w9cmFpbmJvdygzKSwgbHdkPTMsIGJvcmRlcj0nd2hpdGUnKQ0KYGBgDQoNCkl0IGlzIGFsc28gcG9zc2libGUgdG8gYWdncmVnYXRlIHBvbHlnb25zIHdpdGhvdXQgZGlzc29sdmluZyB0aGUgYm9yZGVycy4NCg0KYGBge3IsICBldmFsPVR9DQpUYWl3YW4kcmVnaW9uPC1jKHJlcCgiT3RoZXJzIiw2KSwgcmVwKCJOb3J0aCIsMyksIHJlcCgiT3RoZXJzIiwyKSwgIk5vcnRoIiwgcmVwKCJPdGhlcnMiLDEwKSkNCnBhIDwtIGFnZ3JlZ2F0ZShUYWl3YW4sIGJ5PSdyZWdpb24nLGRpc3NvbHZlPUZBTFNFKQ0KemEgPC0gYWdncmVnYXRlKHosIGRpc3NvbHZlID0gRkFMU0UpDQpwbG90KHphLCBjb2w9J2xpZ2h0IGdyYXknLCBib3JkZXI9J2RhcmsgZ3JheScsIGx3ZD0zKQ0KcGxvdChwYSwgYWRkPVRSVUUsIGNvbD1yYWluYm93KDMpLCBsd2Q9MiwgYm9yZGVyPSd3aGl0ZScpDQpgYGANCg0KVGhpcyBpcyBhIHN0cnVjdHVyZSB0aGF0IGlzIHNpbWlsYXIgdG8gd2hhdCB5b3UgbWF5IGdldCBmb3IgYW4gYXJjaGlwZWxhZ286IG11bHRpcGxlIHBvbHlnb25zIHJlcHJlc2VudGVkIGFzIG9uZSBlbnRpdHkgKG9uZSByb3cpLiBVc2UgYGRpc2FnZ2AgdG8gc3BsaXQgdGhlc2UgdXAgaW50byB0aGVpciBwYXJ0cy4NCg0KYGBge3IsICBldmFsPVR9DQp6ZCA8LSBkaXNhZ2cocGEpDQp6ZA0KYGBgDQoNCiMjIyBPdmVybGF5DQoNClRoZXJlIGFyZSBtYW55IGRpZmZlcmVudCB3YXlzIHRvIOKAnG92ZXJsYXnigJ0gdmVjdG9yIGRhdGEuIEhlcmUgYXJlIHNvbWUgZXhhbXBsZXM6DQoNCi0gRXJhc2UNCg0KRXJhc2UgYSBwYXJ0IG9mIGEgU3BhdFZlY3Rvcg0KDQpgYGB7ciwgIGV2YWw9VH0NCmUxIDwtIGVyYXNlKFRhaXdhbix6MSApDQplMiA8LSBlcmFzZShlMSx6MyApDQplMyA8LSBlcmFzZShlMix6NCApDQpwbG90KGUzKQ0KYGBgDQoNCi0gSW50ZXJzZWN0DQoNCkVhc2llciB0byBjb21wbGV0ZSB3aXRoIGBpbnRlcnNlY3RgIFNwYXRWZWN0b3JzDQoNCmBgYHtyLCAgZXZhbD1UfQ0KaSA8LSB0ZXJyYTo6aW50ZXJzZWN0KFRhaXdhbiwgejMpDQpwbG90KGkpDQpgYGANCg0KWW91IGdvdCBUYWlwaW5nIElzbGFuZC4gDQoNCllvdSBjYW4gYWxzbyBgaW50ZXJzZWN0YCBvciBgY3JvcGAgd2l0aCBhIFNwYXRFeHRlbnQgKHJlY3RhbmdsZSkuIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYGludGVyc2VjdGAgYW5kIGBjcm9wYCBpcyB0aGF0IHdpdGggY3JvcCB0aGUgZ2VvbWV0cnkgb2YgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBub3QgYWRkZWQgdG8gdGhlIG91dHB1dC4NCg0KDQpgYGB7ciwgIGV2YWw9VH0NCmUgPC0gZXh0KDExOSwgMTIzLCAyMSwgMjYpDQp0ZSA8LSBjcm9wKFRhaXdhbiwgZSkNCnBsb3QoVGFpd2FuKQ0KcGxvdChlLCBhZGQ9VFJVRSwgbHdkPTMsIGNvbD0icmVkIikNCnBsb3QodGUsIGNvbD0nbGlnaHQgYmx1ZScsIGFkZD1UUlVFKQ0KcGxvdChlLCBhZGQ9VFJVRSwgbHdkPTMsIGJvcmRlcj0iYmx1ZSIpDQpgYGANCg0KLSBVbmlvbg0KDQpHZXQgdGhlIHVuaW9uIG9mIHR3byBTcGF0VmVjdG9ycy4NCg0KYGBge3IsICBldmFsPVR9DQp1IDwtIHRlcnJhOjp1bmlvbihUYWl3YW4sIHopDQp1DQpgYGANCg0KTm90ZSB0aGF0IHRoZXJlIGFyZSBtYW55IG1vcmUgcG9seWdvbnMgbm93LiBPbmUgZm9yIGVhY2ggdW5pcXVlIGNvbWJpbmF0aW9uIG9mIHBvbHlnb25zIChhbmQgYXR0cmlidXRlcyBpbiB0aGlzIGNhc2UpLg0KDQpgYGB7ciwgIGV2YWw9VH0NCnNldC5zZWVkKDUpDQpwbG90KHUsIGNvbD1zYW1wbGUocmFpbmJvdyhsZW5ndGgodSkpKSkNCmBgYA0KDQotIENvdmVyDQoNCmBjb3ZlcmAgaXMgYSBjb21iaW5hdGlvbiBvZiBgaW50ZXJzZWN0YCBhbmQgYHVuaW9uYC4gYGludGVyc2VjdGAgcmV0dXJucyBuZXcgKGludGVyc2VjdGVkKSBnZW9tZXRyaWVzIHdpdGggdGhlIGF0dHJpYnV0ZXMgb2YgYm90aCBpbnB1dCBkYXRhc2V0cy4gYHVuaW9uYCBhcHBlbmRzIHRoZSBnZW9tZXRyaWVzIGFuZCBhdHRyaWJ1dGVzIG9mIHRoZSBpbnB1dC4gYGNvdmVyYCByZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gYW5kIGFwcGVuZHMgdGhlIG90aGVyIGdlb21ldHJpZXMgYW5kIGF0dHJpYnV0ZXMgb2YgYm90aCBkYXRhc2V0cy4NCg0KYGBge3IsICBldmFsPVR9DQpjb3YgPC0gY292ZXIoVGFpd2FuLCB6W2MoMSwzKSxdKQ0KcGxvdChjb3YpDQpgYGANCg0KLSBEaWZmZXJlbmNlDQoNClRoZSBzeW1tZXRyaWNhbCBkaWZmZXJlbmNlIG9mIHR3byBTcGF0VmVjdG9ycw0KDQpgYGB7ciwgIGV2YWw9VH0NCmRpZiA8LSBzeW1kaWYoeixUYWl3YW4pDQpwbG90KGRpZiwgY29sPXJhaW5ib3cobGVuZ3RoKGRpZikpKQ0KYGBgDQoNCiMjIyBTcGF0aWFsIHF1ZXJpZXMNCg0KV2UgY2FuIHF1ZXJ5IHBvbHlnb25zIHdpdGggcG9pbnRzICjigJxwb2ludC1pbi1wb2x5Z29uIHF1ZXJ54oCdKS4NCg0KYGBge3IsICBldmFsPVR9DQpwdHMgPC0gbWF0cml4KGMoMTE3LCAxMjIsIDExNywgMTIyLCAxNSwgMTUsIDIzLCAyMyksIG5jb2w9MikNCnNwdHMgPC0gdmVjdChwdHMsIGNycz1jcnMoVGFpd2FuKSkNCnBsb3QoeiwgY29sPSdsaWdodCBibHVlJywgbHdkPTIpDQpwb2ludHMoc3B0cywgY29sPSdsaWdodCBncmF5JywgcGNoPTIwLCBjZXg9NikNCnRleHQoc3B0cywgMTpucm93KHB0cyksIGNvbD0ncmVkJywgZm9udD0yLCBjZXg9MS41KQ0KbGluZXMoVGFpd2FuLCBjb2w9J2JsdWUnLCBsd2Q9MikNCmBgYA0KDQpgZXh0cmFjdGAgaXMgdXNlZCBmb3IgcXVlcmllcyBiZXR3ZWVuIFNwYXRWZWN0b3IgYW5kIFNwYXRSYXN0ZXIgb2JqZWN0cywgYW5kIGFsc28gZm9yIHF1ZXJpZXMgYmV0d2VlbiBTcGF0VmVjdG9ycy4NCg0KYGBge3IsICBldmFsPVR9DQpleHRyYWN0KHNwdHMsIFRhaXdhbikNCmBgYA0KDQojIFJhc3RlciBkYXRhIG1hbmlwdWxhdGlvbg0KDQpgdGVycmFgIGhhcyBhIGxhcmdlIG51bWJlciBvZiBmdW5jdGlvbnMsIG5vdCBhbGwgb2YgdGhlbSBhcmUgZGlzY3Vzc2VkIGhlcmUsIGFuZCB0aG9zZSB0aGF0IGFyZSBkaXNjdXNzZWQgYXJlIG1lbnRpb25lZCBvbmx5IGJyaWVmbHkuIFNlZSB0aGUgaGVscCBmaWxlcyBvZiB0aGUgcGFja2FnZSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBpbmRpdmlkdWFsIGZ1bmN0aW9ucyBhbmQgYGhlbHAoInRlcnJhLXBhY2thZ2UiKWAgZm9yIGFuIGluZGV4IG9mIGZ1bmN0aW9ucyBieSB0b3BpYy4NCg0KIyMgQ3JlYXRpbmcgU3BhdFJhc3RlciBvYmplY3RzDQoNCkEgYFNwYXRSYXN0ZXJgIGNhbiBlYXNpbHkgYmUgY3JlYXRlZCBmcm9tIHNjcmF0Y2ggdXNpbmcgdGhlIGZ1bmN0aW9uIGByYXN0YC4gVGhlIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBjcmVhdGUgYSBnbG9iYWwgcmFzdGVyIGRhdGEgc3RydWN0dXJlIHdpdGggYSBsb25naXR1ZGUvbGF0aXR1ZGUgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtIGFuZCAxIGJ5IDEgZGVncmVlIGNlbGxzLiBZb3UgY2FuIGNoYW5nZSB0aGVzZSBzZXR0aW5ncyBieSBwcm92aWRpbmcgYWRkaXRpb25hbCBhcmd1bWVudHMgc3VjaCBhcyBgeG1pbmAsIGBucm93YCwgYG5jb2xgLCBhbmQvb3IgYGNyc2AsIHRvIHRoZSBmdW5jdGlvbi4gWW91IGNhbiBhbHNvIGNoYW5nZSB0aGVzZSBwYXJhbWV0ZXJzIGFmdGVyIGNyZWF0aW5nIHRoZSBvYmplY3QuIElmIHlvdSBzZXQgdGhlIHByb2plY3Rpb24sIHRoaXMgaXMgb25seSB0byBwcm9wZXJseSBkZWZpbmUgaXQsIG5vdCB0byBjaGFuZ2UgaXQuIFRvIHRyYW5zZm9ybSBhIGBTcGF0UmFzdGVyYCB0byBhbm90aGVyIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbSAocHJvamVjdGlvbikgeW91IGNhbiB1c2UgdGhlIGBwcm9qZWN0YCBmdW5jdGlvbi4NCg0KSGVyZSBpcyBhbiBleGFtcGxlIG9mIGNyZWF0aW5nIGFuZCBjaGFuZ2luZyBhIFNwYXRSYXN0ZXIgb2JqZWN0IOKAmHLigJkgZnJvbSBzY3JhdGNoLg0KDQoNCmBgYHtyLCAgZXZhbD1UfQ0KbGlicmFyeSAodGVycmEpDQp4PC1yYXN0KCkNCngNCmBgYA0KDQp3aXRoIHNvbWUgb3RoZXIgcGFyYW1ldGVycw0KDQpgYGB7ciwgIGV2YWw9VH0NCnggPC0gcmFzdChuY29sPTM2LCBucm93PTE4LCB4bWluPS0xMDAwLCB4bWF4PTEwMDAsIHltaW49LTEwMCwgeW1heD05MDApDQpgYGANCg0KVGhlc2UgcGFyYW1ldGVycyBjYW4gYmUgY2hhbmdlZC4gUmVzb2x1dGlvbjoNCg0KYGBge3IsICBldmFsPVR9DQpyZXMoeCkNCnJlcyh4KSA8LSAxMDANCnJlcyh4KQ0KYGBgDQoNCkNoYW5nZSB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgKHRoaXMgYWZmZWN0cyB0aGUgcmVzb2x1dGlvbikuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KbmNvbCh4KQ0KbmNvbCh4KSA8LSAxOA0KbmNvbCh4KQ0KcmVzKHgpDQpgYGANCg0KU2V0IHRoZSBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW0gKENSUykgKGkuZS4sIGRlZmluZSB0aGUgcHJvamVjdGlvbikuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KY3JzKHgpIDwtICIrcHJvaj11dG0gK3pvbmU9NDggK2RhdHVtPVdHUzg0Ig0KeA0KYGBgDQoNClRoZSBvYmplY3QgYHhgIGNyZWF0ZWQgaW4gdGhlIGV4YW1wbGVzIGFib3ZlIG9ubHkgY29uc2lzdHMgb2YgdGhlIHJhc3RlciAqZ2VvbWV0cnkqLCB0aGF0IGlzLCB3ZSBoYXZlIGRlZmluZWQgdGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zLCBhbmQgd2hlcmUgdGhlIHJhc3RlciBpcyBsb2NhdGVkIGluIGdlb2dyYXBoaWMgc3BhY2UsIGJ1dCB0aGVyZSBhcmUgbm8gY2VsbC12YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGl0LiBTZXR0aW5nIGFuZCBhY2Nlc3NpbmcgdmFsdWVzIGlzIGlsbHVzdHJhdGVkIGJlbG93Lg0KDQpGaXJzdCBhbm90aGVyIGV4YW1wbGUgZW1wdHkgcmFzdGVyIGdlb21ldHJ5Lg0KDQpgYGB7ciwgIGV2YWw9VH0NCnIgPC0gcmFzdChuY29sPTEwLCBucm93PTEwKQ0KbmNlbGwocikNCmhhc1ZhbHVlcyhyKSAjIGNoZWNrIGlmIGluLW1lbW9yeSBsYXllcnMgYWN0dWFsbHkgaGF2ZSBjZWxsIHZhbHVlcw0KYGBgDQoNClVzZSB0aGUgYHZhbHVlc2AgZnVuY3Rpb24uDQoNCmBgYHtyLCAgZXZhbD1UfQ0KdmFsdWVzKHIpIDwtIDE6bmNlbGwocikNCmBgYA0KDQpBbm90aGVyIGV4YW1wbGU6IA0KDQpgYGB7ciwgIGV2YWw9VH0NCnNldC5zZWVkKDApDQp2YWx1ZXMocikgPC0gcnVuaWYobmNlbGwocikpDQpoYXNWYWx1ZXMocikNCnNvdXJjZXMocikgIyBHZXQgdGhlIGRhdGEgc291cmNlcyBvZiBhIFNwYXRSYXN0ZXI6IFNvdXJjZXMgYXJlIGVpdGhlciBmaWxlcyAob3Igc2ltaWxhciByZXNvdXJjZXMpIG9yICIiLCBtZWFuaW5nIHRoYXQgdGhleSBhcmUgaW4gbWVtb3J5LiANCnZhbHVlcyhyKVsxOjEwXQ0KcGxvdChyLCBtYWluPSdSYXN0ZXIgd2l0aCAxMDAgY2VsbHMnKQ0KYGBgDQoNCkluIHNvbWUgY2FzZXMsIGZvciBleGFtcGxlIHdoZW4geW91IGNoYW5nZSB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgb3Igcm93cywgeW91IHdpbGwgbG9zZSB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgYFNwYXRSYXN0ZXJgIGlmIHRoZXJlIHdlcmUgYW55IChvciB0aGUgbGluayB0byBhIGZpbGUgaWYgdGhlcmUgd2FzIG9uZSkuIFRoZSBzYW1lIGFwcGxpZXMsIGluIG1vc3QgY2FzZXMsIGlmIHlvdSBjaGFuZ2UgdGhlIHJlc29sdXRpb24gZGlyZWN0bHkgKGFzIHRoaXMgY2FuIGFmZmVjdCB0aGUgbnVtYmVyIG9mIHJvd3Mgb3IgY29sdW1ucykuIFZhbHVlcyBhcmUgbm90IGxvc3Qgd2hlbiBjaGFuZ2luZyB0aGUgZXh0ZW50IGFzIHRoaXMgY2hhbmdlIGFkanVzdHMgdGhlIHJlc29sdXRpb24sIGJ1dCBkb2VzIG5vdCBjaGFuZ2UgdGhlIG51bWJlciBvZiByb3dzIG9yIGNvbHVtbnMuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KaGFzVmFsdWVzKHIpDQpyZXMocikNCmRpbShyKQ0KZXh0KHIpDQpgYGANCg0KTm93IGNoYW5nZSB0aGUgbWF4aW11bSB4IGNvb3JkaW5hdGUgb2YgdGhlIGV4dGVudCAoYm91bmRpbmcgYm94KSBvZiB0aGUgYFNwYXRSYXN0ZXJgLg0KDQpgYGB7ciwgIGV2YWw9VH0NCnhtYXgocikgPC0gMA0KaGFzVmFsdWVzKHIpDQpyZXMocikNCmRpbShyKQ0KYGBgDQoNCkFuZCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgKHRoZSB2YWx1ZXMgZGlzYXBwZWFyKQ0KDQpgYGB7ciwgIGV2YWw9VH0NCm5jb2wocikgPC0gNg0KaGFzVmFsdWVzKHIpDQpyZXMocikNCmRpbShyKQ0KeG1heChyKQ0KYGBgDQoNCldoaWxlIHdlIGNhbiBjcmVhdGUgYSBgU3BhdFJhc3RlcmAgZnJvbSBzY3JhdGNoLCBpdCBpcyBtb3JlIGNvbW1vbiB0byBkbyBzbyBmcm9tIGEgZmlsZS4gVGhlIGB0ZXJyYWAgcGFja2FnZSBjYW4gdXNlIHJhc3RlciBmaWxlcyBpbiBzZXZlcmFsIGZvcm1hdHMsIGluY2x1ZGluZyBHZW9UaWZmLCBFU1JJLCBFTlZJLCBhbmQgRVJEQVMuDQoNCkEgbm90YWJsZSBmZWF0dXJlIG9mIHRoZSBgdGVycmFgIHBhY2thZ2UgaXMgdGhhdCBpdCBjYW4gd29yayB3aXRoIHJhc3RlciBkYXRhc2V0cyB0aGF0IGFyZSBzdG9yZWQgb24gZGlzayBhbmQgYXJlIHRvbyBsYXJnZSB0byBiZSBsb2FkZWQgaW50byBtZW1vcnkgKFJBTSkuIFRoZSBwYWNrYWdlIGNhbiB3b3JrIHdpdGggbGFyZ2UgZmlsZXMgYmVjYXVzZSB0aGUgb2JqZWN0cyBpdCBjcmVhdGVzIGZyb20gdGhlc2UgZmlsZXMgb25seSBjb250YWluIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGRhdGEsIHN1Y2ggYXMgdGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zLCB0aGUgc3BhdGlhbCBleHRlbnQsIGFuZCB0aGUgZmlsZW5hbWUsIGJ1dCBpdCBkb2VzIG5vdCBhdHRlbXB0IHRvIHJlYWQgYWxsIHRoZSBjZWxsIHZhbHVlcyBpbiBtZW1vcnkuIEluIGNvbXB1dGF0aW9ucyB3aXRoIHRoZXNlIG9iamVjdHMsIGRhdGEgaXMgcHJvY2Vzc2VkIGluIGNodW5rcy4gSWYgbm8gb3V0cHV0IGZpbGVuYW1lIGlzIHNwZWNpZmllZCB0byBhIGZ1bmN0aW9uLCBhbmQgdGhlIG91dHB1dCByYXN0ZXIgaXMgdG9vIGxhcmdlIHRvIGtlZXAgaW4gbWVtb3J5LCB0aGUgcmVzdWx0cyBhcmUgd3JpdHRlbiB0byBhIHRlbXBvcmFyeSBmaWxlLg0KDQpCZWxvdyB3ZSBmaXJzdCB3ZSBnZXQgdGhlIG5hbWUgb2YgYW4gZXhhbXBsZSByYXN0ZXIgZmlsZSB0aGF0IGlzIGluc3RhbGxlZCB3aXRoIHRoZSBgdGVycmFgIHBhY2thZ2UuIERvIG5vdCB1c2UgdGhpcyBzeXN0ZW0uZmlsZSBjb25zdHJ1Y3Rpb24gZm9yIHlvdXIgb3duIGZpbGVzLiBKdXN0IHR5cGUgdGhlIGZpbGUgbmFtZSBhcyB5b3Ugd291bGQgZG8gZm9yIGFueSBvdGhlciBmaWxlLCBidXQgZG9u4oCZdCBmb3JnZXQgdG8gdXNlIGZvcndhcmQgc2xhc2hlcyBhcyBwYXRoIHNlcGFyYXRvcnMuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KZmlsZW5hbWUgPC0gc3lzdGVtLmZpbGUoImV4L2VsZXYudGlmIiwgcGFja2FnZT0idGVycmEiKQ0KYmFzZW5hbWUoZmlsZW5hbWUpDQpgYGANCg0KVGhhdCdzIHRlaCBmaWxlIHdpdGggdGhlIGVsZXZhdGlvbiBvZiBMdXhlbWJvdXJnLg0KDQpgYGB7ciwgIGV2YWw9VH0NCnIgPC0gcmFzdChmaWxlbmFtZSkNCnNvdXJjZXMocikNCmhhc1ZhbHVlcyhyKQ0KcGxvdChyLCBtYWluPSJTcGF0UmFzdGVyIGZyb20gZmlsZSIpDQpgYGANCg0KQW4gZXhhbXBsZSB3aXRoIEdlb1RpZmYgb2YgVGFpd2FuIFBvcHVsYXRpb24gZGVuc2l0eSAoMjAxNSkgYXZhaWxhYmxlIFtoZXJlXShodHRwczovL2VuZXJneWRhdGEuaW5mby9kYXRhc2V0L3RhaXdhbi0tcG9wdWxhdGlvbi1kZW5zaXR5LTIwMTUvcmVzb3VyY2UvYWM5ODJhNGYtNzg0Yi00YzlmLWExMjQtODc2ODU1NmM4OWViKS4NCg0KDQpgYGB7ciwgIGV2YWw9VH0NCnRhaS5wb3AgPC0gcmFzdCgnLi9kYXRhL3BvcG1hcDE1YWRqLnRpZicpDQpwYXIobWZyb3c9YygxLDIpKQ0KIyBwbG90KHRhaS5wb3AsIG1haW49IlRhaXdhbiAtIFBvcHVsYXRpb24gRGVuc2l0eSAoMjAxNSkiKQ0KIyBOZWVkIGEgbG9nIHRyYW5zZm9ybWF0b24NCnBsb3QobG9nKHRhaS5wb3ArMSksIG1haW49IlRhaXdhbiAtIGxvZy10cmFuc2Zvcm1lZCBQb3B1bGF0aW9uIERlbnNpdHkgKDIwMTUpIikNCmBgYA0KDQpXZSBjYW4gYWxzbyB1c2Ugb3VyIHByZXZpb3VzIFNwYXRSYXN0ZXIgb2YgZWxldmF0aW9uIG9mIFRhaXdhbiBpbiBhIG5pY2VyIG1hcDogDQoNCmBgYHtyLCAgZXZhbD1UfQ0KbGlicmFyeShnZW9kYXRhKQ0KbGlicmFyeShnZ3Bsb3QyKQ0KbGlicmFyeShnZ3NwYXRpYWwpDQplbGUgPC1lbGV2YXRpb25fMzBzKCJUV04iLCBwYXRoPXRlbXBkaXIoKSkNCmdncGxvdCgpKw0KICBsYXllcl9zcGF0aWFsKGVsZSkrDQogIHNjYWxlX2ZpbGxfY29udGludW91cyhuYS52YWx1ZSA9ICd0cmFuc3BhcmVudCcsIG5hbWU9J0VsZXZhdGlvbiAobSknKSsNCiAgZ2dzcGF0aWFsOjphbm5vdGF0aW9uX25vcnRoX2Fycm93KA0KICAgIGxvY2F0aW9uID0gInRsIiwgd2hpY2hfbm9ydGggPSAidHJ1ZSIsDQogICAgc3R5bGUgPSBnZ3NwYXRpYWw6Om5vcnRoX2Fycm93X25hdXRpY2FsKGZpbGwgPSBjKCJncmV5NDAiLCAid2hpdGUiKSwgbGluZV9jb2wgPSAiZ3JleTIwIikpKw0KICBnZ3NwYXRpYWw6OmFubm90YXRpb25fc2NhbGUgKCkgKw0KICB0aGVtZV9idygpDQpgYGANCg0KTXVsdGktbGF5ZXIgb2JqZWN0cyBjYW4gYmUgY3JlYXRlZCBpbiBtZW1vcnkgb3IgZnJvbSBmaWxlcy4NCg0KQ3JlYXRlIHRocmVlIGlkZW50aWNhbCBgU3BhdFJhc3RlcmAgb2JqZWN0czoNCg0KDQpgYGB7ciwgIGV2YWw9VH0NCnIxIDwtIHIyIDwtIHIzIDwtIHJhc3QobnJvdz0xMCwgbmNvbD0xMCkNCiMgQXNzaWduIHJhbmRvbSBjZWxsIHZhbHVlcw0KdmFsdWVzKHIxKSA8LSBydW5pZihuY2VsbChyMSkpDQp2YWx1ZXMocjIpIDwtIHJ1bmlmKG5jZWxsKHIyKSkNCnZhbHVlcyhyMykgPC0gcnVuaWYobmNlbGwocjMpKQ0KYGBgDQoNCkNvbWJpbmUgdGhyZWUgYFNwYXRSYXN0ZXJgOg0KDQpgYGB7ciwgIGV2YWw9VH0NCnMgPC0gYyhyMSwgcjIsIHIzKQ0Kcw0Kbmx5cihzKQ0KYGBgDQoNCg0KWW91IGNhbiBhbHNvIGNyZWF0ZSBhIG11bHRpbGF5ZXIgb2JqZWN0IGZyb20gYSBmaWxlLg0KDQpgYGB7ciwgIGV2YWw9VH0NCmZpbGVuYW1lIDwtIHN5c3RlbS5maWxlKCJleC9sb2dvLnRpZiIsIHBhY2thZ2U9InRlcnJhIikNCmJhc2VuYW1lKGZpbGVuYW1lKQ0KYiA8LSByYXN0KGZpbGVuYW1lKQ0KYg0Kbmx5cihiKQ0KYGBgDQoNCkV4dHJhY3QgYSBzaW5nbGUgbGF5ZXIgKHRoZSBzZWNvbmQgb25lIG9uIHRoaXMgY2FzZSkNCg0KYGBge3IsICBldmFsPVR9DQpyIDwtIGJbWzJdXQ0KYGBgDQoNCiMjIFJhc3RlciBhbGdlYnJhIChleHRyYSkNCg0KTWFueSBnZW5lcmljIGZ1bmN0aW9ucyB0aGF0IGFsbG93IGZvciBzaW1wbGUgYW5kIGVsZWdhbnQgcmFzdGVyIGFsZ2VicmEgaGF2ZSBiZWVuIGltcGxlbWVudGVkIGZvciBSYXN0ZXIgb2JqZWN0cywgaW5jbHVkaW5nIHRoZSBub3JtYWwgYWxnZWJyYWljIG9wZXJhdG9ycyBzdWNoIGFzIGArYCwgYC1gLCBgKmAsIGAvYCwgbG9naWNhbCBvcGVyYXRvcnMgc3VjaCBhcyBgPmAsIGA+PWAsIGA8YCwgYD09YCwgYCFgIGFuZCBmdW5jdGlvbnMgbGlrZSBgYWJzYCwgYHJvdW5kYCwgYGNlaWxpbmdgLCBgZmxvb3JgLCBgdHJ1bmNgLCBgc3FydGAsIGBsb2dgLCBgbG9nMTBgLCBgZXhwYCwgYGNvc2AsIGBzaW5gLCBgYXRhbmAsIGB0YW5gLCBgbWF4YCwgYG1pbmAsIGByYW5nZWAsIGBwcm9kYCwgYHN1bWAsIGBhbnlgLCBgYWxsYC4gSW4gdGhlc2UgZnVuY3Rpb25zIHlvdSBjYW4gbWl4IHJhc3RlciBvYmplY3RzIHdpdGggbnVtYmVycywgYXMgbG9uZyBhcyB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSByYXN0ZXIgb2JqZWN0Lg0KDQpDcmVhdGUgYW4gZW1wdHkgYFNwYXRSYXN0ZXJgIGFuZCBhc3NpZ24gdmFsdWVzIHRvIGNlbGxzLg0KDQpgYGB7ciwgIGV2YWw9VH0NCnIgPC0gcmFzdChuY29sPTEwLCBucm93PTEwKQ0KdmFsdWVzKHIpIDwtIDE6bmNlbGwocikNCmBgYA0KDQpOb3cgc29tZSByYXN0ZXIgYWxnZWJyYS4NCg0KYGBge3IsICBldmFsPVR9DQpzIDwtIHIgKyAxMA0KcyA8LSBzcXJ0KHMpDQpzIDwtIHMgKiByICsgNQ0KdmFsdWVzKHIpIDwtIHJ1bmlmKG5jZWxsKHIpKQ0KciA8LSByb3VuZChyKQ0KciA8LSByID09IDENCmBgYA0KDQpZb3UgY2FuIGFsc28gdXNlIHJlcGxhY2VtZW50IGZ1bmN0aW9ucy4NCg0KYGBge3IsICBldmFsPVR9DQojTm90IHlldCBpbXBsZW1lbnRlZA0Kc1tyXSA8LSAtMC41DQpzWyFyXSA8LSA1DQpzW3MgPT0gNV0gPC0gMTUNCmBgYA0KDQoNCklmIHlvdSB1c2UgbXVsdGlwbGUgYFNwYXRSYXN0ZXJgIG9iamVjdHMgKGluIGZ1bmN0aW9ucyB3aGVyZSB0aGlzIGlzIHJlbGV2YW50LCBzdWNoIGFzIHJhbmdlKSwgdGhlc2UgbXVzdCBoYXZlIHRoZSBzYW1lIHJlc29sdXRpb24gYW5kIG9yaWdpbi4gVGhlIG9yaWdpbiBvZiBhIGBSYXN0ZXJgIG9iamVjdCBpcyB0aGUgcG9pbnQgY2xvc2VzdCB0byAoMCwgMCkgdGhhdCB5b3UgY291bGQgZ2V0IGlmIHlvdSBtb3ZlZCBmcm9tIGEgY29ybmVyIG9mIGEgYFNwYXRSYXN0ZXJgIHRvd2FyZCB0aGF0IHBvaW50IGluIHN0ZXBzIG9mIHRoZSB4IGFuZCB5IHJlc29sdXRpb24uIE5vcm1hbGx5IHRoZXNlIG9iamVjdHMgd291bGQgYWxzbyBoYXZlIHRoZSBzYW1lIGV4dGVudCwgYnV0IGlmIHRoZXkgZG8gbm90LCB0aGUgcmV0dXJuZWQgb2JqZWN0IGNvdmVycyB0aGUgc3BhdGlhbCBpbnRlcnNlY3Rpb24gb2YgdGhlIG9iamVjdHMgdXNlZC4NCg0KV2hlbiB5b3UgdXNlIG11bHRpcGxlIG11bHRpLWxheWVyIG9iamVjdHMgd2l0aCBkaWZmZXJlbnQgbnVtYmVycyBvciBsYXllcnMsIHRoZSDigJhzaG9ydGVy4oCZIG9iamVjdHMgYXJlIOKAmHJlY3ljbGVk4oCZLiBGb3IgZXhhbXBsZSwgaWYgeW91IG11bHRpcGx5IGEgNC1sYXllciBvYmplY3QgKGBhMWAsIGBhMmAsIGBhM2AsIGBhNGApIHdpdGggYSAyLWxheWVyIG9iamVjdCAoYGIxYCwgYGIyYCksIHRoZSByZXN1bHQgaXMgYSBmb3VyLWxheWVyIG9iamVjdCAoYGExKmIxYCwgYGEyKmIyYCwgYGEzKmIxYCwgYGEzKmIyYCkuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KciA8LSByYXN0KG5jb2w9NSwgbnJvdz01KQ0KdmFsdWVzKHIpIDwtIDENCnMgPC0gYyhyLCByKzEpDQpxIDwtIGMociwgcisyLCByKzQsIHIrNikNCnggPC0gciArIHMgKyBxDQp4DQpgYGANCg0KU3VtbWFyeSBmdW5jdGlvbnMgKGBtaW5gLCBgbWF4YCwgYG1lYW5gLCBgcHJvZGAsIGBzdW1gLCBgbWVkaWFuYCwgYGN2YCwgYHJhbmdlYCwgYGFueWAsIGBhbGxgKSBhbHdheXMgcmV0dXJuIGEgYFNwYXRSYXN0ZXJgIG9iamVjdC4gUGVyaGFwcyB0aGlzIGlzIG5vdCBvYnZpb3VzIHdoZW4gdXNpbmcgZnVuY3Rpb25zIGxpa2UgYG1pbmAsIGBzdW1gIG9yIGBtZWFuYC4NCg0KYGBge3IsICBldmFsPVR9DQphIDwtIG1lYW4ocixzLDEwKQ0KYiA8LSBzdW0ocixzKQ0Kc3QgPC0gYyhyLCBzLCBhLCBiKQ0Kc3N0IDwtIHN1bShzdCkNCnNzdA0KYGBgDQoNCg0KVXNlIGBnbG9iYWxgIGlmIHlvdSB3YW50IGEgc2luZ2xlIG51bWJlciBzdW1tYXJpemluZyB0aGUgY2VsbCB2YWx1ZXMgb2YgZWFjaCBsYXllci4NCg0KYGBge3IsICBldmFsPVR9DQpnbG9iYWwoc3QsICdzdW0nKQ0KYGBgDQoNCiMjIOKAmEhpZ2gtbGV2ZWzigJkgZnVuY3Rpb25zIChleHRyYSkNCg0KU2V2ZXJhbCDigJhoaWdoIGxldmVs4oCZIGZ1bmN0aW9ucyBoYXZlIGJlZW4gaW1wbGVtZW50ZWQgZm9yIGBTcGF0UmFzdGVyYCBvYmplY3RzLiDigJhIaWdoIGxldmVs4oCZIGZ1bmN0aW9ucyByZWZlciB0byBmdW5jdGlvbnMgdGhhdCB5b3Ugd291bGQgbm9ybWFsbHkgZmluZCBpbiBhIGNvbXB1dGVyIHByb2dyYW0gdGhhdCBzdXBwb3J0cyB0aGUgYW5hbHlzaXMgb2YgcmFzdGVyIGRhdGEuIEhlcmUgd2UgYnJpZWZseSBkaXNjdXNzIHNvbWUgb2YgdGhlc2UgZnVuY3Rpb25zLiBBbGwgdGhlc2UgZnVuY3Rpb25zIHdvcmsgZm9yIHJhc3RlciBkYXRhc2V0cyB0aGF0IGNhbm5vdCBiZSBsb2FkZWQgaW50byBtZW1vcnkuIFNlZSB0aGUgaGVscCBmaWxlcyBmb3IgbW9yZSBkZXRhaWxlZCBkZXNjcmlwdGlvbnMgb2YgZWFjaCBmdW5jdGlvbi4NCg0KVGhlIGhpZ2gtbGV2ZWwgZnVuY3Rpb25zIGhhdmUgc29tZSBhcmd1bWVudHMgaW4gY29tbW9uLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdHlwaWNhbGx5IGEgYFNwYXRSYXN0ZXJgIOKAmHjigJkgb3Ig4oCYb2JqZWN04oCZLiBJdCBpcyBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBhcmd1bWVudHMgc3BlY2lmaWMgdG8gdGhlIGZ1bmN0aW9uIChlaXRoZXIgYWRkaXRpb25hbCBgU3BhdFJhc3RlcmAgb2JqZWN0cyBvciBvdGhlciBhcmd1bWVudHMpLCBmb2xsb3dlZCBieSBgZmlsZW5hbWVgIGFuZCBgLi4uYCBhcmd1bWVudHMuDQoNClRoZSBkZWZhdWx0IGZpbGVuYW1lIGlzIGFuIGVtcHR5IGNoYXJhY3RlciBgIiJgLiBJZiB5b3UgZG8gbm90IHNwZWNpZnkgYSBmaWxlbmFtZSwgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciB0aGUgZnVuY3Rpb24gaXMgdG8gcmV0dXJuIGEgYHJhc3RlcmAgb2JqZWN0IHRoYXQgb25seSBleGlzdHMgaW4gbWVtb3J5LiBIb3dldmVyLCBpZiB0aGUgZnVuY3Rpb24gZGVlbXMgdGhhdCB0aGUgYHJhc3RlcmAgb2JqZWN0IHRvIGJlIGNyZWF0ZWQgd291bGQgYmUgdG9vIGxhcmdlIHRvIGhvbGQgaW4gbWVtb3J5LCBpdCBpcyB3cml0dGVuIHRvIGEgdGVtcG9yYXJ5IGZpbGUgaW5zdGVhZC4NCg0KVGhlIGAuLi5gIGFyZ3VtZW50IGFsbG93cyBmb3Igc2V0dGluZyBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGFyZSByZWxldmFudCB3aGVuIHdyaXRpbmcgdmFsdWVzIHRvIGEgZmlsZTogdGhlIGZpbGUgZm9ybWF0LCBkYXRhdHlwZSAoZS5nLiBpbnRlZ2VyIG9yIHJlYWwgdmFsdWVzKSwgYW5kIGEgdG8gaW5kaWNhdGUgd2hldGhlciBleGlzdGluZyBmaWxlcyBzaG91bGQgYmUgb3ZlcndyaXR0ZW4uDQoNCiMjIyBNb2RpZnlpbmcgYSBTcGF0UmFzdGVyIG9iamVjdA0KDQpUaGVyZSBhcmUgc2V2ZXJhbCBmdW5jdGlvbnMgdGhhdCBkZWFsIHdpdGggbW9kaWZ5aW5nIHRoZSBzcGF0aWFsIGV4dGVudCBvZiBgU3BhdFJhc3RlcmAgb2JqZWN0cy4gVGhlIGBjcm9wYCBmdW5jdGlvbiBsZXRzIHlvdSB0YWtlIGEgZ2VvZ3JhcGhpYyBzdWJzZXQgb2YgYSBsYXJnZXIgYHJhc3RlcmAgb2JqZWN0LiBZb3UgY2FuIGNyb3AgYSBgU3BhdFJhc3RlcmAgYnkgcHJvdmlkaW5nIGFuIGV4dGVudCBvYmplY3Qgb3IgYW5vdGhlciBzcGF0aWFsIG9iamVjdCBmcm9tIHdoaWNoIGFuIGV4dGVudCBjYW4gYmUgZXh0cmFjdGVkIChvYmplY3RzIGZyb20gY2xhc3NlcyBkZXJpdmluZyBmcm9tIGBSYXN0ZXJgIGFuZCBmcm9tIGBTcGF0aWFsYCBpbiB0aGUgYHNwYCBwYWNrYWdlKS4gQW4gZWFzeSB3YXkgdG8gZ2V0IGFuIGV4dGVudCBvYmplY3QgaXMgdG8gcGxvdCBhIGBTcGF0UmFzdGVyYCBhbmQgdGhlbiB1c2UgYGRyYXdFeHRlbnRgIHRvIHZpc3VhbGx5IGRldGVybWluZSB0aGUgbmV3IGV4dGVudCAoYm91bmRpbmcgYm94KSB0byBwcm92aWRlIHRvIHRoZSBjcm9wIGZ1bmN0aW9uLg0KDQpgdHJpbWAgY3JvcHMgYSBgU3BhdFJhc3RlcmAgYnkgcmVtb3ZpbmcgdGhlIG91dGVyIHJvd3MgYW5kIGNvbHVtbnMgdGhhdCBvbmx5IGNvbnRhaW4gYE5BYCB2YWx1ZXMuIEluIGNvbnRyYXN0LCBgZXh0ZW5kYCBhZGRzIG5ldyByb3dzIGFuZC9vciBjb2x1bW5zIHdpdGggYE5BYCB2YWx1ZXMuIFRoZSBwdXJwb3NlIG9mIHRoaXMgY291bGQgYmUgdG8gY3JlYXRlIGEgbmV3IGBTcGF0UmFzdGVyYCB3aXRoIHRoZSBzYW1lIEV4dGVudCBvZiBhbm90aGVyLCBsYXJnZXIsIGBTcGF0UmFzdGVyYCBzdWNoIHRoYXQgdGhleSBjYW4gYmUgdXNlZCB0b2dldGhlciBpbiBvdGhlciBmdW5jdGlvbnMuDQoNClRoZSBgbWVyZ2VgIGZ1bmN0aW9uIGxldHMgeW91IG1lcmdlIDIgb3IgbW9yZSBTcGF0UmFzdGVyIG9iamVjdHMgaW50byBhIHNpbmdsZSBuZXcgb2JqZWN0LiBUaGUgaW5wdXQgb2JqZWN0cyBtdXN0IGhhdmUgdGhlIHNhbWUgcmVzb2x1dGlvbiBhbmQgb3JpZ2luIChzdWNoIHRoYXQgdGhlaXIgY2VsbHMgbmVhdGx5IGZpdCBpbnRvIGEgc2luZ2xlIGxhcmdlciByYXN0ZXIpLiBJZiB0aGlzIGlzIG5vdCB0aGUgY2FzZSB5b3UgY2FuIGZpcnN0IGFkanVzdCBvbmUgb2YgdGhlIFNwYXRSYXN0ZXIgb2JqZWN0cyB3aXRoIGBhZ2dyZWdhdGVgL2BkaXNhZ2dgIG9yIGByZXNhbXBsZWAuDQoNCmBhZ2dyZWdhdGVgIGFuZCBgZGlzYWdnYCBhbGxvdyBmb3IgY2hhbmdpbmcgdGhlIHJlc29sdXRpb24gKGNlbGwgc2l6ZSkgb2YgYSBTcGF0UmFzdGVyIG9iamVjdC4gSW4gdGhlIGNhc2Ugb2YgYWdncmVnYXRlLCB5b3UgbmVlZCB0byBzcGVjaWZ5IGEgZnVuY3Rpb24gZGV0ZXJtaW5pbmcgd2hhdCB0byBkbyB3aXRoIHRoZSBncm91cGVkIGNlbGwgdmFsdWVzIG1lYW4uIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgZGlmZmVyZW50IChkaXMpYWdncmVnYXRpb24gZmFjdG9ycyBpbiB0aGUgeCBhbmQgeSBkaXJlY3Rpb24uIGBhZ2dyZWdhdGVgIGFuZCBgZGlzYWdnYCBhcmUgdGhlIGJlc3QgZnVuY3Rpb25zIHdoZW4gYWRqdXN0aW5nIGNlbGxzIHNpemUgb25seSwgd2l0aCBhbiBpbnRlZ2VyIHN0ZXAgKGUuZy4gZWFjaCBzaWRlIDIgdGltZXMgc21hbGxlciBvciBsYXJnZXIpLCBidXQgaW4gc29tZSBjYXNlcyB0aGF0IGlzIG5vdCBwb3NzaWJsZS4NCg0KRm9yIGV4YW1wbGUsIHlvdSBtYXkgbmVlZCBuZWFybHkgdGhlIHNhbWUgY2VsbCBzaXplLCB3aGlsZSBzaGlmdGluZyB0aGUgY2VsbCBjZW50ZXJzLiBJbiB0aG9zZSBjYXNlcywgdGhlIGByZXNhbXBsZWAgZnVuY3Rpb24gY2FuIGJlIHVzZWQuIEl0IGNhbiBkbyBlaXRoZXIgbmVhcmVzdCBuZWlnaGJvciBhc3NpZ25tZW50cyAoZm9yIGNhdGVnb3JpY2FsIGRhdGEpIG9yIGJpbGluZWFyIGludGVycG9sYXRpb24gKGZvciBudW1lcmljYWwgZGF0YSkuIFNpbXBsZSBsaW5lYXIgc2hpZnRzIG9mIGEgUmFzdGVyIG9iamVjdCBjYW4gYmUgYWNjb21wbGlzaGVkIHdpdGggdGhlIGBzaGlmdGAgZnVuY3Rpb24gb3Igd2l0aCB0aGUgYGV4dGVudGAgZnVuY3Rpb24uDQoNCldpdGggdGhlIGB3YXJwYCBmdW5jdGlvbiB5b3UgY2FuIHRyYW5zZm9ybSB2YWx1ZXMgb2YgYFNwYXRSYXN0ZXJgIG9iamVjdCB0byBhIG5ldyBvYmplY3Qgd2l0aCBhIGRpZmZlcmVudCBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW0uDQoNCkhlcmUgYXJlIHNvbWUgc2ltcGxlIGV4YW1wbGVzLg0KDQpBZ2dyZWdhdGUgYW5kIGRpc2FnZ3JlZ2F0ZS4NCg0KYGBge3IsICBldmFsPVR9DQpyIDwtIHJhc3QoKQ0KdmFsdWVzKHIpIDwtIDE6bmNlbGwocikNCnJhIDwtIGFnZ3JlZ2F0ZShyLCAyMCkNCnJkIDwtIGRpc2FnZyhyYSwgMjApDQpgYGANCg0KQ3JvcCBhbmQgbWVyZ2UgZXhhbXBsZS4NCg0KYGBge3IsICBldmFsPVR9DQpyMSA8LSBjcm9wKHIsIGV4dCgtNTAsMCwwLDMwKSkNCnIyIDwtIGNyb3AociwgZXh0KC0xMCw1MCwtMjAsIDEwKSkNCm0gPC0gbWVyZ2UocjEsIHIyLCBmaWxlbmFtZT0idGVzdC50aWYiLCBvdmVyd3JpdGU9VFJVRSkNCnBsb3QobSkNCmBgYA0KDQpgZmxpcGAgbGV0cyB5b3UgZmxpcCB0aGUgZGF0YSAocmV2ZXJzZSBvcmRlcikgaW4gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBkaXJlY3Rpb24g4oCTIHR5cGljYWxseSB0byBjb3JyZWN0IGZvciBhIOKAmGNvbW11bmljYXRpb24gcHJvYmxlbeKAmSBiZXR3ZWVuIGRpZmZlcmVudCBSIHBhY2thZ2VzIG9yIGEgbWlzaW50ZXJwcmV0ZWQgZmlsZS4gYHJvdGF0ZWAgbGV0cyB5b3Ugcm90YXRlIGxvbmdpdHVkZS9sYXRpdHVkZSByYXN0ZXJzIHRoYXQgaGF2ZSBsb25naXR1ZGVzIGZyb20gMCB0byAzNjAgZGVncmVlcyAob2Z0ZW4gdXNlZCBieSBjbGltYXRvbG9naXN0cykgdG8gdGhlIHN0YW5kYXJkIC0xODAgdG8gMTgwIGRlZ3JlZXMgc3lzdGVtLiBXaXRoIGB0YCB5b3UgY2FuIHJvdGF0ZSBhIGBTcGF0UmFzdGVyYCBvYmplY3QgOTAgZGVncmVlcy4NCg0KDQojIyMgT3ZlcmxheQ0KDQpgYXBwYCAoc2hvcnQgZm9yIOKAnGFwcGx54oCdKSBhbGxvd3MgeW91IHRvIGRvIGEgY29tcHV0YXRpb24gZm9yIGEgc2luZ2xlIGBTcGF0UmFzdGVyYCBvYmplY3QgYnkgcHJvdmlkaW5nIGEgZnVuY3Rpb24sIGUuZy4gc3VtLg0KDQpUaGUgYGxhcHBgIChsYXllci1hcHBseSkgZnVuY3Rpb24gY2FuIGJlIHVzZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIHJhc3RlciBhbGdlYnJhIGRpc2N1c3NlZCBhYm92ZS4NCg0KDQojIyMgQ2xhc3NpZnkNCg0KWW91IGNhbiB1c2UgYGNsYXNzaWZ5YCB0byByZXBsYWNlIHJhbmdlcyBvZiB2YWx1ZXMgd2l0aCBzaW5nbGUgdmFsdWVzLCBvciB0byBzdWJzdGl0dXRlIChyZXBsYWNlKSBzaW5nbGUgdmFsdWVzIHdpdGggb3RoZXIgdmFsdWVzLg0KDQpgYGB7ciwgIGV2YWw9VH0NCnIgPC0gcmFzdChuY29sPTMsIG5yb3c9MikNCnZhbHVlcyhyKSA8LSAxOm5jZWxsKHIpDQp2YWx1ZXMocikNCmBgYA0KDQpTZXQgYWxsIHZhbHVlcyBhYm92ZSA0IHRvIGBOQWANCg0KYGBge3IsICBldmFsPVR9DQpzIDwtIGFwcChyLCBmdW49ZnVuY3Rpb24oeCl7IHhbeCA8IDRdIDwtIE5BOyByZXR1cm4oeCl9ICkNCmFzLm1hdHJpeChzKQ0KYGBgDQoNCkRpdmlkZSB0aGUgZmlyc3QgcmFzdGVyIHdpdGggdHdvIHRpbWVzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc2Vjb25kIHJhc3RlciBhbmQgYWRkIGZpdmUuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KcnMgPC0gYyhyLCBzKQ0KdyA8LSBsYXBwKHJzLCBmdW49ZnVuY3Rpb24oeCwgeSl7IHggLyAoMiAqIHNxcnQoeSkpICsgNSB9ICkNCmFzLm1hdHJpeCh3KQ0KYGBgDQoNClJlbW92ZSBmcm9tIHIgYWxsIHZhbHVlcyB0aGF0IGFyZSBOQSBpbiB3Lg0KDQpgYGB7ciwgIGV2YWw9VH0NCnUgPC0gbWFzayhyLCB3KQ0KYXMubWF0cml4KHUpDQpgYGANCg0KSWRlbnRpZnkgdGhlIGNlbGwgdmFsdWVzIGluIGB1YCB0aGF0IGFyZSB0aGUgc2FtZSBhcyBpbiBgc2AuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KdiA8LSB1PT1zDQphcy5tYXRyaXgodikNCmBgYA0KDQpSZXBsYWNlIGBOQWAgdmFsdWVzIGluIHcgd2l0aCB2YWx1ZXMgb2YgYHJgLg0KDQpgYGB7ciwgIGV2YWw9VH0NCmN2ciA8LSBjb3Zlcih3LCByKQ0KYXMubWF0cml4KHcpDQpgYGANCg0KQ2hhbmdlIHZhbHVlIGJldHdlZW4gMCBhbmQgMiB0byAxLCBldGMuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KeCA8LSBjbGFzc2lmeSh3LCByYmluZChjKDAsMiwxKSwgIGMoMiw1LDIpLCBjKDQsMTAsMykpKQ0KYXMubWF0cml4KHgpDQpgYGANCg0KU3Vic3RpdHV0ZSAyIHdpdGggNDAgYW5kIDMgd2l0aCA1MC4NCg0KYGBge3IsICBldmFsPVR9DQp5IDwtIGNsYXNzaWZ5KHgsIGNiaW5kKGlkPWMoMiwzKSwgdj1jKDQwLDUwKSkpDQphcy5tYXRyaXgoeSkNCmBgYA0KDQojIyMgRm9jYWwgbWV0aG9kcw0KDQoNClRoZSBgZm9jYWxgIG1ldGhvZHMgY29tcHV0YXRlIG5ldyB2YWx1ZXMgYmFzZWQgb24gdGhlIHZhbHVlcyBpbiBhIG5laWdoYm9yaG9vZCBvZiBjZWxscyBhcm91bmQgYSBmb2NhbCBjZWxsLCBhbmQgcHV0dGluZyB0aGUgcmVzdWx0IGluIHRoZSBmb2NhbCBjZWxsIG9mIHRoZSBvdXRwdXQgU3BhdFJhc3Rlci4gVGhlIG5laWdoYm9yaG9vZCBpcyBhIHVzZXItZGVmaW5lZCBtYXRyaXggb2Ygd2VpZ2h0cyBhbmQgY291bGQgYXBwcm94aW1hdGUgYW55IHNoYXBlIGJ5IGdpdmluZyBzb21lIGNlbGxzIHplcm8gd2VpZ2h0LiBJdCBpcyBwb3NzaWJsZSB0byBvbmx5IGNvbXB1dGVzIG5ldyB2YWx1ZXMgZm9yIGNlbGxzIHRoYXQgYXJlIGBOQWAgaW4gdGhlIGlucHV0IFNwYXRSYXN0ZXIuDQoNCg0KIyMjIERpc3RhbmNlDQoNClRoZXJlIGFyZSBhIG51bWJlciBvZiBkaXN0YW5jZSByZWxhdGVkIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGUsIHlvdSBjYW4gY29tcHV0ZSB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgdG8gY2VsbHMgdGhhdCBhcmUgbm90IGBOQWAsIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSB0byBhbnkgcG9pbnQgaW4gYSBzZXQgb2YgcG9pbnRzLCBvciB0aGUgZGlzdGFuY2Ugd2hlbiBmb2xsb3dpbmcgZ3JpZCBjZWxscyB0aGF0IGNhbiBiZSB0cmF2ZXJzZWQgKGUuZy4gZXhjbHVkaW5nIHdhdGVyIGJvZGllcykuIGBkaXJlY3Rpb25gIGNvbXB1dGVzIHRoZSBkaXJlY3Rpb24gdG93YXJkIChvciBmcm9tKSB0aGUgbmVhcmVzdCBjZWxsIHRoYXQgaXMgbm90IGBOQWAuIGBhZGphY2VuY3lgIGRldGVybWluZXMgd2hpY2ggY2VsbHMgYXJlIGFkamFjZW50IHRvIG90aGVyIGNlbGxzLiBTZWUgdGhlIGBnZGlzdGFuY2VgIHBhY2thZ2UgZm9yIG1vcmUgYWR2YW5jZWQgZGlzdGFuY2UgY2FsY3VsYXRpb25zIChjb3N0IGRpc3RhbmNlLCByZXNpc3RhbmNlIGRpc3RhbmNlKS4NCg0KIyMjIFNwYXRpYWwgY29uZmlndXJhdGlvbg0KDQpgcGF0Y2hlc2AgaWRlbnRpZmllcyBncm91cHMgb2YgY2VsbHMgdGhhdCBhcmUgY29ubmVjdGVkLiBgYm91bmRhcmllc2AgaWRlbnRpZmllcyBlZGdlcywgdGhhdCBpcywgdHJhbnNpdGlvbnMgYmV0d2VlbiBjZWxsIHZhbHVlcy4gYHpvbmFsYCBjb21wdXRlcyB0aGUgc2l6ZSBvZiBlYWNoIGdyaWQgY2VsbCAoZm9yIHVucHJvamVjdGVkIHJhc3RlcnMpLCB0aGlzIG1heSBiZSB1c2VmdWwgdG8sIGUuZy4gY29tcHV0ZSB0aGUgYXJlYSBjb3ZlcmVkIGJ5IGEgY2VydGFpbiBjbGFzcyBvbiBhIGxvbmdpdHVkZS9sYXRpdHVkZSByYXN0ZXIuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KciA8LSByYXN0KG5yb3c9NDUsIG5jb2w9OTApDQp2YWx1ZXMocikgPC0gcm91bmQocnVuaWYobmNlbGwocikpKjMpDQphIDwtIGNlbGxTaXplKHIpDQp6b25hbChhLCByLCAic3VtIikNCmBgYA0KDQojIyMgUHJlZGljdGlvbnMNCg0KVGhlIGB0ZXJyYWAgcGFja2FnZSBoYXMgdHdvIGZ1bmN0aW9ucyB0byBtYWtlIG1vZGVsIHByZWRpY3Rpb25zIHRvIChwb3RlbnRpYWxseSB2ZXJ5IGxhcmdlKSByYXN0ZXJzLiBwcmVkaWN0IHRha2VzIGEgbXVsdGlsYXllciByYXN0ZXIgYW5kIGEgZml0dGVkIG1vZGVsIGFzIGFyZ3VtZW50cy4gRml0dGVkIG1vZGVscyBjYW4gYmUgb2YgdmFyaW91cyBjbGFzc2VzLCBpbmNsdWRpbmcgZ2xtLCBnYW0sIGFuZCBSYW5kb21Gb3Jlc3QuIFRoZSBmdW5jdGlvbiBgaW50ZXJwb2xhdGVgIGlzIHNpbWlsYXIgYnV0IGlzIGZvciBtb2RlbHMgdGhhdCB1c2UgY29vcmRpbmF0ZXMgYXMgcHJlZGljdG9yIHZhcmlhYmxlcywgZm9yIGV4YW1wbGUgaW4gS3JpZ2luZyBhbmQgc3BsaW5lIGludGVycG9sYXRpb24uDQoNCiMjIyBWZWN0b3IgdG8gcmFzdGVyIGNvbnZlcnNpb24NCg0KVGhlIGB0ZXJyYWAgcGFja2FnZSBzdXBwb3J0cyBwb2ludCwgbGluZSwgYW5kIHBvbHlnb24gdG8gcmFzdGVyIGNvbnZlcnNpb24gd2l0aCB0aGUgYHJhc3Rlcml6ZWAgZnVuY3Rpb24uIEZvciB2ZWN0b3IgdHlwZSBkYXRhIChwb2ludHMsIGxpbmVzLCBwb2x5Z29ucyksIGBTcGF0VmVjdG9yYCBvYmplY3RzIGFyZSB1c2VkOyBidXQgcG9pbnRzIGNhbiBhbHNvIGJlIHJlcHJlc2VudGVkIGJ5IGEgdHdvLWNvbHVtbiBtYXRyaXggKHggYW5kIHkpLg0KDQpQb2ludCB0byByYXN0ZXIgY29udmVyc2lvbiBpcyBvZnRlbiBkb25lIHdpdGggdGhlIHB1cnBvc2UgdG8gYW5hbHl6ZSB0aGUgcG9pbnQgZGF0YS4gRm9yIGV4YW1wbGUgdG8gY291bnQgdGhlIG51bWJlciBvZiBkaXN0aW5jdCBzcGVjaWVzIChyZXByZXNlbnRlZCBieSBwb2ludCBvYnNlcnZhdGlvbnMpIHRoYXQgb2NjdXIgaW4gZWFjaCByYXN0ZXIgY2VsbC4gYHJhc3Rlcml6ZWAgdGFrZXMgYSBgU3BhdFJhc3RlcmAgb2JqZWN0IHRvIHNldCB0aGUgc3BhdGlhbCBleHRlbnQgYW5kIHJlc29sdXRpb24sIGFuZCBhIGZ1bmN0aW9uIHRvIGRldGVybWluZSBob3cgdG8gc3VtbWFyaXplIHRoZSBwb2ludHMgKG9yIGFuIGF0dHJpYnV0ZSBvZiBlYWNoIHBvaW50KSBieSBjZWxsLg0KDQpQb2x5Z29uIHRvIHJhc3RlciBjb252ZXJzaW9uIGlzIHR5cGljYWxseSBkb25lIHRvIGNyZWF0ZSBhIGBTcGF0UmFzdGVyYCB0aGF0IGNhbiBhY3QgYXMgYSBtYXNrLCBpLmUuIHRvIHNldCB0byBgTkFgIGEgc2V0IG9mIGNlbGxzIG9mIGEgYFNwYXRSYXN0ZXJgIG9iamVjdCwgb3IgdG8gc3VtbWFyaXplIHZhbHVlcyBvbiBhIHJhc3RlciBieSB6b25lLiBGb3IgZXhhbXBsZSBhIGNvdW50cnkgcG9seWdvbiBpcyB0cmFuc2ZlcnJlZCB0byBhIHJhc3RlciB0aGF0IGlzIHRoZW4gdXNlZCB0byBzZXQgYWxsIHRoZSBjZWxscyBvdXRzaWRlIHRoYXQgY291bnRyeSB0byBgTkFgOyB3aGVyZWFzIHBvbHlnb25zIHJlcHJlc2VudGluZyBhZG1pbmlzdHJhdGl2ZSByZWdpb25zIHN1Y2ggYXMgc3RhdGVzIGNhbiBiZSB0cmFuc2ZlcnJlZCB0byBhIHJhc3RlciB0byBzdW1tYXJpemUgcmFzdGVyIHZhbHVlcyBieSByZWdpb24uDQoNCkl0IGlzIGFsc28gcG9zc2libGUgdG8gY29udmVydCB0aGUgdmFsdWVzIG9mIGEgYFNwYXRSYXN0ZXJgIHRvIHBvaW50cyBvciBwb2x5Z29ucywgdXNpbmcgYGFzLnBvaW50c2AgYW5kIGBhcy5wb2x5Z29uc2AuIEJvdGggZnVuY3Rpb25zIG9ubHkgcmV0dXJuIHZhbHVlcyBmb3IgY2VsbHMgdGhhdCBhcmUgbm90IE5BLg0KDQojIyBTdW1tYXJpemluZyBmdW5jdGlvbnMgKGV4dHJhKQ0KDQpXaGVuIHVzZWQgd2l0aCBhIGBTcGF0UmFzdGVyYCBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnQsIG5vcm1hbCBzdW1tYXJ5IHN0YXRpc3RpY3MgZnVuY3Rpb25zIHN1Y2ggYXMgYG1pbmAsIGBtYXhgIGFuZCBgbWVhbmAgcmV0dXJuIGEgYFNwYXRSYXN0ZXJgLiBZb3UgY2FuIHVzZSBgZ2xvYmFsYCBpZiwgaW5zdGVhZCwgeW91IHdhbnQgdG8gb2J0YWluIGEgc3VtbWFyeSBmb3IgYWxsIGNlbGxzIG9mIGEgc2luZ2xlIGBTcGF0UmFzdGVyYCBvYmplY3QuIFlvdSBjYW4gdXNlIGBmcmVxYCB0byBtYWtlIGEgZnJlcXVlbmN5IHRhYmxlLCBvciB0byBjb3VudCB0aGUgbnVtYmVyIG9mIGNlbGxzIHdpdGggYSBzcGVjaWZpZWQgdmFsdWUuIFVzZSBgem9uYWxgIHRvIHN1bW1hcml6ZSBhIFNwYXRSYXN0ZXIgb2JqZWN0IHVzaW5nIHpvbmVzIChhcmVhcyB3aXRoIHRoZSBzYW1lIGludGVnZXIgbnVtYmVyKSBkZWZpbmVkIGluIGEgYFNwYXRSYXN0ZXJgIGFuZCBgY3Jvc3N0YWJgIHRvIGNyb3NzLXRhYnVsYXRlIHR3byBgU3BhdFJhc3RlcmAgb2JqZWN0cy4NCg0KYGBge3IsICBldmFsPVR9DQpyIDwtIHJhc3QobmNvbD0zNiwgbnJvdz0xOCkNCnZhbHVlcyhyKSA8LSBydW5pZihuY2VsbChyKSkNCmdsb2JhbChyLCBtZWFuKQ0KYGBgDQoNCg0KWm9uYWwgc3RhdHMsIGJlbG93IGByYCBoYXMgdGhlIGNlbGxzIHdlIHdhbnQgdG8gc3VtbWFyaXplLCBgc2AgZGVmaW5lcyB0aGUgem9uZXMsIGFuZCB0aGUgbGFzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdG8gc3VtbWFyaXplIHRoZSB2YWx1ZXMgb2YgYHJgIGZvciBlYWNoIHpvbmUgaW4gYHNgLg0KDQpgYGB7ciwgIGV2YWw9VH0NCnMgPC0gcg0KdmFsdWVzKHMpIDwtIHJvdW5kKHJ1bmlmKG5jZWxsKHIpKSAqIDUpDQp6b25hbChyLCBzLCAnbWVhbicpDQpgYGANCg0KQ291bnQgY2VsbHMNCg0KYGBge3IsICBldmFsPVR9DQpmcmVxKHMpDQpmcmVxKHMsIHZhbHVlPTMpDQpgYGANCg0KQ3Jvc3MtdGFidWxhdGUNCg0KYGBge3IsICBldmFsPVR9DQpjdGIgPC0gY3Jvc3N0YWIoYyhyKjMsIHMpKQ0KaGVhZChjdGIpDQpgYGANCg0KIyMgSGVscGVyIGZ1bmN0aW9ucw0KDQpUaGUgY2VsbCBudW1iZXIgaXMgYW4gaW1wb3J0YW50IGNvbmNlcHQgaW4gdGhlIHRlcnJhIHBhY2thZ2UuIFJhc3RlciBkYXRhIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGEgbWF0cml4LCBidXQgaW4gYSBgU3BhdFJhc3RlcmAgaXQgaXMgbW9yZSBjb21tb25seSB0cmVhdGVkIGFzIGEgdmVjdG9yLiBDZWxscyBhcmUgbnVtYmVyZWQgZnJvbSB0aGUgdXBwZXIgbGVmdCBjZWxsIHRvIHRoZSB1cHBlciByaWdodCBjZWxsIGFuZCB0aGVuIGNvbnRpbnVpbmcgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgbmV4dCByb3csIGFuZCBzbyBvbiB1bnRpbCB0aGUgbGFzdCBjZWxsIGF0IHRoZSBsb3dlciByaWdodCBzaWRlIG9mIHRoZSByYXN0ZXIuIFRoZXJlIGFyZSBzZXZlcmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIHRoZSBjb2x1bW4gb3Igcm93IG51bWJlciBmcm9tIGEgY2VsbCBhbmQgdmljZSB2ZXJzYSwgYW5kIHRvIGRldGVybWluZSB0aGUgY2VsbCBudW1iZXIgZm9yIHgsIHkgY29vcmRpbmF0ZXMgYW5kIHZpY2UgdmVyc2EuDQoNCg0KYGBge3IsICBldmFsPVR9DQpyIDwtIHJhc3QobmNvbD0zNiwgbnJvdz0xOCkNCm5jb2wocikNCm5yb3cocikNCm5jZWxsKHIpDQpyb3dGcm9tQ2VsbChyLCAxMDApDQpjb2xGcm9tQ2VsbChyLCAxMDApDQpjZWxsRnJvbVJvd0NvbChyLDUsNSkNCnh5RnJvbUNlbGwociwgMTAwKQ0KY2VsbEZyb21YWShyLCBjYmluZCgwLDApKQ0KY29sRnJvbVgociwgMCkNCnJvd0Zyb21ZKHIsIDApDQpgYGANCg0KIyMgQWNjZXNzaW5nIGNlbGwgdmFsdWVzDQoNCkNlbGwgdmFsdWVzIGNhbiBiZSBhY2Nlc3NlZCB3aXRoIHNldmVyYWwgbWV0aG9kcy4gVXNlIGB2YWx1ZXNgIHRvIGdldCBhbGwgdmFsdWVzIG9yIGEgc3Vic2V0IHN1Y2ggYXMgYSBzaW5nbGUgcm93IG9yIGEgYmxvY2sgKHJlY3RhbmdsZSkgb2YgY2VsbCB2YWx1ZXMuDQoNCg0KYGBge3IsICBldmFsPVR9DQpyIDwtIHJhc3Qoc3lzdGVtLmZpbGUoImV4L2VsZXYudGlmIiwgcGFja2FnZT0idGVycmEiKSkNCnYgPC0gdmFsdWVzKHIpDQp2WzMwNzU6MzA4MCwgXQ0KdmFsdWVzKHIsIHJvdz0zMywgbnJvdz0xLCBjb2w9MzUsIG5jb2w9NikNCmBgYA0KDQpZb3UgY2FuIGFsc28gcmVhZCB2YWx1ZXMgdXNpbmcgY2VsbCBudW1iZXJzIG9yIGNvb3JkaW5hdGVzICh4eSkgdXNpbmcgdGhlIGBleHRyYWN0YCBtZXRob2QuDQoNCmBgYHtyLCAgZXZhbD1UfQ0KY2VsbHMgPC0gY2VsbEZyb21Sb3dDb2wociwgMzMsIDM1OjQwKQ0KY2VsbHMNCnJbY2VsbHNdDQp4eSA8LSB4eUZyb21DZWxsKHIsIGNlbGxzKQ0KeHkNCmV4dHJhY3QociwgeHkpDQpgYGANCg0KWW91IGNhbiBhbHNvIGV4dHJhY3QgdmFsdWVzIHVzaW5nIGBTcGF0VmVjdG9yYCBvYmplY3RzLiBUaGUgZGVmYXVsdCBhcHByb2FjaCBmb3IgZXh0cmFjdGluZyByYXN0ZXIgdmFsdWVzIHdpdGggcG9seWdvbnMgaXMgdGhhdCBhIHBvbHlnb24gaGFzIHRvIGNvdmVyIHRoZSBjZW50ZXIgb2YgYSBjZWxsLCBmb3IgdGhlIGNlbGwgdG8gYmUgaW5jbHVkZWQuIEhvd2V2ZXIsIHlvdSBjYW4gdXNlIGFyZ3VtZW50IGB3ZWlnaHRzPVRSVUVgIGluIHdoaWNoIGNhc2UgeW91IGdldCwgYXBhcnQgZnJvbSB0aGUgY2VsbCB2YWx1ZXMsIHRoZSBwZXJjZW50YWdlIG9mIGVhY2ggY2VsbCB0aGF0IGlzIGNvdmVyZWQgYnkgdGhlIHBvbHlnb24sIHNvIHRoYXQgeW91IGNhbiBhcHBseSwgZS5nLiwgYSDigJw1MCUgYXJlYSBjb3ZlcmVk4oCdIHRocmVzaG9sZCwgb3IgY29tcHV0ZSBhbiBhcmVhLXdlaWdodGVkIGF2ZXJhZ2UuDQoNCkluIHRoZSBjYXNlIG9mIGxpbmVzLCBhbnkgY2VsbCB0aGF0IGlzIGNyb3NzZWQgYnkgYSBsaW5lIGlzIGluY2x1ZGVkLiBGb3IgbGluZXMgYW5kIHBvaW50cywgYSBjZWxsIHRoYXQgaXMgb25seSDigJh0b3VjaGVk4oCZIGlzIGluY2x1ZGVkIHdoZW4gaXQgaXMgYmVsb3cgb3IgdG8gdGhlIHJpZ2h0IChvciBib3RoKSBvZiB0aGUgbGluZSBzZWdtZW50L3BvaW50IChleGNlcHQgZm9yIHRoZSBib3R0b20gcm93IGFuZCByaWdodC1tb3N0IGNvbHVtbikuDQoNCkluIGFkZGl0aW9uLCB5b3UgY2FuIHVzZSBzdGFuZGFyZCBSIGluZGV4aW5nIHRvIGFjY2VzcyB2YWx1ZXMsIG9yIHRvIHJlcGxhY2UgdmFsdWVzIChhc3NpZ24gbmV3IHZhbHVlcyB0byBjZWxscykgaW4gYSBgU3BhdFJhc3RlcmAgb2JqZWN0LiBJZiB5b3UgcmVwbGFjZSBhIHZhbHVlIGluIGEgYFNwYXRSYXN0ZXJgIG9iamVjdCBiYXNlZCBvbiBhIGZpbGUsIHRoZSBjb25uZWN0aW9uIHRvIHRoYXQgZmlsZSBpcyBsb3N0IChiZWNhdXNlIGl0IG5vdyBpcyBkaWZmZXJlbnQgZnJvbSB0aGF0IGZpbGUpLiBTZXR0aW5nIHJhc3RlciB2YWx1ZXMgZm9yIHZlcnkgbGFyZ2UgZmlsZXMgd2lsbCBiZSB2ZXJ5IHNsb3cgd2l0aCB0aGlzIGFwcHJvYWNoIGFzIGVhY2ggdGltZSBhIG5ldyAodGVtcG9yYXJ5KSBmaWxlLCB3aXRoIGFsbCB0aGUgdmFsdWVzLCBpcyB3cml0dGVuIHRvIGRpc2suIElmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSB2YWx1ZXMgaW4gYW4gZXhpc3RpbmcgZmlsZSwgeW91IGNhbiB1c2UgYHVwZGF0ZWAgKHdpdGggY2F1dGlvbiEpDQoNCmBgYHtyLCAgZXZhbD1UfQ0KcltjZWxsc10NCnJbMTo0XQ0Kc291cmNlcyhyKQ0KclsyOjVdIDwtIDEwDQpyWzE6NF0NCnNvdXJjZXMocikNCmBgYA0KDQoNCk5vdGUgdGhhdCBpbiB0aGUgYWJvdmUgZXhhbXBsZXMgdmFsdWVzIGFyZSByZXRyaWV2ZWQgdXNpbmcgY2VsbCBudW1iZXJzLiBUaGF0IGlzLCBhIHJhc3RlciBpcyByZXByZXNlbnRlZCBhcyBhIChvbmUtZGltZW5zaW9uYWwpIHZlY3Rvci4gVmFsdWVzIGNhbiBhbHNvIGJlIGluc3BlY3RlZCB1c2luZyBhICh0d28tZGltZW5zaW9uYWwpIG1hdHJpeCBub3RhdGlvbi4gQXMgZm9yIFIgbWF0cmljZXMsIHRoZSBmaXJzdCBpbmRleCByZXByZXNlbnRzIHRoZSByb3cgbnVtYmVyLCB0aGUgc2Vjb25kIHRoZSBjb2x1bW4gbnVtYmVyLg0KDQoNCmBgYHtyLCAgZXZhbD1UfQ0KclsxOjNdDQpyWzEsMTozXQ0KclsxLCAxOjVdDQpyWzE6NSwgMl0NCnJbMTozLDE6M10NCiMgZ2V0IGEgdmVjdG9yIGluc3RlYWQgb2YgYSBhIG1hdHJpeA0KclsxOjMsIDE6MywgZHJvcD1UUlVFXQ0KIyBvciBhIHJhc3RlciBsaWtlIG1hdHJpeA0KYXMubWF0cml4KHIsIHdpZGU9VFJVRSlbMTozLCAxOjRdDQpgYGANCg0KQWNjZXNzaW5nIHZhbHVlcyB0aHJvdWdoIHRoaXMgdHlwZSBvZiBpbmRleGluZyBzaG91bGQgYmUgYXZvaWRlZCBpbnNpZGUgZnVuY3Rpb25zIGFzIGl0IGlzIGxlc3MgZWZmaWNpZW50IHRoYW4gYWNjZXNzaW5nIHZhbHVlcyB2aWEgZnVuY3Rpb25zIGxpa2UgYGdldFZhbHVlc2AuDQoNCiMjIENvZXJjaW9uIHRvIG90aGVyIGNsYXNzZXMNCg0KWW91IGNhbiBjb252ZXJ0IGBTcGF0UmFzdGVyYCBvYmplY3RzIHRvIGBSYXN0ZXIqYCBvYmplY3RzIGRlZmluZWQgaW4gdGhlIHJhc3RlciBwYWNrYWdlLg0KDQpgYGB7ciwgIGV2YWw9VH0NCnIgPC0gcmFzdChuY29sPTM2LCBucm93PTE4KQ0KdmFsdWVzKHIpIDwtIHJ1bmlmKG5jZWxsKHIpKQ0KbGlicmFyeShyYXN0ZXIpDQojIyBMb2FkaW5nIHJlcXVpcmVkIHBhY2thZ2U6IHNwDQp4IDwtIHJhc3RlcihyKQ0KYGBgDQo=" download="maps.Rmd">Download maps.Rmd</a>
<a href="data:text/plain;base64,eGFyaW5nYW5FeHRyYTo6dXNlX2NsaXBib2FyZCgpDQoNCm5hbWUgPC0gTEVUVEVSU1sxOjEwXQ0KbG9uZ2l0dWRlIDwtIGMoLTExNi43LCAtMTIwLjQsIC0xMTYuNywgLTExMy41LCAtMTE1LjUsDQogICAgICAgICAgICAgICAtMTIwLjgsIC0xMTkuNSwgLTExMy43LCAtMTEzLjcsIC0xMTAuNykNCmxhdGl0dWRlIDwtIGMoNDUuMywgNDIuNiwgMzguOSwgNDIuMSwgMzUuNywgMzguOSwNCiAgICAgICAgICAgICAgMzYuMiwgMzksIDQxLjYsIDM2LjkpDQpzdGF0aW9ucyA8LSBjYmluZChsb25naXR1ZGUsIGxhdGl0dWRlKQ0KIyBTaW11bGF0ZWQgcmFpbmZhbGwgZGF0YQ0Kc2V0LnNlZWQoMCkNCnByZWNpcCA8LSByb3VuZCgocnVuaWYobGVuZ3RoKGxhdGl0dWRlKSkqMTApXjMpDQoNCnBzaXplIDwtIDEgKyBwcmVjaXAvNTAwDQpwbG90KHN0YXRpb25zLCBjZXg9cHNpemUsIHBjaD0yMCwgY29sPSdyZWQnLCBtYWluPSdQcmVjaXBpdGF0aW9uJykNCiMgYWRkIG5hbWVzIHRvIHBsb3QNCnRleHQoc3RhdGlvbnMsIG5hbWUsIHBvcz00KQ0KIyBhZGQgYSBsZWdlbmQNCmJyZWFrcyA8LSBjKDEwMCwgMjUwLCA1MDAsIDEwMDApDQpsZWdlbmQucHNpemUgPC0gMSticmVha3MvNTAwDQpsZWdlbmQoInRvcHJpZ2h0IiwgbGVnZW5kPWJyZWFrcywgcGNoPTIwLCBwdC5jZXg9bGVnZW5kLnBzaXplLCBjb2w9J3JlZCcsIGJnPSdncmF5JykNCg0KbG9uIDwtIGMoLTExNi44LCAtMTE0LjIsIC0xMTIuOSwgLTExMS45LCAtMTE0LjIsIC0xMTUuNCwgLTExNy43KQ0KbGF0IDwtIGMoNDEuMywgNDIuOSwgNDIuNCwgMzkuOCwgMzcuNiwgMzguMywgMzcuNikNCnggPC0gY2JpbmQobG9uLCBsYXQpDQpwbG90KHN0YXRpb25zLCBtYWluPSdQcmVjaXBpdGF0aW9uJykNCnBvbHlnb24oeCwgY29sPSdibHVlJywgYm9yZGVyPSdsaWdodCBibHVlJykNCmxpbmVzKHN0YXRpb25zLCBsd2Q9MywgY29sPSdyZWQnKQ0KcG9pbnRzKHgsIGNleD0yLCBwY2g9MjApDQpwb2ludHMoc3RhdGlvbnMsIGNleD1wc2l6ZSwgcGNoPTIwLCBjb2w9J3JlZCcsIG1haW49J1ByZWNpcGl0YXRpb24nKQ0KDQp3c3QgPC0gZGF0YS5mcmFtZShsb25naXR1ZGUsIGxhdGl0dWRlLCBuYW1lLCBwcmVjaXApDQp3c3QNCg0KIyMgbGlicmFyeSAoZ2VvZGF0YSkNCiMjICNUV04gPC0gZ2FkbShjb3VudHJ5PSJUV04iLCBsZXZlbD0xLCBwYXRoPXRlbXBkaXIoKSkNCiMjICNUV04gPC0gZ2FkbShjb3VudHJ5PSJUV04iLCBsZXZlbD0xLCBwYXRoPSIuL2RhdGEiDQojIyBUV04gPC0gdmVjdCgnZGF0YS9nYWRtL2dhZG00MV9UV05fMV9way5yZHMnKQ0KIyMgVFdODQojIyAjIGNoZWNrIGZvciA/Z2FkbQ0KDQojIGV4YW1wbGUgdXNpbmcgLnNocCBmaWxlDQpsaWJyYXJ5KHRlcnJhKQ0KZmlsZW5hbWUxIDwtIHN5c3RlbS5maWxlKCJleC9sdXguc2hwIiwgcGFja2FnZT0idGVycmEiKQ0KYmFzZW5hbWUoZmlsZW5hbWUxKQ0KDQojIGV4YW1wbGUgdXNpbmcgLnNocCBmaWxlDQpzMSA8LSB2ZWN0KGZpbGVuYW1lMSkNCnMxDQoNClRXTiA8LSB2ZWN0KCdkYXRhL2dhZG0vZ2FkbTQxX1RXTl8xX3BrLnJkcycpDQpvdXRmaWxlMSA8LSAiZGF0YS9zaHBfVFdOLnNocCINCndyaXRlVmVjdG9yKFRXTiwgb3V0ZmlsZTEsIG92ZXJ3cml0ZT1UUlVFKQ0KDQpsaWJyYXJ5KGdlb2RhdGEpDQplbGUgPC1lbGV2YXRpb25fMzBzKCJUV04iLCBwYXRoPXRlbXBkaXIoKSkNCmVsZQ0KDQpmIDwtIHN5c3RlbS5maWxlKCJleC9sb2dvLnRpZiIsIHBhY2thZ2U9InRlcnJhIikNCmJhc2VuYW1lKGYpDQoNCnIgPC0gcmFzdChmKQ0Kcg0KDQpyMiA8LSByW1syXV0NCnIyDQoNCnggPC0gd3JpdGVSYXN0ZXIoZWxlLCAiZGF0YS9lbGUudGlmIiwgb3ZlcndyaXRlPVRSVUUpDQp4DQoNCnMxDQoNCmNycyhzMSkNCg0Kc3MgPC0gczENCmNycyhzcykgPC0gIiINCmNycyhzcykNCmNycyhzcykgPC0gIitwcm9qPWxvbmdsYXQgK2RhdHVtPVdHUzg0Ig0KY3JzKHNzKQ0KDQpuZXdjcnMgPC0gIitwcm9qPXJvYmluICtkYXR1bT1XR1M4NCINCg0Kcm9iIDwtIHRlcnJhOjpwcm9qZWN0KHMxLCBuZXdjcnMpDQpyb2INCg0KcDIgPC0gdGVycmE6OnByb2plY3Qocm9iLCAiK3Byb2o9bG9uZ2xhdCArZGF0dW09V0dTODQiKQ0KDQpyIDwtIHJhc3QoeG1pbj0tMTEwLCB4bWF4PS05MCwgeW1pbj00MCwgeW1heD02MCwgbmNvbHM9NDAsIG5yb3dzPTQwKQ0KdmFsdWVzKHIpIDwtIDE6bmNlbGwocikNCnINCnBsb3QgKHIpDQoNCm5ld2Nycw0KcHIxIDwtIHRlcnJhOjpwcm9qZWN0KHIsIG5ld2NycykNCmNycyhwcjEpDQpwbG90KHByMSkNCg0KeCA8LSByYXN0KHByMSkNCiMgU2V0IHRoZSBjZWxsIHNpemUNCnJlcyh4KSA8LSAyMDAwMDANCg0KcHIzIDwtIHRlcnJhOjpwcm9qZWN0KHIsIHgpDQpwcjMNCnBsb3QocHIzKQ0KDQpUV04gPC0gdmVjdCgnZGF0YS9nYWRtL2dhZG00MV9UV05fMV9way5yZHMnKQ0KcGxvdChUV04sICJOQU1FXzEiKQ0KDQojIyB1cmwgPC0gJ2h0dHBzOi8vZGF0YS5tb2kuZ292LnR3L01vaU9EL1N5c3RlbS9Eb3dubG9hZEZpbGUuYXNweD9EQVRBPTcyODc0QzU1LTg4NEQtNENFQS1CN0Q2LUY2MEIwQkU4NUFCMCcNCiMjIHBhdGgxIDwtIHRlbXBmaWxlKGZpbGVleHQgPSAiLnppcCIpDQojIyBpZiAoZmlsZS5leGlzdHMocGF0aDEpKSAgJ2ZpbGUgYWxyZWR5IGV4aXN0cycgZWxzZSBkb3dubG9hZC5maWxlKHVybCwgcGF0aDEsIG1vZGU9IndiIikNCiMjIHppcDo6dW56aXAoemlwZmlsZSA9IHBhdGgxLGV4ZGlyID0gJ2RhdGEnKQ0KDQpUYWl3YW4gPC0gImRhdGEvQ09VTlRZX01PSV8xMTMwNzE4LnNocCINClRhaXdhbiA8LXZlY3QoVGFpd2FuKQ0KDQpwbG90KFRhaXdhbiwgIkNPVU5UWUVORyIpDQoNCmQgPC0gYXMuZGF0YS5mcmFtZShUYWl3YW4pDQojIGhlYWQoZCkgIyBub3QgcnVuIGZvciBDaGluZXNlIGNoYXJhY3Rlcg0KDQpnIDwtIGdlb20oVGFpd2FuKSANCmhlYWQoZykNCg0KZyA8LSBnZW9tKFRhaXdhbiwgd2t0PVRSVUUpDQpzdWJzdHIoZywgMSwgNTApDQoNClRhaXdhbiRDT1VOVFlFTkcNCg0KVGFpd2FuWywiQ09VTlRZRU5HIl0NCg0Kc2V0LnNlZWQoMCkNClRhaXdhbiRsZXRzIDwtIHNhbXBsZShsZXR0ZXJzLCBucm93KFRhaXdhbikpDQojIFRhaXdhbg0KDQpUYWl3YW4kbGV0cyA8LSBzYW1wbGUoTEVUVEVSUywgbnJvdyhUYWl3YW4pKQ0KIyBoZWFkKFRhaXdhbikNCg0KVGFpd2FuJGxldHMgPC0gTlVMTA0KDQpkZnIgPC0gZGF0YS5mcmFtZShDb3VudHk9VGFpd2FuJENPVU5UWUVORywgVmFsdWU9cm91bmQocnVuaWYobGVuZ3RoKFRhaXdhbiksIDEwMCwgMTAwMCkpKQ0KZGZyIDwtIGRmcltvcmRlcihkZnIkQ291bnR5KSwgXQ0KcG0gPC0gbWVyZ2UoVGFpd2FuLCBkZnIsIGJ5Lng9IkNPVU5UWUVORyIsYnkueT0iQ291bnR5IikNCiMgcG0gDQojIGhlYWQocG0pDQoNCmkgPC0gd2hpY2goVGFpd2FuJENPVU5UWUVORyA9PSAnVGFpcGVpIENpdHknKQ0KZyA8LSBUYWl3YW5baSxdDQojIGcNCg0KeiA8LSByYXN0KFRhaXdhbikNCmRpbSh6KSA8LSBjKDIsMikNCnZhbHVlcyh6KSA8LSAxOjQNCm5hbWVzKHopIDwtICdab25lJw0KeiA8LSBhcy5wb2x5Z29ucyh6KQ0Keg0KejEgPC0gelsxLF0NCnoyIDwtIHpbMixdDQp6MyA8LSB6WzMsXQ0KejQgPC0gels0LF0NCnBsb3QoVGFpd2FuKQ0KcGxvdCh6LCBhZGQ9VFJVRSwgYm9yZGVyPSdibHVlJywgbHdkPTUpDQpwbG90KHoyLCBhZGQ9VFJVRSwgYm9yZGVyPSdyZWQnLCBsd2Q9MiwgY29sPSdyZWQnKQ0KDQpiIDwtIHJiaW5kKFRhaXdhbiwgeikNCiMgaGVhZChiKQ0KIyB0YWlsKGIpDQoNClRhaXdhbiRyZWdpb248LWMocmVwKCJPdGhlcnMiLDYpLCByZXAoIk5vcnRoIiwzKSwgcmVwKCJPdGhlcnMiLDIpLCAiTm9ydGgiLCByZXAoIk90aGVycyIsMTApKQ0KcGEgPC0gYWdncmVnYXRlKFRhaXdhbiwgYnk9J3JlZ2lvbicpDQp6YSA8LSBhZ2dyZWdhdGUoeikNCnBsb3QoemEsIGNvbD0nbGlnaHQgZ3JheScsIGJvcmRlcj0nbGlnaHQgZ3JheScsIGx3ZD01KQ0KcGxvdChwYSwgYWRkPVRSVUUsIGNvbD1yYWluYm93KDMpLCBsd2Q9MywgYm9yZGVyPSd3aGl0ZScpDQoNClRhaXdhbiRyZWdpb248LWMocmVwKCJPdGhlcnMiLDYpLCByZXAoIk5vcnRoIiwzKSwgcmVwKCJPdGhlcnMiLDIpLCAiTm9ydGgiLCByZXAoIk90aGVycyIsMTApKQ0KcGEgPC0gYWdncmVnYXRlKFRhaXdhbiwgYnk9J3JlZ2lvbicsZGlzc29sdmU9RkFMU0UpDQp6YSA8LSBhZ2dyZWdhdGUoeiwgZGlzc29sdmUgPSBGQUxTRSkNCnBsb3QoemEsIGNvbD0nbGlnaHQgZ3JheScsIGJvcmRlcj0nZGFyayBncmF5JywgbHdkPTMpDQpwbG90KHBhLCBhZGQ9VFJVRSwgY29sPXJhaW5ib3coMyksIGx3ZD0yLCBib3JkZXI9J3doaXRlJykNCg0KemQgPC0gZGlzYWdnKHBhKQ0KemQNCg0KZTEgPC0gZXJhc2UoVGFpd2FuLHoxICkNCmUyIDwtIGVyYXNlKGUxLHozICkNCmUzIDwtIGVyYXNlKGUyLHo0ICkNCnBsb3QoZTMpDQoNCmkgPC0gdGVycmE6OmludGVyc2VjdChUYWl3YW4sIHozKQ0KcGxvdChpKQ0KDQplIDwtIGV4dCgxMTksIDEyMywgMjEsIDI2KQ0KdGUgPC0gY3JvcChUYWl3YW4sIGUpDQpwbG90KFRhaXdhbikNCnBsb3QoZSwgYWRkPVRSVUUsIGx3ZD0zLCBjb2w9InJlZCIpDQpwbG90KHRlLCBjb2w9J2xpZ2h0IGJsdWUnLCBhZGQ9VFJVRSkNCnBsb3QoZSwgYWRkPVRSVUUsIGx3ZD0zLCBib3JkZXI9ImJsdWUiKQ0KDQp1IDwtIHRlcnJhOjp1bmlvbihUYWl3YW4sIHopDQp1DQoNCnNldC5zZWVkKDUpDQpwbG90KHUsIGNvbD1zYW1wbGUocmFpbmJvdyhsZW5ndGgodSkpKSkNCg0KY292IDwtIGNvdmVyKFRhaXdhbiwgeltjKDEsMyksXSkNCnBsb3QoY292KQ0KDQpkaWYgPC0gc3ltZGlmKHosVGFpd2FuKQ0KcGxvdChkaWYsIGNvbD1yYWluYm93KGxlbmd0aChkaWYpKSkNCg0KcHRzIDwtIG1hdHJpeChjKDExNywgMTIyLCAxMTcsIDEyMiwgMTUsIDE1LCAyMywgMjMpLCBuY29sPTIpDQpzcHRzIDwtIHZlY3QocHRzLCBjcnM9Y3JzKFRhaXdhbikpDQpwbG90KHosIGNvbD0nbGlnaHQgYmx1ZScsIGx3ZD0yKQ0KcG9pbnRzKHNwdHMsIGNvbD0nbGlnaHQgZ3JheScsIHBjaD0yMCwgY2V4PTYpDQp0ZXh0KHNwdHMsIDE6bnJvdyhwdHMpLCBjb2w9J3JlZCcsIGZvbnQ9MiwgY2V4PTEuNSkNCmxpbmVzKFRhaXdhbiwgY29sPSdibHVlJywgbHdkPTIpDQoNCmV4dHJhY3Qoc3B0cywgVGFpd2FuKQ0KDQpsaWJyYXJ5ICh0ZXJyYSkNCng8LXJhc3QoKQ0KeA0KDQp4IDwtIHJhc3QobmNvbD0zNiwgbnJvdz0xOCwgeG1pbj0tMTAwMCwgeG1heD0xMDAwLCB5bWluPS0xMDAsIHltYXg9OTAwKQ0KDQpyZXMoeCkNCnJlcyh4KSA8LSAxMDANCnJlcyh4KQ0KDQpuY29sKHgpDQpuY29sKHgpIDwtIDE4DQpuY29sKHgpDQpyZXMoeCkNCg0KY3JzKHgpIDwtICIrcHJvaj11dG0gK3pvbmU9NDggK2RhdHVtPVdHUzg0Ig0KeA0KDQpyIDwtIHJhc3QobmNvbD0xMCwgbnJvdz0xMCkNCm5jZWxsKHIpDQpoYXNWYWx1ZXMocikgIyBjaGVjayBpZiBpbi1tZW1vcnkgbGF5ZXJzIGFjdHVhbGx5IGhhdmUgY2VsbCB2YWx1ZXMNCg0KdmFsdWVzKHIpIDwtIDE6bmNlbGwocikNCg0Kc2V0LnNlZWQoMCkNCnZhbHVlcyhyKSA8LSBydW5pZihuY2VsbChyKSkNCmhhc1ZhbHVlcyhyKQ0Kc291cmNlcyhyKSAjIEdldCB0aGUgZGF0YSBzb3VyY2VzIG9mIGEgU3BhdFJhc3RlcjogU291cmNlcyBhcmUgZWl0aGVyIGZpbGVzIChvciBzaW1pbGFyIHJlc291cmNlcykgb3IgIiIsIG1lYW5pbmcgdGhhdCB0aGV5IGFyZSBpbiBtZW1vcnkuIA0KdmFsdWVzKHIpWzE6MTBdDQpwbG90KHIsIG1haW49J1Jhc3RlciB3aXRoIDEwMCBjZWxscycpDQoNCmhhc1ZhbHVlcyhyKQ0KcmVzKHIpDQpkaW0ocikNCmV4dChyKQ0KDQp4bWF4KHIpIDwtIDANCmhhc1ZhbHVlcyhyKQ0KcmVzKHIpDQpkaW0ocikNCg0KbmNvbChyKSA8LSA2DQpoYXNWYWx1ZXMocikNCnJlcyhyKQ0KZGltKHIpDQp4bWF4KHIpDQoNCmZpbGVuYW1lIDwtIHN5c3RlbS5maWxlKCJleC9lbGV2LnRpZiIsIHBhY2thZ2U9InRlcnJhIikNCmJhc2VuYW1lKGZpbGVuYW1lKQ0KDQpyIDwtIHJhc3QoZmlsZW5hbWUpDQpzb3VyY2VzKHIpDQpoYXNWYWx1ZXMocikNCnBsb3QociwgbWFpbj0iU3BhdFJhc3RlciBmcm9tIGZpbGUiKQ0KDQp0YWkucG9wIDwtIHJhc3QoJy4vZGF0YS9wb3BtYXAxNWFkai50aWYnKQ0KcGFyKG1mcm93PWMoMSwyKSkNCiMgcGxvdCh0YWkucG9wLCBtYWluPSJUYWl3YW4gLSBQb3B1bGF0aW9uIERlbnNpdHkgKDIwMTUpIikNCiMgTmVlZCBhIGxvZyB0cmFuc2Zvcm1hdG9uDQpwbG90KGxvZyh0YWkucG9wKzEpLCBtYWluPSJUYWl3YW4gLSBsb2ctdHJhbnNmb3JtZWQgUG9wdWxhdGlvbiBEZW5zaXR5ICgyMDE1KSIpDQoNCmxpYnJhcnkoZ2VvZGF0YSkNCmxpYnJhcnkoZ2dwbG90MikNCmxpYnJhcnkoZ2dzcGF0aWFsKQ0KZWxlIDwtZWxldmF0aW9uXzMwcygiVFdOIiwgcGF0aD10ZW1wZGlyKCkpDQpnZ3Bsb3QoKSsNCiAgbGF5ZXJfc3BhdGlhbChlbGUpKw0KICBzY2FsZV9maWxsX2NvbnRpbnVvdXMobmEudmFsdWUgPSAndHJhbnNwYXJlbnQnLCBuYW1lPSdFbGV2YXRpb24gKG0pJykrDQogIGdnc3BhdGlhbDo6YW5ub3RhdGlvbl9ub3J0aF9hcnJvdygNCiAgICBsb2NhdGlvbiA9ICJ0bCIsIHdoaWNoX25vcnRoID0gInRydWUiLA0KICAgIHN0eWxlID0gZ2dzcGF0aWFsOjpub3J0aF9hcnJvd19uYXV0aWNhbChmaWxsID0gYygiZ3JleTQwIiwgIndoaXRlIiksIGxpbmVfY29sID0gImdyZXkyMCIpKSsNCiAgZ2dzcGF0aWFsOjphbm5vdGF0aW9uX3NjYWxlICgpICsNCiAgdGhlbWVfYncoKQ0KDQpyMSA8LSByMiA8LSByMyA8LSByYXN0KG5yb3c9MTAsIG5jb2w9MTApDQojIEFzc2lnbiByYW5kb20gY2VsbCB2YWx1ZXMNCnZhbHVlcyhyMSkgPC0gcnVuaWYobmNlbGwocjEpKQ0KdmFsdWVzKHIyKSA8LSBydW5pZihuY2VsbChyMikpDQp2YWx1ZXMocjMpIDwtIHJ1bmlmKG5jZWxsKHIzKSkNCg0KcyA8LSBjKHIxLCByMiwgcjMpDQpzDQpubHlyKHMpDQoNCmZpbGVuYW1lIDwtIHN5c3RlbS5maWxlKCJleC9sb2dvLnRpZiIsIHBhY2thZ2U9InRlcnJhIikNCmJhc2VuYW1lKGZpbGVuYW1lKQ0KYiA8LSByYXN0KGZpbGVuYW1lKQ0KYg0Kbmx5cihiKQ0KDQpyIDwtIGJbWzJdXQ0KDQpyIDwtIHJhc3QobmNvbD0xMCwgbnJvdz0xMCkNCnZhbHVlcyhyKSA8LSAxOm5jZWxsKHIpDQoNCnMgPC0gciArIDEwDQpzIDwtIHNxcnQocykNCnMgPC0gcyAqIHIgKyA1DQp2YWx1ZXMocikgPC0gcnVuaWYobmNlbGwocikpDQpyIDwtIHJvdW5kKHIpDQpyIDwtIHIgPT0gMQ0KDQojTm90IHlldCBpbXBsZW1lbnRlZA0Kc1tyXSA8LSAtMC41DQpzWyFyXSA8LSA1DQpzW3MgPT0gNV0gPC0gMTUNCg0KciA8LSByYXN0KG5jb2w9NSwgbnJvdz01KQ0KdmFsdWVzKHIpIDwtIDENCnMgPC0gYyhyLCByKzEpDQpxIDwtIGMociwgcisyLCByKzQsIHIrNikNCnggPC0gciArIHMgKyBxDQp4DQoNCmEgPC0gbWVhbihyLHMsMTApDQpiIDwtIHN1bShyLHMpDQpzdCA8LSBjKHIsIHMsIGEsIGIpDQpzc3QgPC0gc3VtKHN0KQ0Kc3N0DQoNCmdsb2JhbChzdCwgJ3N1bScpDQoNCnIgPC0gcmFzdCgpDQp2YWx1ZXMocikgPC0gMTpuY2VsbChyKQ0KcmEgPC0gYWdncmVnYXRlKHIsIDIwKQ0KcmQgPC0gZGlzYWdnKHJhLCAyMCkNCg0KcjEgPC0gY3JvcChyLCBleHQoLTUwLDAsMCwzMCkpDQpyMiA8LSBjcm9wKHIsIGV4dCgtMTAsNTAsLTIwLCAxMCkpDQptIDwtIG1lcmdlKHIxLCByMiwgZmlsZW5hbWU9InRlc3QudGlmIiwgb3ZlcndyaXRlPVRSVUUpDQpwbG90KG0pDQoNCnIgPC0gcmFzdChuY29sPTMsIG5yb3c9MikNCnZhbHVlcyhyKSA8LSAxOm5jZWxsKHIpDQp2YWx1ZXMocikNCg0KcyA8LSBhcHAociwgZnVuPWZ1bmN0aW9uKHgpeyB4W3ggPCA0XSA8LSBOQTsgcmV0dXJuKHgpfSApDQphcy5tYXRyaXgocykNCg0KcnMgPC0gYyhyLCBzKQ0KdyA8LSBsYXBwKHJzLCBmdW49ZnVuY3Rpb24oeCwgeSl7IHggLyAoMiAqIHNxcnQoeSkpICsgNSB9ICkNCmFzLm1hdHJpeCh3KQ0KDQp1IDwtIG1hc2sociwgdykNCmFzLm1hdHJpeCh1KQ0KDQp2IDwtIHU9PXMNCmFzLm1hdHJpeCh2KQ0KDQpjdnIgPC0gY292ZXIodywgcikNCmFzLm1hdHJpeCh3KQ0KDQp4IDwtIGNsYXNzaWZ5KHcsIHJiaW5kKGMoMCwyLDEpLCAgYygyLDUsMiksIGMoNCwxMCwzKSkpDQphcy5tYXRyaXgoeCkNCg0KeSA8LSBjbGFzc2lmeSh4LCBjYmluZChpZD1jKDIsMyksIHY9Yyg0MCw1MCkpKQ0KYXMubWF0cml4KHkpDQoNCnIgPC0gcmFzdChucm93PTQ1LCBuY29sPTkwKQ0KdmFsdWVzKHIpIDwtIHJvdW5kKHJ1bmlmKG5jZWxsKHIpKSozKQ0KYSA8LSBjZWxsU2l6ZShyKQ0Kem9uYWwoYSwgciwgInN1bSIpDQoNCnIgPC0gcmFzdChuY29sPTM2LCBucm93PTE4KQ0KdmFsdWVzKHIpIDwtIHJ1bmlmKG5jZWxsKHIpKQ0KZ2xvYmFsKHIsIG1lYW4pDQoNCnMgPC0gcg0KdmFsdWVzKHMpIDwtIHJvdW5kKHJ1bmlmKG5jZWxsKHIpKSAqIDUpDQp6b25hbChyLCBzLCAnbWVhbicpDQoNCmZyZXEocykNCmZyZXEocywgdmFsdWU9MykNCg0KY3RiIDwtIGNyb3NzdGFiKGMociozLCBzKSkNCmhlYWQoY3RiKQ0KDQpyIDwtIHJhc3QobmNvbD0zNiwgbnJvdz0xOCkNCm5jb2wocikNCm5yb3cocikNCm5jZWxsKHIpDQpyb3dGcm9tQ2VsbChyLCAxMDApDQpjb2xGcm9tQ2VsbChyLCAxMDApDQpjZWxsRnJvbVJvd0NvbChyLDUsNSkNCnh5RnJvbUNlbGwociwgMTAwKQ0KY2VsbEZyb21YWShyLCBjYmluZCgwLDApKQ0KY29sRnJvbVgociwgMCkNCnJvd0Zyb21ZKHIsIDApDQoNCnIgPC0gcmFzdChzeXN0ZW0uZmlsZSgiZXgvZWxldi50aWYiLCBwYWNrYWdlPSJ0ZXJyYSIpKQ0KdiA8LSB2YWx1ZXMocikNCnZbMzA3NTozMDgwLCBdDQp2YWx1ZXMociwgcm93PTMzLCBucm93PTEsIGNvbD0zNSwgbmNvbD02KQ0KDQpjZWxscyA8LSBjZWxsRnJvbVJvd0NvbChyLCAzMywgMzU6NDApDQpjZWxscw0KcltjZWxsc10NCnh5IDwtIHh5RnJvbUNlbGwociwgY2VsbHMpDQp4eQ0KZXh0cmFjdChyLCB4eSkNCg0KcltjZWxsc10NCnJbMTo0XQ0Kc291cmNlcyhyKQ0KclsyOjVdIDwtIDEwDQpyWzE6NF0NCnNvdXJjZXMocikNCg0KclsxOjNdDQpyWzEsMTozXQ0KclsxLCAxOjVdDQpyWzE6NSwgMl0NCnJbMTozLDE6M10NCiMgZ2V0IGEgdmVjdG9yIGluc3RlYWQgb2YgYSBhIG1hdHJpeA0KclsxOjMsIDE6MywgZHJvcD1UUlVFXQ0KIyBvciBhIHJhc3RlciBsaWtlIG1hdHJpeA0KYXMubWF0cml4KHIsIHdpZGU9VFJVRSlbMTozLCAxOjRdDQoNCnIgPC0gcmFzdChuY29sPTM2LCBucm93PTE4KQ0KdmFsdWVzKHIpIDwtIHJ1bmlmKG5jZWxsKHIpKQ0KbGlicmFyeShyYXN0ZXIpDQojIyBMb2FkaW5nIHJlcXVpcmVkIHBhY2thZ2U6IHNwDQp4IDwtIHJhc3RlcihyKQ0K" download="maps.R">Download maps.R</a>
<hr />
<p>This is an introduction to spatial data manipulation with R and the
terra package. In this context “spatial data” refers to data about
geographical locations, that is, places on earth. So to be more precise,
we should speak about <strong>geospatial</strong> data, but we use the
shorthand <strong>spatial</strong>.</p>
<p>The package <code>terra</code> is now the package of reference for
manipulating spatial data, spatial analysis and modeling in R. It is a
very large topics and here we cover the basics of data manipulation.</p>
<p>Because of the many changes happening in the past few years related
to spatial data analysis in R, this section of the course is still under
developement. <strong>The information below are largely extracted form
Terra online tutorial available <a
href="https://rspatial.org/spatial/2-spatialdata.html">here</a>.</strong></p>
<div id="spatial-data" class="section level1">
<h1>Spatial data</h1>
<p>Spatial phenomena can generally be thought of as either discrete
objects with clear boundaries or as a continuous phenomena that can be
observed everywhere, but that do not have natural boundaries. Discrete
spatial objects may refer to a river, road, country, town, or a research
site. Examples of continuous phenomena, or <strong>spatial
fields</strong>, include elevation, temperature, and air quality.</p>
<p>Spatial objects are usually represented by vector data. Such data
consists of a description of the <strong>geometry</strong> or
<strong>shape</strong> of the objects, and normally also includes
additional variables. For example, a vector data set may represent the
borders of the countries of the world (geometry), and also store their
names and the size of their population in 2015; or it may have the
geometry of the roads in an area, as well as their type and names. These
additional variables are often referred to as
<strong>attributes</strong>. Continuous spatial data (fields) are
usually represented with a raster data structure. We discuss these two
data types in turn.</p>
<div id="vector-data" class="section level2">
<h2>Vector data</h2>
<p>The main vector data types are points, lines and polygons. In all
cases, the geometry of these data structures consists of sets of
coordinate pairs (x, y). Points are the simplest case. Each point has
one coordinate pair, and n associated variables. For example, a point
might represent a place where a rat was trapped, and the attributes
could include the date it was captured, the person who captured it, the
species size and sex, and information about the habitat. It is also
possible to combine several points into a multi-point structure, with a
single attribute record. For example, all the coffee shops in a town
could be considered as a single geometry.</p>
<p>The geometry of lines is a just a little bit more complex. First note
that in this context, the term <em>line</em> refers to a set of one or
more polylines (connected series of line segments). For example, in
spatial analysis, a river and all its tributaries could be considered as
a single <em>line</em> (but they could also also be several lines,
perhaps one for each tributary river). Lines are represented as ordered
sets of coordinates (nodes). The actual line segments can be computed
(and drawn on a map) by connecting the points. Thus, the representation
of a line is very similar to that of a multi-point structure. The main
difference is that for a line the ordering of the points is important,
because we need to know in which order the points should be
connected.</p>
<p>A network (e.g. a road or river network), or spatial graph, is a
special type of lines geometry where there is additional information
about things like flow, connectivity, direction, and distance.</p>
<p>A polygon refers to a set of closed polylines. The geometry is very
similar to that of lines, but to close a polygon the last coordinate
pair coincides with the first pair. A complication with polygons is that
they can have holes (that is a polygon entirely enclosed by another
polygon, that serves to remove parts of the enclosing polygon (for
example to show an island inside a lake. Also, valid polygons do not
self-intersect (but it is OK for a line to self-cross). Again, multiple
polygons can be considered as a single geometry. For example, Indonesia
consists of many islands. Each island can be represented by a single
polygon, but together then can be represent a single (multi-) polygon
representing the entire country.</p>
</div>
<div id="raster-data" class="section level2">
<h2>Raster data</h2>
<p>Raster data is commonly used to represent spatially continuous
phenomena such as elevation. A raster divides the world into a grid of
equally sized rectangles (referred to as cells or, in the context of
satellite remote sensing, pixels) that all have one or more values (or
missing values) for the variables of interest. A raster cell value
should normally represent the average (or majority) value for the area
it covers. However, in some cases the values are actually estimates for
the center of the cell (in essence becoming a regular set of points with
an attribute).</p>
<p>In contrast to vector data, in raster data the geometry is not
explicitly stored as coordinates. It is implicitly set by knowing the
spatial extent and the number or rows and columns in which the area is
divided. From the extent and number of rows and columns, the size of the
raster cells (spatial resolution) can be computed. While raster cells
can be thought of as a set of regular polygons, it would be very
inefficient to represent the data that way as coordinates for each cell
would have to be stored explicitly. Doing so would also dramatically
increase processing time.</p>
<p>Continuous surface data are sometimes stored as triangulated
irregular networks (TINs); these are not discussed here.</p>
</div>
<div id="simple-representation-of-spatial-data" class="section level2">
<h2>Simple representation of spatial data</h2>
<p>The basic data types in R are numbers, characters, logical (TRUE or
FALSE) and factor values. Values of a single type can be combined in
vectors and matrices, and variables of multiple types can be combined
into a data.frame. We can represent (only very) basic spatial data with
these data types. Let’s say we have the location (represented by
longitude and latitude) of ten weather stations (named A to J) and their
annual precipitation.</p>
<p>In the example below we make a very simple map. Note that a map is
special type of plot (like a scatter plot, barplot, etc.). A map is a
plot of geospatial data that also has labels and other graphical objects
such as a scale bar or legend. The spatial data itself should not be
referred to as a map.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>name <span class="ot">&lt;-</span> LETTERS[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>]</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>longitude <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">116.7</span>, <span class="sc">-</span><span class="fl">120.4</span>, <span class="sc">-</span><span class="fl">116.7</span>, <span class="sc">-</span><span class="fl">113.5</span>, <span class="sc">-</span><span class="fl">115.5</span>,</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>               <span class="sc">-</span><span class="fl">120.8</span>, <span class="sc">-</span><span class="fl">119.5</span>, <span class="sc">-</span><span class="fl">113.7</span>, <span class="sc">-</span><span class="fl">113.7</span>, <span class="sc">-</span><span class="fl">110.7</span>)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>latitude <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">45.3</span>, <span class="fl">42.6</span>, <span class="fl">38.9</span>, <span class="fl">42.1</span>, <span class="fl">35.7</span>, <span class="fl">38.9</span>,</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>              <span class="fl">36.2</span>, <span class="dv">39</span>, <span class="fl">41.6</span>, <span class="fl">36.9</span>)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>stations <span class="ot">&lt;-</span> <span class="fu">cbind</span>(longitude, latitude)</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co"># Simulated rainfall data</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">0</span>)</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>precip <span class="ot">&lt;-</span> <span class="fu">round</span>((<span class="fu">runif</span>(<span class="fu">length</span>(latitude))<span class="sc">*</span><span class="dv">10</span>)<span class="sc">^</span><span class="dv">3</span>)</span></code></pre></div>
<p>A map of point locations is not that different from a basic x-y
scatter plot. Below is a plot (a map in this case) that shows the
location of the weather stations, and the size of the dots is
proportional to the amount of precipitation. The point size is set with
argument cex.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>psize <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">+</span> precip<span class="sc">/</span><span class="dv">500</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="fu">plot</span>(stations, <span class="at">cex=</span>psize, <span class="at">pch=</span><span class="dv">20</span>, <span class="at">col=</span><span class="st">&#39;red&#39;</span>, <span class="at">main=</span><span class="st">&#39;Precipitation&#39;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co"># add names to plot</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="fu">text</span>(stations, name, <span class="at">pos=</span><span class="dv">4</span>)</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="co"># add a legend</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>breaks <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">250</span>, <span class="dv">500</span>, <span class="dv">1000</span>)</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>legend.psize <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">+</span>breaks<span class="sc">/</span><span class="dv">500</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="at">legend=</span>breaks, <span class="at">pch=</span><span class="dv">20</span>, <span class="at">pt.cex=</span>legend.psize, <span class="at">col=</span><span class="st">&#39;red&#39;</span>, <span class="at">bg=</span><span class="st">&#39;gray&#39;</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>Note that the data are represented by “longitude, latitude”, in that
order, do not use “latitude, longitude” because on most maps latitude
(North/South) is used for the vertical axis and longitude (East/West)
for the horizontal axis. This is important to keep in mind, as it is a
very common source of mistakes!</p>
<p>We can add multiple sets of points to the plot, and even draw lines
and polygons:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>lon <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">116.8</span>, <span class="sc">-</span><span class="fl">114.2</span>, <span class="sc">-</span><span class="fl">112.9</span>, <span class="sc">-</span><span class="fl">111.9</span>, <span class="sc">-</span><span class="fl">114.2</span>, <span class="sc">-</span><span class="fl">115.4</span>, <span class="sc">-</span><span class="fl">117.7</span>)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>lat <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">41.3</span>, <span class="fl">42.9</span>, <span class="fl">42.4</span>, <span class="fl">39.8</span>, <span class="fl">37.6</span>, <span class="fl">38.3</span>, <span class="fl">37.6</span>)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">cbind</span>(lon, lat)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="fu">plot</span>(stations, <span class="at">main=</span><span class="st">&#39;Precipitation&#39;</span>)</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="fu">polygon</span>(x, <span class="at">col=</span><span class="st">&#39;blue&#39;</span>, <span class="at">border=</span><span class="st">&#39;light blue&#39;</span>)</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="fu">lines</span>(stations, <span class="at">lwd=</span><span class="dv">3</span>, <span class="at">col=</span><span class="st">&#39;red&#39;</span>)</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="fu">points</span>(x, <span class="at">cex=</span><span class="dv">2</span>, <span class="at">pch=</span><span class="dv">20</span>)</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="fu">points</span>(stations, <span class="at">cex=</span>psize, <span class="at">pch=</span><span class="dv">20</span>, <span class="at">col=</span><span class="st">&#39;red&#39;</span>, <span class="at">main=</span><span class="st">&#39;Precipitation&#39;</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>The above illustrates how numeric vectors representing locations can
be used to draw simple maps. It also shows how points can (and typically
are) represented by pairs of numbers. A line and a polygon can be
represented by a number of these points. Polygons need to “closed”, that
is, the first point must coincide with the last point, but the
<code>polygon</code> function took care of that for us.</p>
<p>There are cases where a simple approach like this may suffice and you
may come across this in older R code or packages. Likewise, raster data
could be represented by a matrix or higher-order array. Particularly
when only dealing with point data such an approach may be practical. For
example, a spatial data set representing points and attributes could be
made by combining geometry and attributes in a single
<code>data.frame</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>wst <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(longitude, latitude, name, precip)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>wst</span></code></pre></div>
<pre><code>##    longitude latitude name precip
## 1     -116.7     45.3    A    721
## 2     -120.4     42.6    B     19
## 3     -116.7     38.9    C     52
## 4     -113.5     42.1    D    188
## 5     -115.5     35.7    E    749
## 6     -120.8     38.9    F      8
## 7     -119.5     36.2    G    725
## 8     -113.7     39.0    H    843
## 9     -113.7     41.6    I    289
## 10    -110.7     36.9    J    249</code></pre>
<p>However, <code>wst</code> is a data.frame and R does not
automatically understand the special meaning of the first two columns,
or to what coordinate reference system it refers (longitude/latitude, or
perhaps UTM zone 17S, or ….?).</p>
<p>Moreover, it is non-trivial to do some basic spatial operations. For
example, the blue polygon drawn on the map above might represent a
state, and a next question might be which of the 10 stations fall within
that polygon. And how about any other operation on spatial data,
including reading from and writing data to files? To facilitate such
operation a number of R packages have been developed that define new
spatial data types that can be used for this type of specialized
operations.</p>
<p>Recent packages in R that define such spatial data structures include
<code>terra</code> and <code>sf</code>. These packages replace a set of
older packages including <code>raster</code> and <code>sp</code>.</p>
<p>We mostly use the <code>terra</code> package in these materials. You
can install the latest released version of terra from CRAN with
<code>install.packages("terra")</code>.</p>
</div>
</div>
<div id="reading-and-writing-spatial-data" class="section level1">
<h1>Reading and writing spatial data</h1>
<p>Reading and writing spatial data is complicated by the fact that
there are many different file formats. However, there are a few formats
that are most common that we discuss here.</p>
<div id="vector-files" class="section level2">
<h2>Vector files</h2>
<p>The shapefile is the most commonly used file format for vector data
(if you are not familiar with this file format, an important thing to
understand is that a shapefile is really a set of at least three
(ideally four) files, with all the same name, but different extension.
For shapefile x you must have, in the same directory, these three files:
x.shp, x.shx, x.dbf, and ideally also x.prj.</p>
<p>It is easy to read and write such files. Here we use a shapefile that
comes with the <code>terra</code> package.</p>
<div id="reading" class="section level3">
<h3>Reading</h3>
<p>Let’s first download some spatial data of Taiwan using the
<code>geodata</code> package:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">library</span> (geodata)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="co">#TWN &lt;- gadm(country=&quot;TWN&quot;, level=1, path=tempdir())</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">#TWN &lt;- gadm(country=&quot;TWN&quot;, level=1, path=&quot;./data&quot;</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>TWN <span class="ot">&lt;-</span> <span class="fu">vect</span>(<span class="st">&#39;data/gadm/gadm41_TWN_1_pk.rds&#39;</span>)</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>TWN</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co"># check for ?gadm</span></span></code></pre></div>
<p>Using a .shp file, we can use the <code>vect</code> function from the
<code>terra</code> package to read the file. First:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># example using .shp file</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="fu">library</span>(terra)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>filename1 <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;ex/lux.shp&quot;</span>, <span class="at">package=</span><span class="st">&quot;terra&quot;</span>)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="fu">basename</span>(filename1)</span></code></pre></div>
<pre><code>## [1] &quot;lux.shp&quot;</code></pre>
<blockquote>
<p>We use the system.file function to get the full path name of the
file’s location. We need to do this as the location of this file depends
on where the terra package is installed. You should not use the
system.file function for your own files. It only serves for creating
examples with data that ship with R. With your own files, just use the
filename (and path if the file is not in your working directory).</p>
</blockquote>
<p>Then:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># example using .shp file</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>s1 <span class="ot">&lt;-</span> <span class="fu">vect</span>(filename1)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>s1</span></code></pre></div>
<pre><code>##  class       : SpatVector 
##  geometry    : polygons 
##  dimensions  : 12, 6  (geometries, attributes)
##  extent      : 5.74414, 6.528252, 49.44781, 50.18162  (xmin, xmax, ymin, ymax)
##  source      : lux.shp
##  coord. ref. : lon/lat WGS 84 (EPSG:4326) 
##  names       :  ID_1   NAME_1  ID_2   NAME_2  AREA   POP
##  type        : &lt;num&gt;    &lt;chr&gt; &lt;num&gt;    &lt;chr&gt; &lt;num&gt; &lt;int&gt;
##  values      :     1 Diekirch     1 Clervaux   312 18081
##                    1 Diekirch     2 Diekirch   218 32543
##                    1 Diekirch     3  Redange   259 18664</code></pre>
<p>The <code>vect</code> function returns <code>SpatVector</code>
objects. It is important to recognise the difference between this type
of R object (<code>SpatVector</code>), and the file (“shapefile”) that
was used to create it. Thus, you should never say “I have a shapefile in
R”, say “I have a SpatVector of polygons in R”, (and in some cases you
can add “created from a shapefile”). The shapefile is one of many file
formats for vector data.</p>
</div>
<div id="writing" class="section level3">
<h3>Writing</h3>
<p>You can write new files using the <code>writeVector</code> method.
You need to add argument <code>overwrite=TRUE</code> if you want to
overwrite an existing file.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>TWN <span class="ot">&lt;-</span> <span class="fu">vect</span>(<span class="st">&#39;data/gadm/gadm41_TWN_1_pk.rds&#39;</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>outfile1 <span class="ot">&lt;-</span> <span class="st">&quot;data/shp_TWN.shp&quot;</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="fu">writeVector</span>(TWN, outfile1, <span class="at">overwrite=</span><span class="cn">TRUE</span>)</span></code></pre></div>
</div>
</div>
<div id="raster-files" class="section level2">
<h2>Raster files</h2>
<p>The terra package can read and write several raster file formats.</p>
<div id="reading-raster-data" class="section level3">
<h3>Reading raster data</h3>
<p>Get raster data of taiwan elevation using the <code>geodata</code>
package:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">library</span>(geodata)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>ele <span class="ot">&lt;-</span><span class="fu">elevation_30s</span>(<span class="st">&quot;TWN&quot;</span>, <span class="at">path=</span><span class="fu">tempdir</span>())</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>ele</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 636, 684, 1  (nrow, ncol, nlyr)
## resolution  : 0.008333333, 0.008333333  (x, y)
## extent      : 116.6, 122.3, 20.5, 25.8  (xmin, xmax, ymin, ymax)
## coord. ref. : lon/lat WGS 84 (EPSG:4326) 
## source      : TWN_elv_msk.tif 
## name        : TWN_elv_msk 
## min value   :         -12 
## max value   :        3741</code></pre>
<p>Using a .tif file, we can use the <code>rast</code> function from the
<code>terra</code> package to read the file. Firstusing example file
from the package:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;ex/logo.tif&quot;</span>, <span class="at">package=</span><span class="st">&quot;terra&quot;</span>)</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="fu">basename</span>(f)</span></code></pre></div>
<pre><code>## [1] &quot;logo.tif&quot;</code></pre>
<p>Now we can do</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(f)</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>r</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 77, 101, 3  (nrow, ncol, nlyr)
## resolution  : 1, 1  (x, y)
## extent      : 0, 101, 0, 77  (xmin, xmax, ymin, ymax)
## coord. ref. : Cartesian (Meter) 
## source      : logo.tif 
## colors RGB  : 1, 2, 3 
## names       : red, green, blue 
## min values  :   0,     0,    0 
## max values  : 255,   255,  255</code></pre>
<p>Note that x is a SpatRaster of three layers (“bands”). We can subset
it to get a single layer.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>r2 <span class="ot">&lt;-</span> r[[<span class="dv">2</span>]]</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>r2</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 77, 101, 1  (nrow, ncol, nlyr)
## resolution  : 1, 1  (x, y)
## extent      : 0, 101, 0, 77  (xmin, xmax, ymin, ymax)
## coord. ref. : Cartesian (Meter) 
## source      : logo.tif 
## name        : green 
## min value   :     0 
## max value   :   255</code></pre>
<p>The same approach holds for other raster file formats, including
GeoTiff, NetCDF, Imagine, and ESRI Grid formats.</p>
</div>
<div id="writing-raster-data" class="section level3">
<h3>Writing raster data</h3>
<p>Use <code>writeRaster</code> to write raster data. You must provide a
SpatRaster and a filename. The file format will be guessed from the
filename extension. If that does not work you can provide an argument
like <code>format=GTiff</code>. Note the argument
<code>overwrite=TRUE</code> and see <code>?writeRaster</code> for more
arguments, such as <code>datatype=</code> to set the a specific datatype
(e.g., integer).</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">writeRaster</span>(ele, <span class="st">&quot;data/ele.tif&quot;</span>, <span class="at">overwrite=</span><span class="cn">TRUE</span>)</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>x</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 636, 684, 1  (nrow, ncol, nlyr)
## resolution  : 0.008333333, 0.008333333  (x, y)
## extent      : 116.6, 122.3, 20.5, 25.8  (xmin, xmax, ymin, ymax)
## coord. ref. : lon/lat WGS 84 (EPSG:4326) 
## source      : ele.tif 
## name        : TWN_elv_msk 
## min value   :         -12 
## max value   :        3741</code></pre>
</div>
</div>
</div>
<div id="coordinate-reference-systems" class="section level1">
<h1>Coordinate Reference Systems</h1>
<p>A very important aspect of spatial data is the coordinate reference
system (CRS) that is used. For example, a location of (140, 12) is not
meaningful if you do know where the origin (0,0) is and if the
x-coordinate is 140 meters, feet, nautical miles, kilometers, or perhaps
degrees away from the x-origin.</p>
<div id="coordinate-reference-systems-crs" class="section level2">
<h2>Coordinate Reference Systems (CRS)</h2>
<div id="angular-coordinates" class="section level3">
<h3>Angular coordinates</h3>
<p>The earth has an irregular spheroid-like shape. The natural
coordinate reference system for geographic data is longitude/latitude.
This is an angular coordinate reference system. The latitude (phi) of a
point is the angle between the equatorial plane and the line that passes
through a point and the center of the Earth. Longitude (lambda) is the
angle from a reference meridian (lines of constant longitude) to a
meridian that passes through the point.</p>
<p>Obviously we cannot actually measure these angles. But we can
estimate them. To do so, you need a model of the shape of the earth.
Such a model is called a “datum”. The simplest datums are a spheroid (a
sphere that is “flattened” at the poles and bulges at the equator). More
complex datums allow for more variation in the earth’s shape. The most
commonly used datum is called WGS84 (World Geodesic System 1984). This
is very similar to NAD83 (The North American Datum of 1983). Other,
local datums exist to more precisely record locations for a single
country or region.</p>
<p>So the basic way to record a location is a coordinate pair in degrees
and a reference datum. Sometimes people say that their coordinates are
“in WGS84”. That does not tell us much; they typically mean to say that
they are longitude/latitude relative to the WGS84 datum. Likewise
longitude/latitude coordinates are sometimes referred to as “geographic”
coordinates. That is rather odd, if planar coordinate reference systems
(see below) are not geographic, what are they?</p>
</div>
<div id="projections" class="section level3">
<h3>Projections</h3>
<p>A major question in spatial analysis and cartography is how to
transform this three dimensional angular system to a two dimensional
planar (sometimes called “Cartesian”) system. A planar system is easier
to use for certain calculations and required to make maps (unless you
have a 3-d printer). The different types of planar coordinate reference
systems are referred to as “projections”. Examples are “Mercator”,
“UTM”, “Robinson”, “Lambert”, “Sinusoidal” and “Albers”.</p>
<p>There is not one best projection. Some projections can be used for a
map of the whole world; other projections are appropriate for small
areas only. One of the most important characteristics of a map
projection is whether it is “equal area” (the scale of the map is
constant) or “conformal” (the shapes of the geographic features are as
they are seen on a globe). No two dimensional map projection can be both
conformal and equal-area (but they can be approximately both for smaller
areas, e.g. UTM, or Lambert Equal Area for a larger area), and some are
neither.</p>
</div>
<div id="notation" class="section level3">
<h3>Notation</h3>
<p>A planar CRS is defined by a projection, datum, and a set of
parameters. The parameters determine things like where the center of the
map is. The number of parameters depends on the projection. It is
therefore not trivial to document a projection used, and several systems
exist. In R we used to depend on the PROJ.4 notation. PROJ.4 is the name
of a software library that is commonly used for CRS transformation. You
can find many more of these on <a
href="https://spatialreference.org/ref/epsg/4326/">spatialreference.org</a></p>
<p>The PROJ.4 notation is no longer fully supported in the newer
versions of the library (that was renamed to PR<span
class="math inline">\(\phi\)</span>J). It still works for CRSs with the
WGS84 datum. For other cases you have to use a EPSG code (if available)
or a Well-Known-Text notation.</p>
<p>Most commonly used CRSs have been assigned a “EPSG code” (EPSG stands
for European Petroleum Survey Group). This is a unique ID that can be a
simple way to identify a CRS. For example <code>EPSG:27561</code> is
equivalent to
<code>+proj=lcc +lat_1=49.5 +lat_0=49.5 +lon_0=0 +k_0=0.999877341 +x_0=6 +y_0=2 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs</code>.</p>
<p>Now let’s look at an example with a spatial data set in R.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>s1</span></code></pre></div>
<pre><code>##  class       : SpatVector 
##  geometry    : polygons 
##  dimensions  : 12, 6  (geometries, attributes)
##  extent      : 5.74414, 6.528252, 49.44781, 50.18162  (xmin, xmax, ymin, ymax)
##  source      : lux.shp
##  coord. ref. : lon/lat WGS 84 (EPSG:4326) 
##  names       :  ID_1   NAME_1  ID_2   NAME_2  AREA   POP
##  type        : &lt;num&gt;    &lt;chr&gt; &lt;num&gt;    &lt;chr&gt; &lt;num&gt; &lt;int&gt;
##  values      :     1 Diekirch     1 Clervaux   312 18081
##                    1 Diekirch     2 Diekirch   218 32543
##                    1 Diekirch     3  Redange   259 18664</code></pre>
<p>We can inspect the coordinate reference system like this.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="fu">crs</span>(s1)</span></code></pre></div>
<pre><code>## [1] &quot;GEOGCRS[\&quot;WGS 84\&quot;,\n    DATUM[\&quot;World Geodetic System 1984\&quot;,\n        ELLIPSOID[\&quot;WGS 84\&quot;,6378137,298.257223563,\n            LENGTHUNIT[\&quot;metre\&quot;,1]]],\n    PRIMEM[\&quot;Greenwich\&quot;,0,\n        ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\&quot;geodetic latitude (Lat)\&quot;,north,\n            ORDER[1],\n            ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433]],\n        AXIS[\&quot;geodetic longitude (Lon)\&quot;,east,\n            ORDER[2],\n            ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433]],\n    ID[\&quot;EPSG\&quot;,4326]]&quot;</code></pre>
</div>
</div>
<div id="assigning-crs" class="section level2">
<h2>Assigning CRS</h2>
<p>Sometimes we have data without a CRS. This can be because the file
used was incomplete, or perhaps because we created the data ourselves
with R code. In that case we can assign the CRS if we know what it
should be. Here I first remove the CRS of <code>pp</code> and then I set
it again.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>ss <span class="ot">&lt;-</span> s1</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a><span class="fu">crs</span>(ss) <span class="ot">&lt;-</span> <span class="st">&quot;&quot;</span></span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a><span class="fu">crs</span>(ss)</span></code></pre></div>
<pre><code>## [1] &quot;&quot;</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="fu">crs</span>(ss) <span class="ot">&lt;-</span> <span class="st">&quot;+proj=longlat +datum=WGS84&quot;</span></span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a><span class="fu">crs</span>(ss)</span></code></pre></div>
<pre><code>## [1] &quot;GEOGCRS[\&quot;unknown\&quot;,\n    DATUM[\&quot;World Geodetic System 1984\&quot;,\n        ELLIPSOID[\&quot;WGS 84\&quot;,6378137,298.257223563,\n            LENGTHUNIT[\&quot;metre\&quot;,1]],\n        ID[\&quot;EPSG\&quot;,6326]],\n    PRIMEM[\&quot;Greenwich\&quot;,0,\n        ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433],\n        ID[\&quot;EPSG\&quot;,8901]],\n    CS[ellipsoidal,2],\n        AXIS[\&quot;longitude\&quot;,east,\n            ORDER[1],\n            ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433,\n                ID[\&quot;EPSG\&quot;,9122]]],\n        AXIS[\&quot;latitude\&quot;,north,\n            ORDER[2],\n            ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433,\n                ID[\&quot;EPSG\&quot;,9122]]]]&quot;</code></pre>
<p>Note that you should not use this approach to change the CRS of a
data set from what it is to what you want it to be. Assigning a CRS is
like labeling something. You need to provide the label that corresponds
to the item. Not to what you would like it to be. For example if you
label a bicycle, you can write “bicycle”. Perhaps you would prefer a
car, and you can label your bicycle as “car” but that would not do you
any good. It is still a bicycle. You can try to transform your bicycle
into a car. That would not be easy. Transforming spatial data is
easier.</p>
</div>
<div id="transforming-vector-data" class="section level2">
<h2>Transforming vector data</h2>
<p>We can transform these data to a new data set with another CRS using
the <code>project</code> method.</p>
<p>Here we use the Robinson projection. First we need to find the
correct notation.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>newcrs <span class="ot">&lt;-</span> <span class="st">&quot;+proj=robin +datum=WGS84&quot;</span></span></code></pre></div>
<p>Now use it:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>rob <span class="ot">&lt;-</span> terra<span class="sc">::</span><span class="fu">project</span>(s1, newcrs)</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>rob</span></code></pre></div>
<pre><code>##  class       : SpatVector 
##  geometry    : polygons 
##  dimensions  : 12, 6  (geometries, attributes)
##  extent      : 471320.7, 536010.5, 5269709, 5345677  (xmin, xmax, ymin, ymax)
##  coord. ref. : +proj=robin +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs 
##  names       :  ID_1   NAME_1  ID_2   NAME_2  AREA   POP
##  type        : &lt;num&gt;    &lt;chr&gt; &lt;num&gt;    &lt;chr&gt; &lt;num&gt; &lt;int&gt;
##  values      :     1 Diekirch     1 Clervaux   312 18081
##                    1 Diekirch     2 Diekirch   218 32543
##                    1 Diekirch     3  Redange   259 18664</code></pre>
<p>After the transformation, the units of the geometry are no longer in
degrees, but in meters away from (longitude=0, latitude=0). The spatial
extent of the data is also in these units.</p>
<p>We can backtransform to longitude/latitude:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> terra<span class="sc">::</span><span class="fu">project</span>(rob, <span class="st">&quot;+proj=longlat +datum=WGS84&quot;</span>)</span></code></pre></div>
</div>
<div id="transforming-raster-data" class="section level2">
<h2>Transforming raster data</h2>
<p>Vector data can be transformed from lon/lat coordinates to planar and
back without loss of precision. This is not the case with raster data. A
raster consists of rectangular cells of the same size (in terms of the
units of the CRS; their actual size may vary). It is not possible to
transform cell by cell. For each new cell, values need to be estimated
based on the values in the overlapping old cells. If the values are
categorical data, the “nearest neighbor” method is commonly used.
Otherwise some sort of interpolation is employed (e.g. “bilinear”).</p>
<p>Because projection of rasters affects the cell values, in most cases
you will want to avoid projecting raster data and rather project vector
data. But here is how you can project raster data.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="at">xmin=</span><span class="sc">-</span><span class="dv">110</span>, <span class="at">xmax=</span><span class="sc">-</span><span class="dv">90</span>, <span class="at">ymin=</span><span class="dv">40</span>, <span class="at">ymax=</span><span class="dv">60</span>, <span class="at">ncols=</span><span class="dv">40</span>, <span class="at">nrows=</span><span class="dv">40</span>)</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a><span class="fu">values</span>(r) <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">ncell</span>(r)</span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a>r</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 40, 40, 1  (nrow, ncol, nlyr)
## resolution  : 0.5, 0.5  (x, y)
## extent      : -110, -90, 40, 60  (xmin, xmax, ymin, ymax)
## coord. ref. : lon/lat WGS 84 
## source(s)   : memory
## name        : lyr.1 
## min value   :     1 
## max value   :  1600</code></pre>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="fu">plot</span> (r)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<p>The simplest approach is to provide a new crs (the Robinson crs in
this case):</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a>newcrs</span></code></pre></div>
<pre><code>## [1] &quot;+proj=robin +datum=WGS84&quot;</code></pre>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a>pr1 <span class="ot">&lt;-</span> terra<span class="sc">::</span><span class="fu">project</span>(r, newcrs)</span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a><span class="fu">crs</span>(pr1)</span></code></pre></div>
<pre><code>## [1] &quot;PROJCRS[\&quot;unknown\&quot;,\n    BASEGEOGCRS[\&quot;unknown\&quot;,\n        DATUM[\&quot;World Geodetic System 1984\&quot;,\n            ELLIPSOID[\&quot;WGS 84\&quot;,6378137,298.257223563,\n                LENGTHUNIT[\&quot;metre\&quot;,1]],\n            ID[\&quot;EPSG\&quot;,6326]],\n        PRIMEM[\&quot;Greenwich\&quot;,0,\n            ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433],\n            ID[\&quot;EPSG\&quot;,8901]]],\n    CONVERSION[\&quot;unknown\&quot;,\n        METHOD[\&quot;Robinson\&quot;],\n        PARAMETER[\&quot;Longitude of natural origin\&quot;,0,\n            ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433],\n            ID[\&quot;EPSG\&quot;,8802]],\n        PARAMETER[\&quot;False easting\&quot;,0,\n            LENGTHUNIT[\&quot;metre\&quot;,1],\n            ID[\&quot;EPSG\&quot;,8806]],\n        PARAMETER[\&quot;False northing\&quot;,0,\n            LENGTHUNIT[\&quot;metre\&quot;,1],\n            ID[\&quot;EPSG\&quot;,8807]]],\n    CS[Cartesian,2],\n        AXIS[\&quot;(E)\&quot;,east,\n            ORDER[1],\n            LENGTHUNIT[\&quot;metre\&quot;,1,\n                ID[\&quot;EPSG\&quot;,9001]]],\n        AXIS[\&quot;(N)\&quot;,north,\n            ORDER[2],\n            LENGTHUNIT[\&quot;metre\&quot;,1,\n                ID[\&quot;EPSG\&quot;,9001]]]]&quot;</code></pre>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="fu">plot</span>(pr1)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<p>But that is not a good method. As you should want to assure that you
project fits to exactly the raster parameters you need (so that it lines
up with other raster data you are using).</p>
<p>To have this kind of control, provide an existing SpatRaster with the
geometry you desire. That is generally the best way to project raster.
By providing an existing SpatRaster, such that your newly projected data
perfectly aligns with it. In this example we do not have an existing
SpatRaster object, so we create from the result obtained above.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rast</span>(pr1)</span>
<span id="cb42-2"><a href="#cb42-2" tabindex="-1"></a><span class="co"># Set the cell size</span></span>
<span id="cb42-3"><a href="#cb42-3" tabindex="-1"></a><span class="fu">res</span>(x) <span class="ot">&lt;-</span> <span class="dv">200000</span></span></code></pre></div>
<p>Now project, and note the change in the coordinates.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a>pr3 <span class="ot">&lt;-</span> terra<span class="sc">::</span><span class="fu">project</span>(r, x)</span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a>pr3</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 10, 14, 1  (nrow, ncol, nlyr)
## resolution  : 2e+05, 2e+05  (x, y)
## extent      : -9577685, -6777685, 4283463, 6283463  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=robin +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs 
## source(s)   : memory
## name        :     lyr.1 
## min value   :  111.1541 
## max value   : 1523.5796</code></pre>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a><span class="fu">plot</span>(pr3)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<p>For raster based analysis it is often important to use equal area
projections, particularly when large areas are analyzed. This will
assure that the grid cells are all of same size, and therefore
comparable to each other, especially when count data are used.</p>
</div>
</div>
<div id="vector-data-manipulation" class="section level1">
<h1>Vector data manipulation</h1>
<p>This chapter illustrates some ways in which we can manipulate vector
data. We start with an example SpatVector that we read from a
shapefile.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a>TWN <span class="ot">&lt;-</span> <span class="fu">vect</span>(<span class="st">&#39;data/gadm/gadm41_TWN_1_pk.rds&#39;</span>)</span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a><span class="fu">plot</span>(TWN, <span class="st">&quot;NAME_1&quot;</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<p>We can plot these data in many ways. For example:</p>
<p>We can see this data set is incomplete for Taiwan. Let’s get some
data directly from Taiwan</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="st">&#39;https://data.moi.gov.tw/MoiOD/System/DownloadFile.aspx?DATA=72874C55-884D-4CEA-B7D6-F60B0BE85AB0&#39;</span></span>
<span id="cb47-2"><a href="#cb47-2" tabindex="-1"></a>path1 <span class="ot">&lt;-</span> <span class="fu">tempfile</span>(<span class="at">fileext =</span> <span class="st">&quot;.zip&quot;</span>)</span>
<span id="cb47-3"><a href="#cb47-3" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">file.exists</span>(path1))  <span class="st">&#39;file alredy exists&#39;</span> <span class="cf">else</span> <span class="fu">download.file</span>(url, path1, <span class="at">mode=</span><span class="st">&quot;wb&quot;</span>)</span>
<span id="cb47-4"><a href="#cb47-4" tabindex="-1"></a>zip<span class="sc">::</span><span class="fu">unzip</span>(<span class="at">zipfile =</span> path1,<span class="at">exdir =</span> <span class="st">&#39;data&#39;</span>)</span></code></pre></div>
<p>Make <code>SpatialVector</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a>Taiwan <span class="ot">&lt;-</span> <span class="st">&quot;data/COUNTY_MOI_1130718.shp&quot;</span></span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>Taiwan <span class="ot">&lt;-</span><span class="fu">vect</span>(Taiwan)</span></code></pre></div>
<p>Make the new plot:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a><span class="fu">plot</span>(Taiwan, <span class="st">&quot;COUNTYENG&quot;</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
<div id="basics" class="section level2">
<h2>Basics</h2>
<div id="geometry-and-attributes" class="section level3">
<h3>Geometry and attributes</h3>
<p>To extract the attributes (data.frame) from a SpatVector, use:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a>d <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(Taiwan)</span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a><span class="co"># head(d) # not run for Chinese character</span></span></code></pre></div>
<p>You can also extract the geometry as a a matrix (this is rarely
needed).</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">geom</span>(Taiwan) </span>
<span id="cb51-2"><a href="#cb51-2" tabindex="-1"></a><span class="fu">head</span>(g)</span></code></pre></div>
<pre><code>##      geom part        x        y hole
## [1,]    1    1 119.9645 25.94552    0
## [2,]    1    1 119.9643 25.94549    0
## [3,]    1    1 119.9642 25.94549    0
## [4,]    1    1 119.9642 25.94549    0
## [5,]    1    1 119.9642 25.94550    0
## [6,]    1    1 119.9641 25.94552    0</code></pre>
<p>Or as “well-known-text”.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">geom</span>(Taiwan, <span class="at">wkt=</span><span class="cn">TRUE</span>)</span>
<span id="cb53-2"><a href="#cb53-2" tabindex="-1"></a><span class="fu">substr</span>(g, <span class="dv">1</span>, <span class="dv">50</span>)</span></code></pre></div>
<pre><code>##  [1] &quot;MULTIPOLYGON (((119.96446 25.945521, 119.964275 25&quot; &quot;MULTIPOLYGON (((121.959718 24.844932, 121.960654 2&quot; &quot;POLYGON ((120.45656 24.207183, 120.485893 24.19737&quot;
##  [4] &quot;POLYGON ((121.27087 24.23661, 121.271083 24.23656,&quot; &quot;MULTIPOLYGON (((120.081084 23.52412, 120.081612 23&quot; &quot;MULTIPOLYGON (((120.826485 21.756146, 120.826462 2&quot;
##  [7] &quot;MULTIPOLYGON (((121.710159 25.176039, 121.710159 2&quot; &quot;POLYGON ((121.570989 25.197165, 121.57098 25.19703&quot; &quot;POLYGON ((121.537526 25.300029, 121.537689 25.3000&quot;
## [10] &quot;POLYGON ((121.328349 24.433038, 121.328456 24.4323&quot; &quot;POLYGON ((120.440252 23.413081, 120.440401 23.4130&quot; &quot;POLYGON ((121.263822 25.121974, 121.266684 25.1207&quot;
## [13] &quot;POLYGON ((120.911982 24.732445, 120.91207 24.73231&quot; &quot;POLYGON ((120.447587 23.518186, 120.447675 23.5181&quot; &quot;MULTIPOLYGON (((120.151922 23.392736, 120.152511 2&quot;
## [16] &quot;MULTIPOLYGON (((118.233816 24.162771, 118.234055 2&quot; &quot;MULTIPOLYGON (((114.361729 10.372803, 114.361744 1&quot; &quot;MULTIPOLYGON (((121.611792 21.9429, 121.611329 21.&quot;
## [19] &quot;POLYGON ((121.631756 24.369428, 121.631667 24.3692&quot; &quot;MULTIPOLYGON (((119.440261 23.221366, 119.44041 23&quot; &quot;POLYGON ((120.930115 24.853014, 120.930242 24.8529&quot;
## [22] &quot;POLYGON ((121.040116 24.943927, 121.040183 24.9438&quot;</code></pre>
</div>
<div id="variables" class="section level3">
<h3>Variables</h3>
<p>You can extract a variable as you would do with a
<code>data.frame</code>.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a>Taiwan<span class="sc">$</span>COUNTYENG</span></code></pre></div>
<pre><code>##  [1] &quot;Lienchiang County&quot; &quot;Yilan County&quot;      &quot;Changhua County&quot;   &quot;Nantou County&quot;     &quot;Yunlin County&quot;     &quot;Pingtung County&quot;   &quot;Keelung City&quot;      &quot;Taipei City&quot;      
##  [9] &quot;New Taipei City&quot;   &quot;Taichung City&quot;     &quot;Tainan City&quot;       &quot;Taoyuan City&quot;      &quot;Miaoli County&quot;     &quot;Chiayi City&quot;       &quot;Chiayi County&quot;     &quot;Kinmen County&quot;    
## [17] &quot;Kaohsiung City&quot;    &quot;Taitung County&quot;    &quot;Hualien County&quot;    &quot;Penghu County&quot;     &quot;Hsinchu City&quot;      &quot;Hsinchu County&quot;</code></pre>
<p>To sub-set a SpatVector to one or more variables you can use the
notation below. Note how this is different from the above example. Above
a vector of values is returned. With the approach below you get a new
SpatVector with only one variable.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a>Taiwan[,<span class="st">&quot;COUNTYENG&quot;</span>]</span></code></pre></div>
<pre><code>##  class       : SpatVector 
##  geometry    : polygons 
##  dimensions  : 22, 1  (geometries, attributes)
##  extent      : 114.3593, 124.5612, 10.37135, 26.38528  (xmin, xmax, ymin, ymax)
##  source      : COUNTY_MOI_1130718.shp
##  coord. ref. : lon/lat GCS_TWD97[2020] 
##  names       :         COUNTYENG
##  type        :             &lt;chr&gt;
##  values      : Lienchiang County
##                     Yilan County
##                  Changhua County</code></pre>
<p>You can add a new variable to a SpatVector just as if it were a
data.frame.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">0</span>)</span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a>Taiwan<span class="sc">$</span>lets <span class="ot">&lt;-</span> <span class="fu">sample</span>(letters, <span class="fu">nrow</span>(Taiwan))</span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a><span class="co"># Taiwan</span></span></code></pre></div>
<p>Note that to get the number of geometries of SpatVector
<code>Taiwan</code>, you can use <code>nrow(Taiwan)</code>, or
<code>size(Taiwan)</code>. You can also do <code>perim(Taiwan)</code> to
get the “length” of the spatial objects (zero for points, the length of
the lines, or the perimeter of the polygons).</p>
<p>Assigning a new value to an existing variable.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a>Taiwan<span class="sc">$</span>lets <span class="ot">&lt;-</span> <span class="fu">sample</span>(LETTERS, <span class="fu">nrow</span>(Taiwan))</span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a><span class="co"># head(Taiwan)</span></span></code></pre></div>
<p>To get rid of a variable, set it to <code>NULL</code>.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" tabindex="-1"></a>Taiwan<span class="sc">$</span>lets <span class="ot">&lt;-</span> <span class="cn">NULL</span></span></code></pre></div>
</div>
<div id="merge" class="section level3">
<h3>Merge</h3>
<p>You can assign an attributes table (data.frame) to a SpatVector with
<code>values&lt;-</code>. To add attributes to a SpatVector that already
has attributes use <code>merge</code> (or <code>cbind</code> if you know
the order of the records is the same).</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a>dfr <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">County=</span>Taiwan<span class="sc">$</span>COUNTYENG, <span class="at">Value=</span><span class="fu">round</span>(<span class="fu">runif</span>(<span class="fu">length</span>(Taiwan), <span class="dv">100</span>, <span class="dv">1000</span>)))</span>
<span id="cb62-2"><a href="#cb62-2" tabindex="-1"></a>dfr <span class="ot">&lt;-</span> dfr[<span class="fu">order</span>(dfr<span class="sc">$</span>County), ]</span>
<span id="cb62-3"><a href="#cb62-3" tabindex="-1"></a>pm <span class="ot">&lt;-</span> <span class="fu">merge</span>(Taiwan, dfr, <span class="at">by.x=</span><span class="st">&quot;COUNTYENG&quot;</span>,<span class="at">by.y=</span><span class="st">&quot;County&quot;</span>)</span>
<span id="cb62-4"><a href="#cb62-4" tabindex="-1"></a><span class="co"># pm </span></span>
<span id="cb62-5"><a href="#cb62-5" tabindex="-1"></a><span class="co"># head(pm)</span></span></code></pre></div>
<p>Note the new variable <code>Value</code> added to <code>pm</code></p>
</div>
<div id="records" class="section level3">
<h3>Records</h3>
<p>Selecting rows (records).</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="fu">which</span>(Taiwan<span class="sc">$</span>COUNTYENG <span class="sc">==</span> <span class="st">&#39;Taipei City&#39;</span>)</span>
<span id="cb63-2"><a href="#cb63-2" tabindex="-1"></a>g <span class="ot">&lt;-</span> Taiwan[i,]</span>
<span id="cb63-3"><a href="#cb63-3" tabindex="-1"></a><span class="co"># g</span></span></code></pre></div>
<p>It is also possible to interactively select and query records by
clicking on a plotted dataset. That is difficult to show here. See
<code>?sel</code> for interactively selecting geometries and
<code>?click</code> to identify attributes by clicking on a plot
(map).</p>
</div>
</div>
<div id="append-and-aggregate" class="section level2">
<h2>Append and aggregate</h2>
<div id="append" class="section level3">
<h3>Append</h3>
<p>More example data. Object z consists of four polygons; z2 is one of
these four polygons.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a>z <span class="ot">&lt;-</span> <span class="fu">rast</span>(Taiwan)</span>
<span id="cb64-2"><a href="#cb64-2" tabindex="-1"></a><span class="fu">dim</span>(z) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb64-3"><a href="#cb64-3" tabindex="-1"></a><span class="fu">values</span>(z) <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span></span>
<span id="cb64-4"><a href="#cb64-4" tabindex="-1"></a><span class="fu">names</span>(z) <span class="ot">&lt;-</span> <span class="st">&#39;Zone&#39;</span></span>
<span id="cb64-5"><a href="#cb64-5" tabindex="-1"></a>z <span class="ot">&lt;-</span> <span class="fu">as.polygons</span>(z)</span>
<span id="cb64-6"><a href="#cb64-6" tabindex="-1"></a>z</span></code></pre></div>
<pre><code>##  class       : SpatVector 
##  geometry    : polygons 
##  dimensions  : 4, 1  (geometries, attributes)
##  extent      : 114.3593, 124.5612, 10.37135, 26.38528  (xmin, xmax, ymin, ymax)
##  coord. ref. : lon/lat GCS_TWD97[2020] 
##  names       :  Zone
##  type        : &lt;int&gt;
##  values      :     1
##                    2
##                    3</code></pre>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a>z1 <span class="ot">&lt;-</span> z[<span class="dv">1</span>,]</span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>z2 <span class="ot">&lt;-</span> z[<span class="dv">2</span>,]</span>
<span id="cb66-3"><a href="#cb66-3" tabindex="-1"></a>z3 <span class="ot">&lt;-</span> z[<span class="dv">3</span>,]</span>
<span id="cb66-4"><a href="#cb66-4" tabindex="-1"></a>z4 <span class="ot">&lt;-</span> z[<span class="dv">4</span>,]</span>
<span id="cb66-5"><a href="#cb66-5" tabindex="-1"></a><span class="fu">plot</span>(Taiwan)</span>
<span id="cb66-6"><a href="#cb66-6" tabindex="-1"></a><span class="fu">plot</span>(z, <span class="at">add=</span><span class="cn">TRUE</span>, <span class="at">border=</span><span class="st">&#39;blue&#39;</span>, <span class="at">lwd=</span><span class="dv">5</span>)</span>
<span id="cb66-7"><a href="#cb66-7" tabindex="-1"></a><span class="fu">plot</span>(z2, <span class="at">add=</span><span class="cn">TRUE</span>, <span class="at">border=</span><span class="st">&#39;red&#39;</span>, <span class="at">lwd=</span><span class="dv">2</span>, <span class="at">col=</span><span class="st">&#39;red&#39;</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-42-1.png" width="672" /></p>
<p>To append SpatVector objects of the same (vector) type you can use
<code>rbind</code>:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">rbind</span>(Taiwan, z)</span>
<span id="cb67-2"><a href="#cb67-2" tabindex="-1"></a><span class="co"># head(b)</span></span>
<span id="cb67-3"><a href="#cb67-3" tabindex="-1"></a><span class="co"># tail(b)</span></span></code></pre></div>
<p>Note how <code>rbind</code> allows you to append SpatVect objects
with different attribute names, unlike the standard <code>rbind</code>
for <code>data.frame</code>.</p>
</div>
<div id="aggregate" class="section level3">
<h3>Aggregate</h3>
<p>It is common to aggregate (“dissolve”) polygons that have the same
value for an attribute of interest. In this case, we want to highlight
the North of Taiwan.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a>Taiwan<span class="sc">$</span>region<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">&quot;Others&quot;</span>,<span class="dv">6</span>), <span class="fu">rep</span>(<span class="st">&quot;North&quot;</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="st">&quot;Others&quot;</span>,<span class="dv">2</span>), <span class="st">&quot;North&quot;</span>, <span class="fu">rep</span>(<span class="st">&quot;Others&quot;</span>,<span class="dv">10</span>))</span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a>pa <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(Taiwan, <span class="at">by=</span><span class="st">&#39;region&#39;</span>)</span>
<span id="cb68-3"><a href="#cb68-3" tabindex="-1"></a>za <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(z)</span>
<span id="cb68-4"><a href="#cb68-4" tabindex="-1"></a><span class="fu">plot</span>(za, <span class="at">col=</span><span class="st">&#39;light gray&#39;</span>, <span class="at">border=</span><span class="st">&#39;light gray&#39;</span>, <span class="at">lwd=</span><span class="dv">5</span>)</span>
<span id="cb68-5"><a href="#cb68-5" tabindex="-1"></a><span class="fu">plot</span>(pa, <span class="at">add=</span><span class="cn">TRUE</span>, <span class="at">col=</span><span class="fu">rainbow</span>(<span class="dv">3</span>), <span class="at">lwd=</span><span class="dv">3</span>, <span class="at">border=</span><span class="st">&#39;white&#39;</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-44-1.png" width="672" /></p>
<p>It is also possible to aggregate polygons without dissolving the
borders.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" tabindex="-1"></a>Taiwan<span class="sc">$</span>region<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">&quot;Others&quot;</span>,<span class="dv">6</span>), <span class="fu">rep</span>(<span class="st">&quot;North&quot;</span>,<span class="dv">3</span>), <span class="fu">rep</span>(<span class="st">&quot;Others&quot;</span>,<span class="dv">2</span>), <span class="st">&quot;North&quot;</span>, <span class="fu">rep</span>(<span class="st">&quot;Others&quot;</span>,<span class="dv">10</span>))</span>
<span id="cb69-2"><a href="#cb69-2" tabindex="-1"></a>pa <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(Taiwan, <span class="at">by=</span><span class="st">&#39;region&#39;</span>,<span class="at">dissolve=</span><span class="cn">FALSE</span>)</span>
<span id="cb69-3"><a href="#cb69-3" tabindex="-1"></a>za <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(z, <span class="at">dissolve =</span> <span class="cn">FALSE</span>)</span>
<span id="cb69-4"><a href="#cb69-4" tabindex="-1"></a><span class="fu">plot</span>(za, <span class="at">col=</span><span class="st">&#39;light gray&#39;</span>, <span class="at">border=</span><span class="st">&#39;dark gray&#39;</span>, <span class="at">lwd=</span><span class="dv">3</span>)</span>
<span id="cb69-5"><a href="#cb69-5" tabindex="-1"></a><span class="fu">plot</span>(pa, <span class="at">add=</span><span class="cn">TRUE</span>, <span class="at">col=</span><span class="fu">rainbow</span>(<span class="dv">3</span>), <span class="at">lwd=</span><span class="dv">2</span>, <span class="at">border=</span><span class="st">&#39;white&#39;</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-45-1.png" width="672" /></p>
<p>This is a structure that is similar to what you may get for an
archipelago: multiple polygons represented as one entity (one row). Use
<code>disagg</code> to split these up into their parts.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a>zd <span class="ot">&lt;-</span> <span class="fu">disagg</span>(pa)</span>
<span id="cb70-2"><a href="#cb70-2" tabindex="-1"></a>zd</span></code></pre></div>
<pre><code>##  class       : SpatVector 
##  geometry    : polygons 
##  dimensions  : 695, 6  (geometries, attributes)
##  extent      : 114.3593, 124.5612, 10.37135, 26.38528  (xmin, xmax, ymin, ymax)
##  coord. ref. : lon/lat GCS_TWD97[2020] 
##  names       : region  COUNTYID COUNTYCODE COUNTYNAME COUNTYENG agg_n
##  type        :  &lt;chr&gt; &lt;logical&gt;  &lt;logical&gt;  &lt;logical&gt; &lt;logical&gt; &lt;int&gt;
##  values      :  North      &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;      &lt;NA&gt;     4
##                 North      &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;      &lt;NA&gt;     4
##                 North      &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;      &lt;NA&gt;     4</code></pre>
</div>
<div id="overlay" class="section level3">
<h3>Overlay</h3>
<p>There are many different ways to “overlay” vector data. Here are some
examples:</p>
<ul>
<li>Erase</li>
</ul>
<p>Erase a part of a SpatVector</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a>e1 <span class="ot">&lt;-</span> <span class="fu">erase</span>(Taiwan,z1 )</span>
<span id="cb72-2"><a href="#cb72-2" tabindex="-1"></a>e2 <span class="ot">&lt;-</span> <span class="fu">erase</span>(e1,z3 )</span>
<span id="cb72-3"><a href="#cb72-3" tabindex="-1"></a>e3 <span class="ot">&lt;-</span> <span class="fu">erase</span>(e2,z4 )</span>
<span id="cb72-4"><a href="#cb72-4" tabindex="-1"></a><span class="fu">plot</span>(e3)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-47-1.png" width="672" /></p>
<ul>
<li>Intersect</li>
</ul>
<p>Easier to complete with <code>intersect</code> SpatVectors</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" tabindex="-1"></a>i <span class="ot">&lt;-</span> terra<span class="sc">::</span><span class="fu">intersect</span>(Taiwan, z3)</span>
<span id="cb73-2"><a href="#cb73-2" tabindex="-1"></a><span class="fu">plot</span>(i)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-48-1.png" width="672" /></p>
<p>You got Taiping Island.</p>
<p>You can also <code>intersect</code> or <code>crop</code> with a
SpatExtent (rectangle). The difference between <code>intersect</code>
and <code>crop</code> is that with crop the geometry of the second
argument is not added to the output.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a>e <span class="ot">&lt;-</span> <span class="fu">ext</span>(<span class="dv">119</span>, <span class="dv">123</span>, <span class="dv">21</span>, <span class="dv">26</span>)</span>
<span id="cb74-2"><a href="#cb74-2" tabindex="-1"></a>te <span class="ot">&lt;-</span> <span class="fu">crop</span>(Taiwan, e)</span>
<span id="cb74-3"><a href="#cb74-3" tabindex="-1"></a><span class="fu">plot</span>(Taiwan)</span>
<span id="cb74-4"><a href="#cb74-4" tabindex="-1"></a><span class="fu">plot</span>(e, <span class="at">add=</span><span class="cn">TRUE</span>, <span class="at">lwd=</span><span class="dv">3</span>, <span class="at">col=</span><span class="st">&quot;red&quot;</span>)</span>
<span id="cb74-5"><a href="#cb74-5" tabindex="-1"></a><span class="fu">plot</span>(te, <span class="at">col=</span><span class="st">&#39;light blue&#39;</span>, <span class="at">add=</span><span class="cn">TRUE</span>)</span>
<span id="cb74-6"><a href="#cb74-6" tabindex="-1"></a><span class="fu">plot</span>(e, <span class="at">add=</span><span class="cn">TRUE</span>, <span class="at">lwd=</span><span class="dv">3</span>, <span class="at">border=</span><span class="st">&quot;blue&quot;</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-49-1.png" width="672" /></p>
<ul>
<li>Union</li>
</ul>
<p>Get the union of two SpatVectors.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" tabindex="-1"></a>u <span class="ot">&lt;-</span> terra<span class="sc">::</span><span class="fu">union</span>(Taiwan, z)</span>
<span id="cb75-2"><a href="#cb75-2" tabindex="-1"></a>u</span></code></pre></div>
<pre><code>##  class       : SpatVector 
##  geometry    : polygons 
##  dimensions  : 30, 6  (geometries, attributes)
##  extent      : 114.3593, 124.5612, 10.37135, 26.38528  (xmin, xmax, ymin, ymax)
##  coord. ref. : lon/lat GCS_TWD97[2020] 
##  names       : COUNTYID COUNTYCODE COUNTYNAME         COUNTYENG region  Zone
##  type        :    &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;             &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;
##  values      :        Z      09007     連江縣 Lienchiang County Others     2
##                       G      10002     宜蘭縣      Yilan County Others     2
##                       N      10007     彰化縣   Changhua County Others     2</code></pre>
<p>Note that there are many more polygons now. One for each unique
combination of polygons (and attributes in this case).</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">5</span>)</span>
<span id="cb77-2"><a href="#cb77-2" tabindex="-1"></a><span class="fu">plot</span>(u, <span class="at">col=</span><span class="fu">sample</span>(<span class="fu">rainbow</span>(<span class="fu">length</span>(u))))</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-51-1.png" width="672" /></p>
<ul>
<li>Cover</li>
</ul>
<p><code>cover</code> is a combination of <code>intersect</code> and
<code>union</code>. <code>intersect</code> returns new (intersected)
geometries with the attributes of both input datasets.
<code>union</code> appends the geometries and attributes of the input.
<code>cover</code> returns the intersection and appends the other
geometries and attributes of both datasets.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a>cov <span class="ot">&lt;-</span> <span class="fu">cover</span>(Taiwan, z[<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>),])</span>
<span id="cb78-2"><a href="#cb78-2" tabindex="-1"></a><span class="fu">plot</span>(cov)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-52-1.png" width="672" /></p>
<ul>
<li>Difference</li>
</ul>
<p>The symmetrical difference of two SpatVectors</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" tabindex="-1"></a>dif <span class="ot">&lt;-</span> <span class="fu">symdif</span>(z,Taiwan)</span>
<span id="cb79-2"><a href="#cb79-2" tabindex="-1"></a><span class="fu">plot</span>(dif, <span class="at">col=</span><span class="fu">rainbow</span>(<span class="fu">length</span>(dif)))</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-53-1.png" width="672" /></p>
</div>
<div id="spatial-queries" class="section level3">
<h3>Spatial queries</h3>
<p>We can query polygons with points (“point-in-polygon query”).</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a>pts <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">117</span>, <span class="dv">122</span>, <span class="dv">117</span>, <span class="dv">122</span>, <span class="dv">15</span>, <span class="dv">15</span>, <span class="dv">23</span>, <span class="dv">23</span>), <span class="at">ncol=</span><span class="dv">2</span>)</span>
<span id="cb80-2"><a href="#cb80-2" tabindex="-1"></a>spts <span class="ot">&lt;-</span> <span class="fu">vect</span>(pts, <span class="at">crs=</span><span class="fu">crs</span>(Taiwan))</span>
<span id="cb80-3"><a href="#cb80-3" tabindex="-1"></a><span class="fu">plot</span>(z, <span class="at">col=</span><span class="st">&#39;light blue&#39;</span>, <span class="at">lwd=</span><span class="dv">2</span>)</span>
<span id="cb80-4"><a href="#cb80-4" tabindex="-1"></a><span class="fu">points</span>(spts, <span class="at">col=</span><span class="st">&#39;light gray&#39;</span>, <span class="at">pch=</span><span class="dv">20</span>, <span class="at">cex=</span><span class="dv">6</span>)</span>
<span id="cb80-5"><a href="#cb80-5" tabindex="-1"></a><span class="fu">text</span>(spts, <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(pts), <span class="at">col=</span><span class="st">&#39;red&#39;</span>, <span class="at">font=</span><span class="dv">2</span>, <span class="at">cex=</span><span class="fl">1.5</span>)</span>
<span id="cb80-6"><a href="#cb80-6" tabindex="-1"></a><span class="fu">lines</span>(Taiwan, <span class="at">col=</span><span class="st">&#39;blue&#39;</span>, <span class="at">lwd=</span><span class="dv">2</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-54-1.png" width="672" /></p>
<p><code>extract</code> is used for queries between SpatVector and
SpatRaster objects, and also for queries between SpatVectors.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" tabindex="-1"></a><span class="fu">extract</span>(spts, Taiwan)</span></code></pre></div>
<pre><code>##       id.y id.x
##  [1,]    1  NaN
##  [2,]    2  NaN
##  [3,]    3  NaN
##  [4,]    4  NaN
##  [5,]    5  NaN
##  [6,]    6  NaN
##  [7,]    7  NaN
##  [8,]    8  NaN
##  [9,]    9  NaN
## [10,]   10  NaN
## [11,]   11  NaN
## [12,]   12  NaN
## [13,]   13  NaN
## [14,]   14  NaN
## [15,]   15  NaN
## [16,]   16  NaN
## [17,]   17  NaN
## [18,]   18  NaN
## [19,]   19  NaN
## [20,]   20  NaN
## [21,]   21  NaN
## [22,]   22  NaN</code></pre>
</div>
</div>
</div>
<div id="raster-data-manipulation" class="section level1">
<h1>Raster data manipulation</h1>
<p><code>terra</code> has a large number of functions, not all of them
are discussed here, and those that are discussed are mentioned only
briefly. See the help files of the package for more information on
individual functions and <code>help("terra-package")</code> for an index
of functions by topic.</p>
<div id="creating-spatraster-objects" class="section level2">
<h2>Creating SpatRaster objects</h2>
<p>A <code>SpatRaster</code> can easily be created from scratch using
the function <code>rast</code>. The default settings will create a
global raster data structure with a longitude/latitude coordinate
reference system and 1 by 1 degree cells. You can change these settings
by providing additional arguments such as <code>xmin</code>,
<code>nrow</code>, <code>ncol</code>, and/or <code>crs</code>, to the
function. You can also change these parameters after creating the
object. If you set the projection, this is only to properly define it,
not to change it. To transform a <code>SpatRaster</code> to another
coordinate reference system (projection) you can use the
<code>project</code> function.</p>
<p>Here is an example of creating and changing a SpatRaster object ‘r’
from scratch.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" tabindex="-1"></a><span class="fu">library</span> (terra)</span>
<span id="cb83-2"><a href="#cb83-2" tabindex="-1"></a>x<span class="ot">&lt;-</span><span class="fu">rast</span>()</span>
<span id="cb83-3"><a href="#cb83-3" tabindex="-1"></a>x</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 180, 360, 1  (nrow, ncol, nlyr)
## resolution  : 1, 1  (x, y)
## extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
## coord. ref. : lon/lat WGS 84</code></pre>
<p>with some other parameters</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="at">ncol=</span><span class="dv">36</span>, <span class="at">nrow=</span><span class="dv">18</span>, <span class="at">xmin=</span><span class="sc">-</span><span class="dv">1000</span>, <span class="at">xmax=</span><span class="dv">1000</span>, <span class="at">ymin=</span><span class="sc">-</span><span class="dv">100</span>, <span class="at">ymax=</span><span class="dv">900</span>)</span></code></pre></div>
<p>These parameters can be changed. Resolution:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a><span class="fu">res</span>(x)</span></code></pre></div>
<pre><code>## [1] 55.55556 55.55556</code></pre>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" tabindex="-1"></a><span class="fu">res</span>(x) <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb88-2"><a href="#cb88-2" tabindex="-1"></a><span class="fu">res</span>(x)</span></code></pre></div>
<pre><code>## [1] 100 100</code></pre>
<p>Change the number of columns (this affects the resolution).</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" tabindex="-1"></a><span class="fu">ncol</span>(x)</span></code></pre></div>
<pre><code>## [1] 20</code></pre>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" tabindex="-1"></a><span class="fu">ncol</span>(x) <span class="ot">&lt;-</span> <span class="dv">18</span></span>
<span id="cb92-2"><a href="#cb92-2" tabindex="-1"></a><span class="fu">ncol</span>(x)</span></code></pre></div>
<pre><code>## [1] 18</code></pre>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" tabindex="-1"></a><span class="fu">res</span>(x)</span></code></pre></div>
<pre><code>## [1] 111.1111 100.0000</code></pre>
<p>Set the coordinate reference system (CRS) (i.e., define the
projection).</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" tabindex="-1"></a><span class="fu">crs</span>(x) <span class="ot">&lt;-</span> <span class="st">&quot;+proj=utm +zone=48 +datum=WGS84&quot;</span></span>
<span id="cb96-2"><a href="#cb96-2" tabindex="-1"></a>x</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 10, 18, 1  (nrow, ncol, nlyr)
## resolution  : 111.1111, 100  (x, y)
## extent      : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=utm +zone=48 +datum=WGS84 +units=m +no_defs</code></pre>
<p>The object <code>x</code> created in the examples above only consists
of the raster <em>geometry</em>, that is, we have defined the number of
rows and columns, and where the raster is located in geographic space,
but there are no cell-values associated with it. Setting and accessing
values is illustrated below.</p>
<p>First another example empty raster geometry.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="at">ncol=</span><span class="dv">10</span>, <span class="at">nrow=</span><span class="dv">10</span>)</span>
<span id="cb98-2"><a href="#cb98-2" tabindex="-1"></a><span class="fu">ncell</span>(r)</span></code></pre></div>
<pre><code>## [1] 100</code></pre>
<div class="sourceCode" id="cb100"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" tabindex="-1"></a><span class="fu">hasValues</span>(r) <span class="co"># check if in-memory layers actually have cell values</span></span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>Use the <code>values</code> function.</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" tabindex="-1"></a><span class="fu">values</span>(r) <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">ncell</span>(r)</span></code></pre></div>
<p>Another example:</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">0</span>)</span>
<span id="cb103-2"><a href="#cb103-2" tabindex="-1"></a><span class="fu">values</span>(r) <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="fu">ncell</span>(r))</span>
<span id="cb103-3"><a href="#cb103-3" tabindex="-1"></a><span class="fu">hasValues</span>(r)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb105"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1" tabindex="-1"></a><span class="fu">sources</span>(r) <span class="co"># Get the data sources of a SpatRaster: Sources are either files (or similar resources) or &quot;&quot;, meaning that they are in memory. </span></span></code></pre></div>
<pre><code>## [1] &quot;&quot;</code></pre>
<div class="sourceCode" id="cb107"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" tabindex="-1"></a><span class="fu">values</span>(r)[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>]</span></code></pre></div>
<pre><code>##  [1] 0.8966972 0.2655087 0.3721239 0.5728534 0.9082078 0.2016819 0.8983897 0.9446753 0.6607978 0.6291140</code></pre>
<div class="sourceCode" id="cb109"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" tabindex="-1"></a><span class="fu">plot</span>(r, <span class="at">main=</span><span class="st">&#39;Raster with 100 cells&#39;</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-63-1.png" width="672" /></p>
<p>In some cases, for example when you change the number of columns or
rows, you will lose the values associated with the
<code>SpatRaster</code> if there were any (or the link to a file if
there was one). The same applies, in most cases, if you change the
resolution directly (as this can affect the number of rows or columns).
Values are not lost when changing the extent as this change adjusts the
resolution, but does not change the number of rows or columns.</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb110-1"><a href="#cb110-1" tabindex="-1"></a><span class="fu">hasValues</span>(r)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb112"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1" tabindex="-1"></a><span class="fu">res</span>(r)</span></code></pre></div>
<pre><code>## [1] 36 18</code></pre>
<div class="sourceCode" id="cb114"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1" tabindex="-1"></a><span class="fu">dim</span>(r)</span></code></pre></div>
<pre><code>## [1] 10 10  1</code></pre>
<div class="sourceCode" id="cb116"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1" tabindex="-1"></a><span class="fu">ext</span>(r)</span></code></pre></div>
<pre><code>## SpatExtent : -180, 180, -90, 90 (xmin, xmax, ymin, ymax)</code></pre>
<p>Now change the maximum x coordinate of the extent (bounding box) of
the <code>SpatRaster</code>.</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1" tabindex="-1"></a><span class="fu">xmax</span>(r) <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb118-2"><a href="#cb118-2" tabindex="-1"></a><span class="fu">hasValues</span>(r)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb120"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1" tabindex="-1"></a><span class="fu">res</span>(r)</span></code></pre></div>
<pre><code>## [1] 18 18</code></pre>
<div class="sourceCode" id="cb122"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1" tabindex="-1"></a><span class="fu">dim</span>(r)</span></code></pre></div>
<pre><code>## [1] 10 10  1</code></pre>
<p>And the number of columns (the values disappear)</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1" tabindex="-1"></a><span class="fu">ncol</span>(r) <span class="ot">&lt;-</span> <span class="dv">6</span></span>
<span id="cb124-2"><a href="#cb124-2" tabindex="-1"></a><span class="fu">hasValues</span>(r)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb126"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1" tabindex="-1"></a><span class="fu">res</span>(r)</span></code></pre></div>
<pre><code>## [1] 30 18</code></pre>
<div class="sourceCode" id="cb128"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1" tabindex="-1"></a><span class="fu">dim</span>(r)</span></code></pre></div>
<pre><code>## [1] 10  6  1</code></pre>
<div class="sourceCode" id="cb130"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1" tabindex="-1"></a><span class="fu">xmax</span>(r)</span></code></pre></div>
<pre><code>## [1] 0</code></pre>
<p>While we can create a <code>SpatRaster</code> from scratch, it is
more common to do so from a file. The <code>terra</code> package can use
raster files in several formats, including GeoTiff, ESRI, ENVI, and
ERDAS.</p>
<p>A notable feature of the <code>terra</code> package is that it can
work with raster datasets that are stored on disk and are too large to
be loaded into memory (RAM). The package can work with large files
because the objects it creates from these files only contain information
about the structure of the data, such as the number of rows and columns,
the spatial extent, and the filename, but it does not attempt to read
all the cell values in memory. In computations with these objects, data
is processed in chunks. If no output filename is specified to a
function, and the output raster is too large to keep in memory, the
results are written to a temporary file.</p>
<p>Below we first we get the name of an example raster file that is
installed with the <code>terra</code> package. Do not use this
system.file construction for your own files. Just type the file name as
you would do for any other file, but don’t forget to use forward slashes
as path separators.</p>
<div class="sourceCode" id="cb132"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb132-1"><a href="#cb132-1" tabindex="-1"></a>filename <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;ex/elev.tif&quot;</span>, <span class="at">package=</span><span class="st">&quot;terra&quot;</span>)</span>
<span id="cb132-2"><a href="#cb132-2" tabindex="-1"></a><span class="fu">basename</span>(filename)</span></code></pre></div>
<pre><code>## [1] &quot;elev.tif&quot;</code></pre>
<p>That’s teh file with the elevation of Luxembourg.</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb134-1"><a href="#cb134-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(filename)</span>
<span id="cb134-2"><a href="#cb134-2" tabindex="-1"></a><span class="fu">sources</span>(r)</span></code></pre></div>
<pre><code>## [1] &quot;C:/Users/Vianney Denis/AppData/Local/R/win-library/4.2/terra/ex/elev.tif&quot;</code></pre>
<div class="sourceCode" id="cb136"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb136-1"><a href="#cb136-1" tabindex="-1"></a><span class="fu">hasValues</span>(r)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb138"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb138-1"><a href="#cb138-1" tabindex="-1"></a><span class="fu">plot</span>(r, <span class="at">main=</span><span class="st">&quot;SpatRaster from file&quot;</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-68-1.png" width="672" /></p>
<p>An example with GeoTiff of Taiwan Population density (2015) available
<a
href="https://energydata.info/dataset/taiwan--population-density-2015/resource/ac982a4f-784b-4c9f-a124-8768556c89eb">here</a>.</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb139-1"><a href="#cb139-1" tabindex="-1"></a>tai.pop <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="st">&#39;./data/popmap15adj.tif&#39;</span>)</span>
<span id="cb139-2"><a href="#cb139-2" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb139-3"><a href="#cb139-3" tabindex="-1"></a><span class="co"># plot(tai.pop, main=&quot;Taiwan - Population Density (2015)&quot;)</span></span>
<span id="cb139-4"><a href="#cb139-4" tabindex="-1"></a><span class="co"># Need a log transformaton</span></span>
<span id="cb139-5"><a href="#cb139-5" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">log</span>(tai.pop<span class="sc">+</span><span class="dv">1</span>), <span class="at">main=</span><span class="st">&quot;Taiwan - log-transformed Population Density (2015)&quot;</span>)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-69-1.png" width="672" /></p>
<p>We can also use our previous SpatRaster of elevation of Taiwan in a
nicer map:</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb140-1"><a href="#cb140-1" tabindex="-1"></a><span class="fu">library</span>(geodata)</span>
<span id="cb140-2"><a href="#cb140-2" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb140-3"><a href="#cb140-3" tabindex="-1"></a><span class="fu">library</span>(ggspatial)</span>
<span id="cb140-4"><a href="#cb140-4" tabindex="-1"></a>ele <span class="ot">&lt;-</span><span class="fu">elevation_30s</span>(<span class="st">&quot;TWN&quot;</span>, <span class="at">path=</span><span class="fu">tempdir</span>())</span>
<span id="cb140-5"><a href="#cb140-5" tabindex="-1"></a><span class="fu">ggplot</span>()<span class="sc">+</span></span>
<span id="cb140-6"><a href="#cb140-6" tabindex="-1"></a>  <span class="fu">layer_spatial</span>(ele)<span class="sc">+</span></span>
<span id="cb140-7"><a href="#cb140-7" tabindex="-1"></a>  <span class="fu">scale_fill_continuous</span>(<span class="at">na.value =</span> <span class="st">&#39;transparent&#39;</span>, <span class="at">name=</span><span class="st">&#39;Elevation (m)&#39;</span>)<span class="sc">+</span></span>
<span id="cb140-8"><a href="#cb140-8" tabindex="-1"></a>  ggspatial<span class="sc">::</span><span class="fu">annotation_north_arrow</span>(</span>
<span id="cb140-9"><a href="#cb140-9" tabindex="-1"></a>    <span class="at">location =</span> <span class="st">&quot;tl&quot;</span>, <span class="at">which_north =</span> <span class="st">&quot;true&quot;</span>,</span>
<span id="cb140-10"><a href="#cb140-10" tabindex="-1"></a>    <span class="at">style =</span> ggspatial<span class="sc">::</span><span class="fu">north_arrow_nautical</span>(<span class="at">fill =</span> <span class="fu">c</span>(<span class="st">&quot;grey40&quot;</span>, <span class="st">&quot;white&quot;</span>), <span class="at">line_col =</span> <span class="st">&quot;grey20&quot;</span>))<span class="sc">+</span></span>
<span id="cb140-11"><a href="#cb140-11" tabindex="-1"></a>  ggspatial<span class="sc">::</span><span class="fu">annotation_scale</span> () <span class="sc">+</span></span>
<span id="cb140-12"><a href="#cb140-12" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-70-1.png" width="672" /></p>
<p>Multi-layer objects can be created in memory or from files.</p>
<p>Create three identical <code>SpatRaster</code> objects:</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb141-1"><a href="#cb141-1" tabindex="-1"></a>r1 <span class="ot">&lt;-</span> r2 <span class="ot">&lt;-</span> r3 <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="at">nrow=</span><span class="dv">10</span>, <span class="at">ncol=</span><span class="dv">10</span>)</span>
<span id="cb141-2"><a href="#cb141-2" tabindex="-1"></a><span class="co"># Assign random cell values</span></span>
<span id="cb141-3"><a href="#cb141-3" tabindex="-1"></a><span class="fu">values</span>(r1) <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="fu">ncell</span>(r1))</span>
<span id="cb141-4"><a href="#cb141-4" tabindex="-1"></a><span class="fu">values</span>(r2) <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="fu">ncell</span>(r2))</span>
<span id="cb141-5"><a href="#cb141-5" tabindex="-1"></a><span class="fu">values</span>(r3) <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="fu">ncell</span>(r3))</span></code></pre></div>
<p>Combine three <code>SpatRaster</code>:</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1" tabindex="-1"></a>s <span class="ot">&lt;-</span> <span class="fu">c</span>(r1, r2, r3)</span>
<span id="cb142-2"><a href="#cb142-2" tabindex="-1"></a>s</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 10, 10, 3  (nrow, ncol, nlyr)
## resolution  : 36, 18  (x, y)
## extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
## coord. ref. : lon/lat WGS 84 
## source(s)   : memory
## names       :      lyr.1,      lyr.1,      lyr.1 
## min values  : 0.01307758, 0.02778712, 0.06380247 
## max values  : 0.99268406, 0.98156346, 0.99607737</code></pre>
<div class="sourceCode" id="cb144"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb144-1"><a href="#cb144-1" tabindex="-1"></a><span class="fu">nlyr</span>(s)</span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<p>You can also create a multilayer object from a file.</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1" tabindex="-1"></a>filename <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;ex/logo.tif&quot;</span>, <span class="at">package=</span><span class="st">&quot;terra&quot;</span>)</span>
<span id="cb146-2"><a href="#cb146-2" tabindex="-1"></a><span class="fu">basename</span>(filename)</span></code></pre></div>
<pre><code>## [1] &quot;logo.tif&quot;</code></pre>
<div class="sourceCode" id="cb148"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb148-1"><a href="#cb148-1" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">rast</span>(filename)</span>
<span id="cb148-2"><a href="#cb148-2" tabindex="-1"></a>b</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 77, 101, 3  (nrow, ncol, nlyr)
## resolution  : 1, 1  (x, y)
## extent      : 0, 101, 0, 77  (xmin, xmax, ymin, ymax)
## coord. ref. : Cartesian (Meter) 
## source      : logo.tif 
## colors RGB  : 1, 2, 3 
## names       : red, green, blue 
## min values  :   0,     0,    0 
## max values  : 255,   255,  255</code></pre>
<div class="sourceCode" id="cb150"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb150-1"><a href="#cb150-1" tabindex="-1"></a><span class="fu">nlyr</span>(b)</span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<p>Extract a single layer (the second one on this case)</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb152-1"><a href="#cb152-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> b[[<span class="dv">2</span>]]</span></code></pre></div>
</div>
<div id="raster-algebra-extra" class="section level2">
<h2>Raster algebra (extra)</h2>
<p>Many generic functions that allow for simple and elegant raster
algebra have been implemented for Raster objects, including the normal
algebraic operators such as <code>+</code>, <code>-</code>,
<code>*</code>, <code>/</code>, logical operators such as
<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>,
<code>==</code>, <code>!</code> and functions like <code>abs</code>,
<code>round</code>, <code>ceiling</code>, <code>floor</code>,
<code>trunc</code>, <code>sqrt</code>, <code>log</code>,
<code>log10</code>, <code>exp</code>, <code>cos</code>,
<code>sin</code>, <code>atan</code>, <code>tan</code>, <code>max</code>,
<code>min</code>, <code>range</code>, <code>prod</code>,
<code>sum</code>, <code>any</code>, <code>all</code>. In these functions
you can mix raster objects with numbers, as long as the first argument
is a raster object.</p>
<p>Create an empty <code>SpatRaster</code> and assign values to
cells.</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb153-1"><a href="#cb153-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="at">ncol=</span><span class="dv">10</span>, <span class="at">nrow=</span><span class="dv">10</span>)</span>
<span id="cb153-2"><a href="#cb153-2" tabindex="-1"></a><span class="fu">values</span>(r) <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">ncell</span>(r)</span></code></pre></div>
<p>Now some raster algebra.</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb154-1"><a href="#cb154-1" tabindex="-1"></a>s <span class="ot">&lt;-</span> r <span class="sc">+</span> <span class="dv">10</span></span>
<span id="cb154-2"><a href="#cb154-2" tabindex="-1"></a>s <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(s)</span>
<span id="cb154-3"><a href="#cb154-3" tabindex="-1"></a>s <span class="ot">&lt;-</span> s <span class="sc">*</span> r <span class="sc">+</span> <span class="dv">5</span></span>
<span id="cb154-4"><a href="#cb154-4" tabindex="-1"></a><span class="fu">values</span>(r) <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="fu">ncell</span>(r))</span>
<span id="cb154-5"><a href="#cb154-5" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">round</span>(r)</span>
<span id="cb154-6"><a href="#cb154-6" tabindex="-1"></a>r <span class="ot">&lt;-</span> r <span class="sc">==</span> <span class="dv">1</span></span></code></pre></div>
<p>You can also use replacement functions.</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb155-1"><a href="#cb155-1" tabindex="-1"></a><span class="co">#Not yet implemented</span></span>
<span id="cb155-2"><a href="#cb155-2" tabindex="-1"></a>s[r] <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fl">0.5</span></span>
<span id="cb155-3"><a href="#cb155-3" tabindex="-1"></a>s[<span class="sc">!</span>r] <span class="ot">&lt;-</span> <span class="dv">5</span></span>
<span id="cb155-4"><a href="#cb155-4" tabindex="-1"></a>s[s <span class="sc">==</span> <span class="dv">5</span>] <span class="ot">&lt;-</span> <span class="dv">15</span></span></code></pre></div>
<p>If you use multiple <code>SpatRaster</code> objects (in functions
where this is relevant, such as range), these must have the same
resolution and origin. The origin of a <code>Raster</code> object is the
point closest to (0, 0) that you could get if you moved from a corner of
a <code>SpatRaster</code> toward that point in steps of the x and y
resolution. Normally these objects would also have the same extent, but
if they do not, the returned object covers the spatial intersection of
the objects used.</p>
<p>When you use multiple multi-layer objects with different numbers or
layers, the ‘shorter’ objects are ‘recycled’. For example, if you
multiply a 4-layer object (<code>a1</code>, <code>a2</code>,
<code>a3</code>, <code>a4</code>) with a 2-layer object
(<code>b1</code>, <code>b2</code>), the result is a four-layer object
(<code>a1*b1</code>, <code>a2*b2</code>, <code>a3*b1</code>,
<code>a3*b2</code>).</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb156-1"><a href="#cb156-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="at">ncol=</span><span class="dv">5</span>, <span class="at">nrow=</span><span class="dv">5</span>)</span>
<span id="cb156-2"><a href="#cb156-2" tabindex="-1"></a><span class="fu">values</span>(r) <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb156-3"><a href="#cb156-3" tabindex="-1"></a>s <span class="ot">&lt;-</span> <span class="fu">c</span>(r, r<span class="sc">+</span><span class="dv">1</span>)</span>
<span id="cb156-4"><a href="#cb156-4" tabindex="-1"></a>q <span class="ot">&lt;-</span> <span class="fu">c</span>(r, r<span class="sc">+</span><span class="dv">2</span>, r<span class="sc">+</span><span class="dv">4</span>, r<span class="sc">+</span><span class="dv">6</span>)</span>
<span id="cb156-5"><a href="#cb156-5" tabindex="-1"></a>x <span class="ot">&lt;-</span> r <span class="sc">+</span> s <span class="sc">+</span> q</span>
<span id="cb156-6"><a href="#cb156-6" tabindex="-1"></a>x</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 5, 5, 4  (nrow, ncol, nlyr)
## resolution  : 72, 36  (x, y)
## extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
## coord. ref. : lon/lat WGS 84 
## source(s)   : memory
## names       : lyr1, lyr2, lyr3, lyr4 
## min values  :    3,    6,    7,   10 
## max values  :    3,    6,    7,   10</code></pre>
<p>Summary functions (<code>min</code>, <code>max</code>,
<code>mean</code>, <code>prod</code>, <code>sum</code>,
<code>median</code>, <code>cv</code>, <code>range</code>,
<code>any</code>, <code>all</code>) always return a
<code>SpatRaster</code> object. Perhaps this is not obvious when using
functions like <code>min</code>, <code>sum</code> or
<code>mean</code>.</p>
<div class="sourceCode" id="cb158"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb158-1"><a href="#cb158-1" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">mean</span>(r,s,<span class="dv">10</span>)</span>
<span id="cb158-2"><a href="#cb158-2" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">sum</span>(r,s)</span>
<span id="cb158-3"><a href="#cb158-3" tabindex="-1"></a>st <span class="ot">&lt;-</span> <span class="fu">c</span>(r, s, a, b)</span>
<span id="cb158-4"><a href="#cb158-4" tabindex="-1"></a>sst <span class="ot">&lt;-</span> <span class="fu">sum</span>(st)</span>
<span id="cb158-5"><a href="#cb158-5" tabindex="-1"></a>sst</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 5, 5, 1  (nrow, ncol, nlyr)
## resolution  : 72, 36  (x, y)
## extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
## coord. ref. : lon/lat WGS 84 
## source(s)   : memory
## name        :      sum 
## min value   : 17.33333 
## max value   : 17.33333</code></pre>
<p>Use <code>global</code> if you want a single number summarizing the
cell values of each layer.</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb160-1"><a href="#cb160-1" tabindex="-1"></a><span class="fu">global</span>(st, <span class="st">&#39;sum&#39;</span>)</span></code></pre></div>
<pre><code>##              sum
## lyr.1    25.0000
## lyr.1.1  25.0000
## lyr.1.2  50.0000
## lyr1    100.0000
## lyr2    108.3333
## lyr1.1   50.0000
## lyr2.1   75.0000</code></pre>
</div>
<div id="high-level-functions-extra" class="section level2">
<h2>‘High-level’ functions (extra)</h2>
<p>Several ‘high level’ functions have been implemented for
<code>SpatRaster</code> objects. ‘High level’ functions refer to
functions that you would normally find in a computer program that
supports the analysis of raster data. Here we briefly discuss some of
these functions. All these functions work for raster datasets that
cannot be loaded into memory. See the help files for more detailed
descriptions of each function.</p>
<p>The high-level functions have some arguments in common. The first
argument is typically a <code>SpatRaster</code> ‘x’ or ‘object’. It is
followed by one or more arguments specific to the function (either
additional <code>SpatRaster</code> objects or other arguments), followed
by <code>filename</code> and <code>...</code> arguments.</p>
<p>The default filename is an empty character <code>""</code>. If you do
not specify a filename, the default action for the function is to return
a <code>raster</code> object that only exists in memory. However, if the
function deems that the <code>raster</code> object to be created would
be too large to hold in memory, it is written to a temporary file
instead.</p>
<p>The <code>...</code> argument allows for setting additional arguments
that are relevant when writing values to a file: the file format,
datatype (e.g. integer or real values), and a to indicate whether
existing files should be overwritten.</p>
<div id="modifying-a-spatraster-object" class="section level3">
<h3>Modifying a SpatRaster object</h3>
<p>There are several functions that deal with modifying the spatial
extent of <code>SpatRaster</code> objects. The <code>crop</code>
function lets you take a geographic subset of a larger
<code>raster</code> object. You can crop a <code>SpatRaster</code> by
providing an extent object or another spatial object from which an
extent can be extracted (objects from classes deriving from
<code>Raster</code> and from <code>Spatial</code> in the <code>sp</code>
package). An easy way to get an extent object is to plot a
<code>SpatRaster</code> and then use <code>drawExtent</code> to visually
determine the new extent (bounding box) to provide to the crop
function.</p>
<p><code>trim</code> crops a <code>SpatRaster</code> by removing the
outer rows and columns that only contain <code>NA</code> values. In
contrast, <code>extend</code> adds new rows and/or columns with
<code>NA</code> values. The purpose of this could be to create a new
<code>SpatRaster</code> with the same Extent of another, larger,
<code>SpatRaster</code> such that they can be used together in other
functions.</p>
<p>The <code>merge</code> function lets you merge 2 or more SpatRaster
objects into a single new object. The input objects must have the same
resolution and origin (such that their cells neatly fit into a single
larger raster). If this is not the case you can first adjust one of the
SpatRaster objects with <code>aggregate</code>/<code>disagg</code> or
<code>resample</code>.</p>
<p><code>aggregate</code> and <code>disagg</code> allow for changing the
resolution (cell size) of a SpatRaster object. In the case of aggregate,
you need to specify a function determining what to do with the grouped
cell values mean. It is possible to specify different (dis)aggregation
factors in the x and y direction. <code>aggregate</code> and
<code>disagg</code> are the best functions when adjusting cells size
only, with an integer step (e.g. each side 2 times smaller or larger),
but in some cases that is not possible.</p>
<p>For example, you may need nearly the same cell size, while shifting
the cell centers. In those cases, the <code>resample</code> function can
be used. It can do either nearest neighbor assignments (for categorical
data) or bilinear interpolation (for numerical data). Simple linear
shifts of a Raster object can be accomplished with the
<code>shift</code> function or with the <code>extent</code>
function.</p>
<p>With the <code>warp</code> function you can transform values of
<code>SpatRaster</code> object to a new object with a different
coordinate reference system.</p>
<p>Here are some simple examples.</p>
<p>Aggregate and disaggregate.</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb162-1"><a href="#cb162-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>()</span>
<span id="cb162-2"><a href="#cb162-2" tabindex="-1"></a><span class="fu">values</span>(r) <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">ncell</span>(r)</span>
<span id="cb162-3"><a href="#cb162-3" tabindex="-1"></a>ra <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(r, <span class="dv">20</span>)</span>
<span id="cb162-4"><a href="#cb162-4" tabindex="-1"></a>rd <span class="ot">&lt;-</span> <span class="fu">disagg</span>(ra, <span class="dv">20</span>)</span></code></pre></div>
<p>Crop and merge example.</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb163-1"><a href="#cb163-1" tabindex="-1"></a>r1 <span class="ot">&lt;-</span> <span class="fu">crop</span>(r, <span class="fu">ext</span>(<span class="sc">-</span><span class="dv">50</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">30</span>))</span>
<span id="cb163-2"><a href="#cb163-2" tabindex="-1"></a>r2 <span class="ot">&lt;-</span> <span class="fu">crop</span>(r, <span class="fu">ext</span>(<span class="sc">-</span><span class="dv">10</span>,<span class="dv">50</span>,<span class="sc">-</span><span class="dv">20</span>, <span class="dv">10</span>))</span>
<span id="cb163-3"><a href="#cb163-3" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="fu">merge</span>(r1, r2, <span class="at">filename=</span><span class="st">&quot;test.tif&quot;</span>, <span class="at">overwrite=</span><span class="cn">TRUE</span>)</span>
<span id="cb163-4"><a href="#cb163-4" tabindex="-1"></a><span class="fu">plot</span>(m)</span></code></pre></div>
<p><img src="maps_files/figure-html/unnamed-chunk-82-1.png" width="672" /></p>
<p><code>flip</code> lets you flip the data (reverse order) in
horizontal or vertical direction – typically to correct for a
‘communication problem’ between different R packages or a misinterpreted
file. <code>rotate</code> lets you rotate longitude/latitude rasters
that have longitudes from 0 to 360 degrees (often used by
climatologists) to the standard -180 to 180 degrees system. With
<code>t</code> you can rotate a <code>SpatRaster</code> object 90
degrees.</p>
</div>
<div id="overlay-1" class="section level3">
<h3>Overlay</h3>
<p><code>app</code> (short for “apply”) allows you to do a computation
for a single <code>SpatRaster</code> object by providing a function,
e.g. sum.</p>
<p>The <code>lapp</code> (layer-apply) function can be used as an
alternative to the raster algebra discussed above.</p>
</div>
<div id="classify" class="section level3">
<h3>Classify</h3>
<p>You can use <code>classify</code> to replace ranges of values with
single values, or to substitute (replace) single values with other
values.</p>
<div class="sourceCode" id="cb164"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb164-1"><a href="#cb164-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="at">ncol=</span><span class="dv">3</span>, <span class="at">nrow=</span><span class="dv">2</span>)</span>
<span id="cb164-2"><a href="#cb164-2" tabindex="-1"></a><span class="fu">values</span>(r) <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">ncell</span>(r)</span>
<span id="cb164-3"><a href="#cb164-3" tabindex="-1"></a><span class="fu">values</span>(r)</span></code></pre></div>
<pre><code>##      lyr.1
## [1,]     1
## [2,]     2
## [3,]     3
## [4,]     4
## [5,]     5
## [6,]     6</code></pre>
<p>Set all values above 4 to <code>NA</code></p>
<div class="sourceCode" id="cb166"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb166-1"><a href="#cb166-1" tabindex="-1"></a>s <span class="ot">&lt;-</span> <span class="fu">app</span>(r, <span class="at">fun=</span><span class="cf">function</span>(x){ x[x <span class="sc">&lt;</span> <span class="dv">4</span>] <span class="ot">&lt;-</span> <span class="cn">NA</span>; <span class="fu">return</span>(x)} )</span>
<span id="cb166-2"><a href="#cb166-2" tabindex="-1"></a><span class="fu">as.matrix</span>(s)</span></code></pre></div>
<pre><code>##      lyr.1
## [1,]    NA
## [2,]    NA
## [3,]    NA
## [4,]     4
## [5,]     5
## [6,]     6</code></pre>
<p>Divide the first raster with two times the square root of the second
raster and add five.</p>
<div class="sourceCode" id="cb168"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb168-1"><a href="#cb168-1" tabindex="-1"></a>rs <span class="ot">&lt;-</span> <span class="fu">c</span>(r, s)</span>
<span id="cb168-2"><a href="#cb168-2" tabindex="-1"></a>w <span class="ot">&lt;-</span> <span class="fu">lapp</span>(rs, <span class="at">fun=</span><span class="cf">function</span>(x, y){ x <span class="sc">/</span> (<span class="dv">2</span> <span class="sc">*</span> <span class="fu">sqrt</span>(y)) <span class="sc">+</span> <span class="dv">5</span> } )</span>
<span id="cb168-3"><a href="#cb168-3" tabindex="-1"></a><span class="fu">as.matrix</span>(w)</span></code></pre></div>
<pre><code>##          lyr1
## [1,]       NA
## [2,]       NA
## [3,]       NA
## [4,] 6.000000
## [5,] 6.118034
## [6,] 6.224745</code></pre>
<p>Remove from r all values that are NA in w.</p>
<div class="sourceCode" id="cb170"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb170-1"><a href="#cb170-1" tabindex="-1"></a>u <span class="ot">&lt;-</span> <span class="fu">mask</span>(r, w)</span>
<span id="cb170-2"><a href="#cb170-2" tabindex="-1"></a><span class="fu">as.matrix</span>(u)</span></code></pre></div>
<pre><code>##      lyr.1
## [1,]    NA
## [2,]    NA
## [3,]    NA
## [4,]     4
## [5,]     5
## [6,]     6</code></pre>
<p>Identify the cell values in <code>u</code> that are the same as in
<code>s</code>.</p>
<div class="sourceCode" id="cb172"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb172-1"><a href="#cb172-1" tabindex="-1"></a>v <span class="ot">&lt;-</span> u<span class="sc">==</span>s</span>
<span id="cb172-2"><a href="#cb172-2" tabindex="-1"></a><span class="fu">as.matrix</span>(v)</span></code></pre></div>
<pre><code>##      lyr.1
## [1,]    NA
## [2,]    NA
## [3,]    NA
## [4,]  TRUE
## [5,]  TRUE
## [6,]  TRUE</code></pre>
<p>Replace <code>NA</code> values in w with values of
<code>r</code>.</p>
<div class="sourceCode" id="cb174"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb174-1"><a href="#cb174-1" tabindex="-1"></a>cvr <span class="ot">&lt;-</span> <span class="fu">cover</span>(w, r)</span>
<span id="cb174-2"><a href="#cb174-2" tabindex="-1"></a><span class="fu">as.matrix</span>(w)</span></code></pre></div>
<pre><code>##          lyr1
## [1,]       NA
## [2,]       NA
## [3,]       NA
## [4,] 6.000000
## [5,] 6.118034
## [6,] 6.224745</code></pre>
<p>Change value between 0 and 2 to 1, etc.</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb176-1"><a href="#cb176-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">classify</span>(w, <span class="fu">rbind</span>(<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">1</span>),  <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">2</span>), <span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">10</span>,<span class="dv">3</span>)))</span>
<span id="cb176-2"><a href="#cb176-2" tabindex="-1"></a><span class="fu">as.matrix</span>(x)</span></code></pre></div>
<pre><code>##      lyr1
## [1,]  NaN
## [2,]  NaN
## [3,]  NaN
## [4,]    3
## [5,]    3
## [6,]    3</code></pre>
<p>Substitute 2 with 40 and 3 with 50.</p>
<div class="sourceCode" id="cb178"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb178-1"><a href="#cb178-1" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">classify</span>(x, <span class="fu">cbind</span>(<span class="at">id=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">3</span>), <span class="at">v=</span><span class="fu">c</span>(<span class="dv">40</span>,<span class="dv">50</span>)))</span>
<span id="cb178-2"><a href="#cb178-2" tabindex="-1"></a><span class="fu">as.matrix</span>(y)</span></code></pre></div>
<pre><code>##      lyr1
## [1,]  NaN
## [2,]  NaN
## [3,]  NaN
## [4,]   50
## [5,]   50
## [6,]   50</code></pre>
</div>
<div id="focal-methods" class="section level3">
<h3>Focal methods</h3>
<p>The <code>focal</code> methods computate new values based on the
values in a neighborhood of cells around a focal cell, and putting the
result in the focal cell of the output SpatRaster. The neighborhood is a
user-defined matrix of weights and could approximate any shape by giving
some cells zero weight. It is possible to only computes new values for
cells that are <code>NA</code> in the input SpatRaster.</p>
</div>
<div id="distance" class="section level3">
<h3>Distance</h3>
<p>There are a number of distance related functions. For example, you
can compute the shortest distance to cells that are not <code>NA</code>,
the shortest distance to any point in a set of points, or the distance
when following grid cells that can be traversed (e.g. excluding water
bodies). <code>direction</code> computes the direction toward (or from)
the nearest cell that is not <code>NA</code>. <code>adjacency</code>
determines which cells are adjacent to other cells. See the
<code>gdistance</code> package for more advanced distance calculations
(cost distance, resistance distance).</p>
</div>
<div id="spatial-configuration" class="section level3">
<h3>Spatial configuration</h3>
<p><code>patches</code> identifies groups of cells that are connected.
<code>boundaries</code> identifies edges, that is, transitions between
cell values. <code>zonal</code> computes the size of each grid cell (for
unprojected rasters), this may be useful to, e.g. compute the area
covered by a certain class on a longitude/latitude raster.</p>
<div class="sourceCode" id="cb180"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb180-1"><a href="#cb180-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="at">nrow=</span><span class="dv">45</span>, <span class="at">ncol=</span><span class="dv">90</span>)</span>
<span id="cb180-2"><a href="#cb180-2" tabindex="-1"></a><span class="fu">values</span>(r) <span class="ot">&lt;-</span> <span class="fu">round</span>(<span class="fu">runif</span>(<span class="fu">ncell</span>(r))<span class="sc">*</span><span class="dv">3</span>)</span>
<span id="cb180-3"><a href="#cb180-3" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">cellSize</span>(r)</span>
<span id="cb180-4"><a href="#cb180-4" tabindex="-1"></a><span class="fu">zonal</span>(a, r, <span class="st">&quot;sum&quot;</span>)</span></code></pre></div>
<pre><code>##   lyr.1         area
## 1     0 9.391452e+13
## 2     1 1.694339e+14
## 3     2 1.586069e+14
## 4     3 8.811029e+13</code></pre>
</div>
<div id="predictions" class="section level3">
<h3>Predictions</h3>
<p>The <code>terra</code> package has two functions to make model
predictions to (potentially very large) rasters. predict takes a
multilayer raster and a fitted model as arguments. Fitted models can be
of various classes, including glm, gam, and RandomForest. The function
<code>interpolate</code> is similar but is for models that use
coordinates as predictor variables, for example in Kriging and spline
interpolation.</p>
</div>
<div id="vector-to-raster-conversion" class="section level3">
<h3>Vector to raster conversion</h3>
<p>The <code>terra</code> package supports point, line, and polygon to
raster conversion with the <code>rasterize</code> function. For vector
type data (points, lines, polygons), <code>SpatVector</code> objects are
used; but points can also be represented by a two-column matrix (x and
y).</p>
<p>Point to raster conversion is often done with the purpose to analyze
the point data. For example to count the number of distinct species
(represented by point observations) that occur in each raster cell.
<code>rasterize</code> takes a <code>SpatRaster</code> object to set the
spatial extent and resolution, and a function to determine how to
summarize the points (or an attribute of each point) by cell.</p>
<p>Polygon to raster conversion is typically done to create a
<code>SpatRaster</code> that can act as a mask, i.e. to set to
<code>NA</code> a set of cells of a <code>SpatRaster</code> object, or
to summarize values on a raster by zone. For example a country polygon
is transferred to a raster that is then used to set all the cells
outside that country to <code>NA</code>; whereas polygons representing
administrative regions such as states can be transferred to a raster to
summarize raster values by region.</p>
<p>It is also possible to convert the values of a
<code>SpatRaster</code> to points or polygons, using
<code>as.points</code> and <code>as.polygons</code>. Both functions only
return values for cells that are not NA.</p>
</div>
</div>
<div id="summarizing-functions-extra" class="section level2">
<h2>Summarizing functions (extra)</h2>
<p>When used with a <code>SpatRaster</code> object as first argument,
normal summary statistics functions such as <code>min</code>,
<code>max</code> and <code>mean</code> return a <code>SpatRaster</code>.
You can use <code>global</code> if, instead, you want to obtain a
summary for all cells of a single <code>SpatRaster</code> object. You
can use <code>freq</code> to make a frequency table, or to count the
number of cells with a specified value. Use <code>zonal</code> to
summarize a SpatRaster object using zones (areas with the same integer
number) defined in a <code>SpatRaster</code> and <code>crosstab</code>
to cross-tabulate two <code>SpatRaster</code> objects.</p>
<div class="sourceCode" id="cb182"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb182-1"><a href="#cb182-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="at">ncol=</span><span class="dv">36</span>, <span class="at">nrow=</span><span class="dv">18</span>)</span>
<span id="cb182-2"><a href="#cb182-2" tabindex="-1"></a><span class="fu">values</span>(r) <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="fu">ncell</span>(r))</span>
<span id="cb182-3"><a href="#cb182-3" tabindex="-1"></a><span class="fu">global</span>(r, mean)</span></code></pre></div>
<pre><code>##            mean
## lyr.1 0.5179682</code></pre>
<p>Zonal stats, below <code>r</code> has the cells we want to summarize,
<code>s</code> defines the zones, and the last argument is the function
to summarize the values of <code>r</code> for each zone in
<code>s</code>.</p>
<div class="sourceCode" id="cb184"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb184-1"><a href="#cb184-1" tabindex="-1"></a>s <span class="ot">&lt;-</span> r</span>
<span id="cb184-2"><a href="#cb184-2" tabindex="-1"></a><span class="fu">values</span>(s) <span class="ot">&lt;-</span> <span class="fu">round</span>(<span class="fu">runif</span>(<span class="fu">ncell</span>(r)) <span class="sc">*</span> <span class="dv">5</span>)</span>
<span id="cb184-3"><a href="#cb184-3" tabindex="-1"></a><span class="fu">zonal</span>(r, s, <span class="st">&#39;mean&#39;</span>)</span></code></pre></div>
<pre><code>##   lyr.1   lyr.1.1
## 1     0 0.5144431
## 2     1 0.5480089
## 3     2 0.5249257
## 4     3 0.5194031
## 5     4 0.4853966
## 6     5 0.5218401</code></pre>
<p>Count cells</p>
<div class="sourceCode" id="cb186"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb186-1"><a href="#cb186-1" tabindex="-1"></a><span class="fu">freq</span>(s)</span></code></pre></div>
<pre><code>##   layer value count
## 1     1     0    54
## 2     1     1   102
## 3     1     2   139
## 4     1     3   148
## 5     1     4   133
## 6     1     5    72</code></pre>
<div class="sourceCode" id="cb188"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb188-1"><a href="#cb188-1" tabindex="-1"></a><span class="fu">freq</span>(s, <span class="at">value=</span><span class="dv">3</span>)</span></code></pre></div>
<pre><code>##   layer value count
## 1     1     3   148</code></pre>
<p>Cross-tabulate</p>
<div class="sourceCode" id="cb190"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb190-1"><a href="#cb190-1" tabindex="-1"></a>ctb <span class="ot">&lt;-</span> <span class="fu">crosstab</span>(<span class="fu">c</span>(r<span class="sc">*</span><span class="dv">3</span>, s))</span>
<span id="cb190-2"><a href="#cb190-2" tabindex="-1"></a><span class="fu">head</span>(ctb)</span></code></pre></div>
<pre><code>##      lyr.1.1
## lyr.1  0  1  2  3  4  5
##     0  8 13 21 16 24 10
##     1 17 31 42 56 45 24
##     2 19 31 52 54 37 27
##     3 10 27 24 22 27 11</code></pre>
</div>
<div id="helper-functions" class="section level2">
<h2>Helper functions</h2>
<p>The cell number is an important concept in the terra package. Raster
data can be thought of as a matrix, but in a <code>SpatRaster</code> it
is more commonly treated as a vector. Cells are numbered from the upper
left cell to the upper right cell and then continuing on the left side
of the next row, and so on until the last cell at the lower right side
of the raster. There are several helper functions to determine the
column or row number from a cell and vice versa, and to determine the
cell number for x, y coordinates and vice versa.</p>
<div class="sourceCode" id="cb192"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb192-1"><a href="#cb192-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="at">ncol=</span><span class="dv">36</span>, <span class="at">nrow=</span><span class="dv">18</span>)</span>
<span id="cb192-2"><a href="#cb192-2" tabindex="-1"></a><span class="fu">ncol</span>(r)</span></code></pre></div>
<pre><code>## [1] 36</code></pre>
<div class="sourceCode" id="cb194"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb194-1"><a href="#cb194-1" tabindex="-1"></a><span class="fu">nrow</span>(r)</span></code></pre></div>
<pre><code>## [1] 18</code></pre>
<div class="sourceCode" id="cb196"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb196-1"><a href="#cb196-1" tabindex="-1"></a><span class="fu">ncell</span>(r)</span></code></pre></div>
<pre><code>## [1] 648</code></pre>
<div class="sourceCode" id="cb198"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb198-1"><a href="#cb198-1" tabindex="-1"></a><span class="fu">rowFromCell</span>(r, <span class="dv">100</span>)</span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<div class="sourceCode" id="cb200"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb200-1"><a href="#cb200-1" tabindex="-1"></a><span class="fu">colFromCell</span>(r, <span class="dv">100</span>)</span></code></pre></div>
<pre><code>## [1] 28</code></pre>
<div class="sourceCode" id="cb202"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb202-1"><a href="#cb202-1" tabindex="-1"></a><span class="fu">cellFromRowCol</span>(r,<span class="dv">5</span>,<span class="dv">5</span>)</span></code></pre></div>
<pre><code>## [1] 149</code></pre>
<div class="sourceCode" id="cb204"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb204-1"><a href="#cb204-1" tabindex="-1"></a><span class="fu">xyFromCell</span>(r, <span class="dv">100</span>)</span></code></pre></div>
<pre><code>##       x  y
## [1,] 95 65</code></pre>
<div class="sourceCode" id="cb206"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb206-1"><a href="#cb206-1" tabindex="-1"></a><span class="fu">cellFromXY</span>(r, <span class="fu">cbind</span>(<span class="dv">0</span>,<span class="dv">0</span>))</span></code></pre></div>
<pre><code>## [1] 343</code></pre>
<div class="sourceCode" id="cb208"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb208-1"><a href="#cb208-1" tabindex="-1"></a><span class="fu">colFromX</span>(r, <span class="dv">0</span>)</span></code></pre></div>
<pre><code>## [1] 19</code></pre>
<div class="sourceCode" id="cb210"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb210-1"><a href="#cb210-1" tabindex="-1"></a><span class="fu">rowFromY</span>(r, <span class="dv">0</span>)</span></code></pre></div>
<pre><code>## [1] 10</code></pre>
</div>
<div id="accessing-cell-values" class="section level2">
<h2>Accessing cell values</h2>
<p>Cell values can be accessed with several methods. Use
<code>values</code> to get all values or a subset such as a single row
or a block (rectangle) of cell values.</p>
<div class="sourceCode" id="cb212"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb212-1"><a href="#cb212-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="fu">system.file</span>(<span class="st">&quot;ex/elev.tif&quot;</span>, <span class="at">package=</span><span class="st">&quot;terra&quot;</span>))</span>
<span id="cb212-2"><a href="#cb212-2" tabindex="-1"></a>v <span class="ot">&lt;-</span> <span class="fu">values</span>(r)</span>
<span id="cb212-3"><a href="#cb212-3" tabindex="-1"></a>v[<span class="dv">3075</span><span class="sc">:</span><span class="dv">3080</span>, ]</span></code></pre></div>
<pre><code>## [1] 324 288 342 313 311 291</code></pre>
<div class="sourceCode" id="cb214"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb214-1"><a href="#cb214-1" tabindex="-1"></a><span class="fu">values</span>(r, <span class="at">row=</span><span class="dv">33</span>, <span class="at">nrow=</span><span class="dv">1</span>, <span class="at">col=</span><span class="dv">35</span>, <span class="at">ncol=</span><span class="dv">6</span>)</span></code></pre></div>
<pre><code>##      elevation
## [1,]       324
## [2,]       288
## [3,]       342
## [4,]       313
## [5,]       311
## [6,]       291</code></pre>
<p>You can also read values using cell numbers or coordinates (xy) using
the <code>extract</code> method.</p>
<div class="sourceCode" id="cb216"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb216-1"><a href="#cb216-1" tabindex="-1"></a>cells <span class="ot">&lt;-</span> <span class="fu">cellFromRowCol</span>(r, <span class="dv">33</span>, <span class="dv">35</span><span class="sc">:</span><span class="dv">40</span>)</span>
<span id="cb216-2"><a href="#cb216-2" tabindex="-1"></a>cells</span></code></pre></div>
<pre><code>## [1] 3075 3076 3077 3078 3079 3080</code></pre>
<div class="sourceCode" id="cb218"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb218-1"><a href="#cb218-1" tabindex="-1"></a>r[cells]</span></code></pre></div>
<pre><code>##   elevation
## 1       324
## 2       288
## 3       342
## 4       313
## 5       311
## 6       291</code></pre>
<div class="sourceCode" id="cb220"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb220-1"><a href="#cb220-1" tabindex="-1"></a>xy <span class="ot">&lt;-</span> <span class="fu">xyFromCell</span>(r, cells)</span>
<span id="cb220-2"><a href="#cb220-2" tabindex="-1"></a>xy</span></code></pre></div>
<pre><code>##             x        y
## [1,] 6.029167 49.92083
## [2,] 6.037500 49.92083
## [3,] 6.045833 49.92083
## [4,] 6.054167 49.92083
## [5,] 6.062500 49.92083
## [6,] 6.070833 49.92083</code></pre>
<div class="sourceCode" id="cb222"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb222-1"><a href="#cb222-1" tabindex="-1"></a><span class="fu">extract</span>(r, xy)</span></code></pre></div>
<pre><code>##   elevation
## 1       324
## 2       288
## 3       342
## 4       313
## 5       311
## 6       291</code></pre>
<p>You can also extract values using <code>SpatVector</code> objects.
The default approach for extracting raster values with polygons is that
a polygon has to cover the center of a cell, for the cell to be
included. However, you can use argument <code>weights=TRUE</code> in
which case you get, apart from the cell values, the percentage of each
cell that is covered by the polygon, so that you can apply, e.g., a “50%
area covered” threshold, or compute an area-weighted average.</p>
<p>In the case of lines, any cell that is crossed by a line is included.
For lines and points, a cell that is only ‘touched’ is included when it
is below or to the right (or both) of the line segment/point (except for
the bottom row and right-most column).</p>
<p>In addition, you can use standard R indexing to access values, or to
replace values (assign new values to cells) in a <code>SpatRaster</code>
object. If you replace a value in a <code>SpatRaster</code> object based
on a file, the connection to that file is lost (because it now is
different from that file). Setting raster values for very large files
will be very slow with this approach as each time a new (temporary)
file, with all the values, is written to disk. If you want to overwrite
values in an existing file, you can use <code>update</code> (with
caution!)</p>
<div class="sourceCode" id="cb224"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb224-1"><a href="#cb224-1" tabindex="-1"></a>r[cells]</span></code></pre></div>
<pre><code>##   elevation
## 1       324
## 2       288
## 3       342
## 4       313
## 5       311
## 6       291</code></pre>
<div class="sourceCode" id="cb226"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb226-1"><a href="#cb226-1" tabindex="-1"></a>r[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>]</span></code></pre></div>
<pre><code>##   elevation
## 1        NA
## 2        NA
## 3        NA
## 4        NA</code></pre>
<div class="sourceCode" id="cb228"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb228-1"><a href="#cb228-1" tabindex="-1"></a><span class="fu">sources</span>(r)</span></code></pre></div>
<pre><code>## [1] &quot;C:/Users/Vianney Denis/AppData/Local/R/win-library/4.2/terra/ex/elev.tif&quot;</code></pre>
<div class="sourceCode" id="cb230"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb230-1"><a href="#cb230-1" tabindex="-1"></a>r[<span class="dv">2</span><span class="sc">:</span><span class="dv">5</span>] <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb230-2"><a href="#cb230-2" tabindex="-1"></a>r[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>]</span></code></pre></div>
<pre><code>##   elevation
## 1        NA
## 2        10
## 3        10
## 4        10</code></pre>
<div class="sourceCode" id="cb232"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb232-1"><a href="#cb232-1" tabindex="-1"></a><span class="fu">sources</span>(r)</span></code></pre></div>
<pre><code>## [1] &quot;&quot;</code></pre>
<p>Note that in the above examples values are retrieved using cell
numbers. That is, a raster is represented as a (one-dimensional) vector.
Values can also be inspected using a (two-dimensional) matrix notation.
As for R matrices, the first index represents the row number, the second
the column number.</p>
<div class="sourceCode" id="cb234"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb234-1"><a href="#cb234-1" tabindex="-1"></a>r[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>]</span></code></pre></div>
<pre><code>##   elevation
## 1        NA
## 2        10
## 3        10</code></pre>
<div class="sourceCode" id="cb236"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb236-1"><a href="#cb236-1" tabindex="-1"></a>r[<span class="dv">1</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>]</span></code></pre></div>
<pre><code>##   elevation
## 1        NA
## 2        10
## 3        10</code></pre>
<div class="sourceCode" id="cb238"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb238-1"><a href="#cb238-1" tabindex="-1"></a>r[<span class="dv">1</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span></code></pre></div>
<pre><code>##   elevation
## 1        NA
## 2        10
## 3        10
## 4        10
## 5        10</code></pre>
<div class="sourceCode" id="cb240"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb240-1"><a href="#cb240-1" tabindex="-1"></a>r[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>, <span class="dv">2</span>]</span></code></pre></div>
<pre><code>##   elevation
## 1        10
## 2        NA
## 3        NA
## 4        NA
## 5        NA</code></pre>
<div class="sourceCode" id="cb242"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb242-1"><a href="#cb242-1" tabindex="-1"></a>r[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>]</span></code></pre></div>
<pre><code>##   elevation
## 1        NA
## 2        10
## 3        10
## 4        NA
## 5        NA
## 6        NA
## 7        NA
## 8        NA
## 9        NA</code></pre>
<div class="sourceCode" id="cb244"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb244-1"><a href="#cb244-1" tabindex="-1"></a><span class="co"># get a vector instead of a a matrix</span></span>
<span id="cb244-2"><a href="#cb244-2" tabindex="-1"></a>r[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, drop<span class="ot">=</span><span class="cn">TRUE</span>]</span></code></pre></div>
<pre><code>##   elevation
## 1        NA
## 2        10
## 3        10
## 4        NA
## 5        NA
## 6        NA
## 7        NA
## 8        NA
## 9        NA</code></pre>
<div class="sourceCode" id="cb246"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb246-1"><a href="#cb246-1" tabindex="-1"></a><span class="co"># or a raster like matrix</span></span>
<span id="cb246-2"><a href="#cb246-2" tabindex="-1"></a><span class="fu">as.matrix</span>(r, <span class="at">wide=</span><span class="cn">TRUE</span>)[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>]</span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   NA   10   10   10
## [2,]   NA   NA   NA   NA
## [3,]   NA   NA   NA   NA</code></pre>
<p>Accessing values through this type of indexing should be avoided
inside functions as it is less efficient than accessing values via
functions like <code>getValues</code>.</p>
</div>
<div id="coercion-to-other-classes" class="section level2">
<h2>Coercion to other classes</h2>
<p>You can convert <code>SpatRaster</code> objects to
<code>Raster*</code> objects defined in the raster package.</p>
<div class="sourceCode" id="cb248"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb248-1"><a href="#cb248-1" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(<span class="at">ncol=</span><span class="dv">36</span>, <span class="at">nrow=</span><span class="dv">18</span>)</span>
<span id="cb248-2"><a href="#cb248-2" tabindex="-1"></a><span class="fu">values</span>(r) <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="fu">ncell</span>(r))</span>
<span id="cb248-3"><a href="#cb248-3" tabindex="-1"></a><span class="fu">library</span>(raster)</span></code></pre></div>
<pre><code>## Warning: package &#39;raster&#39; was built under R version 4.3.0</code></pre>
<pre><code>## Loading required package: sp</code></pre>
<pre><code>## Warning: package &#39;sp&#39; was built under R version 4.3.0</code></pre>
<pre><code>## 
## Attaching package: &#39;raster&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:dplyr&#39;:
## 
##     select</code></pre>
<div class="sourceCode" id="cb254"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb254-1"><a href="#cb254-1" tabindex="-1"></a><span class="do">## Loading required package: sp</span></span>
<span id="cb254-2"><a href="#cb254-2" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">raster</span>(r)</span></code></pre></div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
